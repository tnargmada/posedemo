function _g(n,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(r){if(r!=="default"&&!(r in n)){var s=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return t[r]}})}})}),Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}const Ag=function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function t(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerpolicy&&(o.referrerPolicy=s.referrerpolicy),s.crossorigin==="use-credentials"?o.credentials="include":s.crossorigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=t(s);fetch(s.href,o)}};Ag();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Og=1e-7,Fg=1e-4;class Dg{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Jl{refCount(e){return St("refCount")}incRef(e){return St("incRef")}timerAvailable(){return!0}time(e){return St("time")}read(e){return St("read")}readSync(e){return St("readSync")}readToGPU(e,t){return St("readToGPU")}numDataIds(){return St("numDataIds")}disposeData(e,t){return St("disposeData")}write(e,t,r){return St("write")}move(e,t,r,s,o){return St("move")}memory(){return St("memory")}floatPrecision(){return St("floatPrecision")}epsilon(){return this.floatPrecision()===32?Og:Fg}dispose(){return St("dispose")}}function St(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n,e,t){return Math.max(n,Math.min(e,t))}function ec(n){return n%2===0?n:n+1}function Yr(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function Pg(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function I(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Qt(n,e,t=""){I(ze(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function ia(n){I(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function $r(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||nn(n)&&!t)for(let r=0;r<n.length;++r)$r(n[r],e,t);else e.push(n);return e}function j(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function ze(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function ss(n){return n%1===0}function hi(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function xr(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function du(n,e=r=>0,t){return new Promise((r,s)=>{let o=0;const i=()=>{if(n()){r();return}o++;const a=e(o);if(t!=null&&o>=t){s();return}setTimeout(i,a)};i()})}function Lg(n,e){let t=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function et(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),I(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),I(n.every(r=>ss(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Rn(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:et(e,n).sort();let i=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[i]==null||o[i]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),o[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function Cn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function At(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Bg(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Vg(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Mg(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function nn(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function pi(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Ug(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function uo(n){return typeof n=="string"||n instanceof String}function Wg(n){return typeof n=="boolean"}function zg(n){return typeof n=="number"}function lo(n){return Array.isArray(n)?lo(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":zg(n)?"float32":uo(n)?"string":Wg(n)?"bool":"float32"}function fu(n){return!!(n&&n.constructor&&n.call&&n.apply)}function di(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function rt(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function tc(n,e,t,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=t[n+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<o;u++)s[u]=tc(n+u*a,i,t,r)}return s}function fi(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,o)=>s*o)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return tc(0,n,e,t)}function nc(n,e){const t=Nn(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Nn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function rc(n){n.forEach(e=>{I(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function mi(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function sc(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function Sr(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mu="tfjsflags";class Gg{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Hg,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Sr(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);mu in e&&e[mu].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=Kg(s,o)})}}function Hg(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(jg(e,r[0],r[1]),r.join("="))),e}function jg(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Kg(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function L(){return oc}let oc=null;function Xg(n){oc=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Mo;function ic(){if(Mo==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");Mo=n}return Mo}function qg(){const n=ic();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function aa(n,e){const t=qg();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const ac="Abs",uc="Acos",lc="Acosh",ua="Add",cc="AddN",hc="All",pc="Any",dc="ArgMax",fc="ArgMin",mc="Asin",gc="Asinh",yc="Atan",xc="Atanh",bc="Atan2",wc="AvgPool",Yg="AvgPoolGrad",vc="AvgPool3D",Qg="AvgPool3DGrad",$c="BatchMatMul",Sc="BatchToSpaceND",Tc="Bincount",Cc="BroadcastArgs",la="Cast",Nc="Ceil",Ec="ClipByValue",Ic="Complex",kc="ComplexAbs",Rc="Concat",_c="Conv2D",Ac="Conv2DBackpropFilter",Oc="Conv2DBackpropInput",Fc="Conv3D",Zg="Conv3DBackpropFilterV2",Jg="Conv3DBackpropInputV2",Dc="Cos",Pc="Cosh",Lc="Cumprod",Bc="Cumsum",Vc="CropAndResize",Mc="DenseBincount",Uc="DepthToSpace",Wc="DepthwiseConv2dNative",zc="DepthwiseConv2dNativeBackpropFilter",Gc="DepthwiseConv2dNativeBackpropInput",ey="Diag",Hc="Dilation2D",jc="RealDiv",Kc="Einsum",Xc="Elu",ty="EluGrad",qc="Erf",Yc="Equal",Qc="Exp",Zc="ExpandDims",Jc="Expm1",eh="FFT",th="Fill",nh="FlipLeftRight",rh="Floor",sh="FloorDiv",oh="FusedBatchNorm",ih="GatherV2",ah="GatherNd",uh="Greater",lh="GreaterEqual",ca="Identity",ch="IFFT",hh="Imag",ny="IsFinite",ry="IsInf",ph="IsNan",dh="LeakyRelu",fh="Less",mh="LessEqual",gh="LinSpace",yh="Log",xh="Log1p",bh="LogicalAnd",wh="LogicalNot",vh="LogicalOr",$h="LRN",sy="LRNGrad",Sh="Max",Th="Maximum",Ch="MaxPool",oy="MaxPoolGrad",Nh="MaxPool3D",iy="MaxPool3DGrad",Eh="MaxPoolWithArgmax",Ih="Mean",kh="Min",Rh="Minimum",_h="MirrorPad",Ah="Mod",Oh="Multinomial",Fh="Multiply",Dh="Neg",Ph="NotEqual",Lh="NonMaxSuppressionV3",Bh="NonMaxSuppressionV4",Vh="NonMaxSuppressionV5",Mh="OnesLike",Uh="OneHot",Wh="Pack",zh="PadV2",Gh="Pow",Hh="Prelu",jh="Prod",Kh="Range",Xh="Real",qh="Reciprocal",Yh="Relu",Qh="Reshape",Zh="ResizeNearestNeighbor",ay="ResizeNearestNeighborGrad",Jh="ResizeBilinear",uy="ResizeBilinearGrad",ep="Relu6",tp="Reverse",np="Round",rp="Rsqrt",sp="ScatterNd",op="SearchSorted",ip="Select",ap="Selu",up="Slice",lp="Sin",cp="Sinh",hp="Sign",pp="Sigmoid",dp="Softplus",fp="Sqrt",mp="Sum",gp="SpaceToBatchND",yp="SplitV",xp="Softmax",bp="SparseFillEmptyRows",wp="SparseReshape",vp="SparseSegmentMean",$p="SparseSegmentSum",Sp="SparseToDense",Tp="SquaredDifference",ly="Square",Cp="StridedSlice",Np="StringNGrams",Ep="StringSplit",Ip="StringToHashBucketFast",kp="Sub",Rp="Tan",_p="Tanh",ha="Tile",Ap="TopK",Op="Transform",Ws="Transpose",Fp="Unique",Dp="Unpack",cy="UnsortedSegmentSum",Pp="ZerosLike",Lp="Step",gi="FromPixels",Bp="RotateWithOffset",yi="_FusedMatMul",xi="FusedConv2D",bi="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(...n){L().getBool("IS_TEST")||L().getBool("PROD")||console.warn(...n)}function hy(...n){L().getBool("IS_TEST")||L().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xs=aa("kernelRegistry",()=>new Map),py=aa("gradRegistry",()=>new Map);function wi(n,e){const t=Vp(n,e);return Xs.get(t)}function gu(n){return py.get(n)}function yu(n){const e=Xs.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===n&&t.push(i)}return t}function dy(n){const{kernelName:e,backendName:t}=n,r=Vp(e,t);Xs.has(r)&&Xt(`The kernel '${e}' for backend '${t}' is already registered`),Xs.set(r,n)}function Vp(n,e){return`${e}_${n}`}var hn=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},vi=Pe,Ot=null;try{Ot=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Pe(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Pe.prototype.__isLong__;Object.defineProperty(Pe.prototype,"__isLong__",{value:!0});function vt(n){return(n&&n.__isLong__)===!0}Pe.isLong=vt;var xu={},bu={};function Jn(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=bu[n],r)?r:(t=Le(n,(n|0)<0?-1:0,!0),s&&(bu[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=xu[n],r)?r:(t=Le(n,n<0?-1:0,!1),s&&(xu[n]=t),t))}Pe.fromInt=Jn;function Ft(n,e){if(isNaN(n))return e?Un:Dt;if(e){if(n<0)return Un;if(n>=Mp)return zp}else{if(n<=-vu)return yt;if(n+1>=vu)return Wp}return n<0?Ft(-n,e).neg():Le(n%Tr|0,n/Tr|0,e)}Pe.fromNumber=Ft;function Le(n,e,t){return new Pe(n,e,t)}Pe.fromBits=Le;var qs=Math.pow;function pa(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Dt;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return pa(n.substring(1),e,t).neg();for(var s=Ft(qs(t,8)),o=Dt,i=0;i<n.length;i+=8){var a=Math.min(8,n.length-i),u=parseInt(n.substring(i,i+a),t);if(a<8){var l=Ft(qs(t,a));o=o.mul(l).add(Ft(u))}else o=o.mul(s),o=o.add(Ft(u))}return o.unsigned=e,o}Pe.fromString=pa;function Zt(n,e){return typeof n=="number"?Ft(n,e):typeof n=="string"?pa(n,e):Le(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Pe.fromValue=Zt;var wu=1<<16,fy=1<<24,Tr=wu*wu,Mp=Tr*Tr,vu=Mp/2,$u=Jn(fy),Dt=Jn(0);Pe.ZERO=Dt;var Un=Jn(0,!0);Pe.UZERO=Un;var yr=Jn(1);Pe.ONE=yr;var Up=Jn(1,!0);Pe.UONE=Up;var $i=Jn(-1);Pe.NEG_ONE=$i;var Wp=Le(-1,2147483647,!1);Pe.MAX_VALUE=Wp;var zp=Le(-1,-1,!0);Pe.MAX_UNSIGNED_VALUE=zp;var yt=Le(0,-2147483648,!1);Pe.MIN_VALUE=yt;var K=Pe.prototype;K.toInt=function(){return this.unsigned?this.low>>>0:this.low};K.toNumber=function(){return this.unsigned?(this.high>>>0)*Tr+(this.low>>>0):this.high*Tr+(this.low>>>0)};K.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(yt)){var t=Ft(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=Ft(qs(e,6),this.unsigned),i=this,a="";;){var u=i.div(o),l=i.sub(u.mul(o)).toInt()>>>0,c=l.toString(e);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};K.getHighBits=function(){return this.high};K.getHighBitsUnsigned=function(){return this.high>>>0};K.getLowBits=function(){return this.low};K.getLowBitsUnsigned=function(){return this.low>>>0};K.getNumBitsAbs=function(){if(this.isNegative())return this.eq(yt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};K.isZero=function(){return this.high===0&&this.low===0};K.eqz=K.isZero;K.isNegative=function(){return!this.unsigned&&this.high<0};K.isPositive=function(){return this.unsigned||this.high>=0};K.isOdd=function(){return(this.low&1)===1};K.isEven=function(){return(this.low&1)===0};K.equals=function(e){return vt(e)||(e=Zt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};K.eq=K.equals;K.notEquals=function(e){return!this.eq(e)};K.neq=K.notEquals;K.ne=K.notEquals;K.lessThan=function(e){return this.comp(e)<0};K.lt=K.lessThan;K.lessThanOrEqual=function(e){return this.comp(e)<=0};K.lte=K.lessThanOrEqual;K.le=K.lessThanOrEqual;K.greaterThan=function(e){return this.comp(e)>0};K.gt=K.greaterThan;K.greaterThanOrEqual=function(e){return this.comp(e)>=0};K.gte=K.greaterThanOrEqual;K.ge=K.greaterThanOrEqual;K.compare=function(e){if(vt(e)||(e=Zt(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};K.comp=K.compare;K.negate=function(){return!this.unsigned&&this.eq(yt)?yt:this.not().add(yr)};K.neg=K.negate;K.add=function(e){vt(e)||(e=Zt(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,i=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,h=0,p=0,d=0;return d+=o+l,p+=d>>>16,d&=65535,p+=s+u,h+=p>>>16,p&=65535,h+=r+a,c+=h>>>16,h&=65535,c+=t+i,c&=65535,Le(p<<16|d,c<<16|h,this.unsigned)};K.subtract=function(e){return vt(e)||(e=Zt(e)),this.add(e.neg())};K.sub=K.subtract;K.multiply=function(e){if(this.isZero())return Dt;if(vt(e)||(e=Zt(e)),Ot){var t=Ot.mul(this.low,this.high,e.low,e.high);return Le(t,Ot.get_high(),this.unsigned)}if(e.isZero())return Dt;if(this.eq(yt))return e.isOdd()?yt:Dt;if(e.eq(yt))return this.isOdd()?yt:Dt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt($u)&&e.lt($u))return Ft(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,i=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,h=0,p=0,d=0,f=0;return f+=i*c,d+=f>>>16,f&=65535,d+=o*c,p+=d>>>16,d&=65535,d+=i*l,p+=d>>>16,d&=65535,p+=s*c,h+=p>>>16,p&=65535,p+=o*l,h+=p>>>16,p&=65535,p+=i*u,h+=p>>>16,p&=65535,h+=r*c+s*l+o*u+i*a,h&=65535,Le(d<<16|f,h<<16|p,this.unsigned)};K.mul=K.multiply;K.divide=function(e){if(vt(e)||(e=Zt(e)),e.isZero())throw Error("division by zero");if(Ot){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Ot.div_u:Ot.div_s)(this.low,this.high,e.low,e.high);return Le(t,Ot.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Un:Dt;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Un;if(e.gt(this.shru(1)))return Up;o=Un}else{if(this.eq(yt)){if(e.eq(yr)||e.eq($i))return yt;if(e.eq(yt))return yr;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(Dt)?e.isNegative()?yr:$i:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}else if(e.eq(yt))return this.unsigned?Un:Dt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=Dt}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),u=a<=48?1:qs(2,a-48),l=Ft(r),c=l.mul(e);c.isNegative()||c.gt(s);)r-=u,l=Ft(r,this.unsigned),c=l.mul(e);l.isZero()&&(l=yr),o=o.add(l),s=s.sub(c)}return o};K.div=K.divide;K.modulo=function(e){if(vt(e)||(e=Zt(e)),Ot){var t=(this.unsigned?Ot.rem_u:Ot.rem_s)(this.low,this.high,e.low,e.high);return Le(t,Ot.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};K.mod=K.modulo;K.rem=K.modulo;K.not=function(){return Le(~this.low,~this.high,this.unsigned)};K.and=function(e){return vt(e)||(e=Zt(e)),Le(this.low&e.low,this.high&e.high,this.unsigned)};K.or=function(e){return vt(e)||(e=Zt(e)),Le(this.low|e.low,this.high|e.high,this.unsigned)};K.xor=function(e){return vt(e)||(e=Zt(e)),Le(this.low^e.low,this.high^e.high,this.unsigned)};K.shiftLeft=function(e){return vt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Le(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Le(0,this.low<<e-32,this.unsigned)};K.shl=K.shiftLeft;K.shiftRight=function(e){return vt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Le(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Le(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};K.shr=K.shiftRight;K.shiftRightUnsigned=function(e){if(vt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return Le(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Le(t,0,this.unsigned):Le(t>>>e-32,0,this.unsigned)};K.shru=K.shiftRightUnsigned;K.shr_u=K.shiftRightUnsigned;K.toSigned=function(){return this.unsigned?Le(this.low,this.high,!1):this};K.toUnsigned=function(){return this.unsigned?this:Le(this.low,this.high,!0)};K.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};K.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};K.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Pe.fromBytes=function(e,t,r){return r?Pe.fromBytesLE(e,t):Pe.fromBytesBE(e,t)};Pe.fromBytesLE=function(e,t){return new Pe(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Pe.fromBytesBE=function(e,t){return new Pe(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};var my=_g({__proto__:null,default:vi},[vi]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vn=vi||my;function co(n){return Vn.fromString(n,!0,16)}const Gp=co("c3a5c85c97cb3127"),Ln=co("b492b66fbe98f273"),ut=co("9ae16a3b2f90404f");function Si(n){return n.xor(n.shru(47))}function Hp(n,e,t){const r=n.slice(e,e+t);return Vn.fromBytes(Array.from(r),!0,!0)}function Oe(n,e){return Hp(n,e,8)}function Su(n,e){return Hp(n,e,4)}function Qe(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function vn(n,e,t=co("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function gy(n,e,t,r,s,o){s=s.add(n),o=Qe(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(t),o=o.add(Qe(s,44)),[s.add(r),o.add(i)]}function Os(n,e,t,r){return gy(Oe(n,e),Oe(n,e+8),Oe(n,e+16),Oe(n,e+24),t,r)}function yy(n,e=n.length){if(e>=8){const t=ut.add(e*2),r=Oe(n,0).add(ut),s=Oe(n,e-8),o=Qe(s,37).mul(t).add(r),i=Qe(r,25).add(s).mul(t);return vn(o,i,t)}if(e>=4){const t=ut.add(e*2),r=Su(n,0);return vn(r.shl(3).add(e),Su(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],o=t+(r<<8),i=e+(s<<2);return Si(ut.mul(o).xor(Gp.mul(i))).mul(ut)}return ut}function xy(n,e=n.length){const t=ut.add(e*2),r=Oe(n,0).mul(Ln),s=Oe(n,8),o=Oe(n,e-8).mul(t),i=Oe(n,e-16).mul(ut);return vn(Qe(r.add(s),43).add(Qe(o,30)).add(i),r.add(Qe(s.add(ut),18)).add(o),t)}function by(n,e=n.length){const t=ut.add(e*2),r=Oe(n,0).mul(ut),s=Oe(n,8),o=Oe(n,e-8).mul(t),i=Oe(n,e-16).mul(ut),a=Qe(r.add(s),43).add(Qe(o,30)).add(i),u=vn(a,r.add(Qe(s.add(ut),18)).add(o),t),l=Oe(n,16).mul(t),c=Oe(n,24),h=a.add(Oe(n,e-32)).mul(t),p=u.add(Oe(n,e-24)).mul(t);return vn(Qe(l.add(c),43).add(Qe(h,30)).add(p),l.add(Qe(c.add(r),18)).add(h),t)}function wy(n,e=n.length){const t=Vn.fromNumber(81,!0);if(e<=32)return e<=16?yy(n,e):xy(n,e);if(e<=64)return by(n,e);let r=t,s=t.mul(Ln).add(113),o=Si(s.mul(ut).add(113)).mul(ut),i=[Vn.UZERO,Vn.UZERO],a=[Vn.UZERO,Vn.UZERO];r=r.mul(ut).add(Oe(n,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do r=Qe(r.add(s).add(i[0]).add(Oe(n,u+8)),37).mul(Ln),s=Qe(s.add(i[1]).add(Oe(n,u+48)),42).mul(Ln),r=r.xor(a[1]),s=s.add(i[0]).add(Oe(n,u+40)),o=Qe(o.add(a[0]),33).mul(Ln),i=Os(n,u,i[1].mul(Ln),r.add(a[0])),a=Os(n,u+32,o.add(a[1]),s.add(Oe(n,u+16))),[o,r]=[r,o],u+=64;while(u!==l);const h=Ln.add(o.and(255).shl(1));return u=c,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Qe(r.add(s).add(i[0]).add(Oe(n,u+8)),37).mul(h),s=Qe(s.add(i[1]).add(Oe(n,u+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Oe(n,u+40))),o=Qe(o.add(a[0]),33).mul(h),i=Os(n,u,i[1].mul(h),r.add(a[0])),a=Os(n,u+32,o.add(a[1]),s.add(Oe(n,u+16))),[o,r]=[r,o],vn(vn(i[0],a[0],h).add(Si(s).mul(Gp)).add(o),vn(i[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ar(n,e){return e==="string"?Hn(n):da([n],e)}function vy(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function da(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=$r(n)),L().getBool("DEBUG")&&Bg(n,e),vy(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function jt(){return L().platform.now()}function Hn(n,e="utf-8"){return e=e||"utf-8",L().platform.encode(n,e)}function Cr(n,e="utf-8"){return e=e||"utf-8",L().platform.decode(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $y{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Ty)}profileKernel(e,t,r){let s;const o=()=>{s=r()};let i;const a=jt();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const l of s)l.dataSync();i=Promise.resolve({kernelMs:jt()-a})}if(L().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const c=s[l];c.data().then(h=>{Sy(h,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(u=>{this.logger.logKernelProfile(t,a,u[0],u[1],o,u[2])})})}}function Sy(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class Ty{logKernelProfile(e,t,r,s,o,i){const a=typeof s=="number"?xr(`${s}ms`,9):s.error,u=xr(e,25),l=t.rank,c=t.size,h=xr(t.shape.toString(),14);let p="";for(const d in o){const f=o[d];if(f!=null){const g=f.shape||t.shape,y=g.length;p+=`${d}: ${y}D ${y>0?g:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${h}	%c${c}	%c${p}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cy(n,e,t){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],c=l.inputs;for(const h in c){const p=c[h];let d=!1;for(let f=0;f<e.length;f++)if(r[p.id]){l.outputs.forEach(g=>r[g.id]=!0),d=!0,s[l.id]=!0;break}if(d)break}}const o={};o[t.id]=!0;const i={};for(let u=n.length-1;u>=0;u--){const l=n[u],c=l.inputs;for(let h=0;h<l.outputs.length;h++)if(o[l.outputs[h].id]){for(const p in c)o[c[p].id]=!0,i[l.id]=!0;break}}const a=[];for(let u=0;u<n.length;u++){const l=n[u];if(s[l.id]&&i[l.id]){const c={};for(const p in l.inputs){const d=l.inputs[p];r[d.id]&&(c[p]=d)}const h=Object.assign({},l);h.inputs=c,h.outputs=l.outputs,a.push(h)}}return a}function Ny(n,e,t,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(u=>{const l=n[u.id];l!=null?i.push(l):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const u in o.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const l=t(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=o.inputs[u];if(!ze(l.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=l;else{const h=n[c.id];n[c.id]=r(h,l),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=20,Qr=3,Uo=7;function Ey(n,e,t,r){const s=rt(e),o=Iy(n,e,t,s),i=e.length,a=zs(n,e,t,s,o),u=["Tensor"];return r&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function Iy(n,e,t,r){const s=j(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,u=t==="complex64"?ts(n):n;if(a>1)for(let l=0;l<s/o;l++){const c=l*o;for(let h=0;h<o;h++)i[h]=Math.max(i[h],es(u[c+h],0,t).length)}return i}function es(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Uo))} + ${parseFloat(n[1].toFixed(Uo))}j`:uo(n)?r=`'${n}'`:t==="bool"?r=jp(n):r=parseFloat(n.toFixed(Uo)).toString(),xr(r,e)}function jp(n){return n===0?"false":"true"}function zs(n,e,t,r,s,o=!0){const i=t==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(t==="complex64"){const g=ts(n);return[es(g[0],0,t)]}return t==="bool"?[jp(n[0])]:[n[0].toString()]}if(u===1){if(a>Tu){const y=Qr*i;let w=Array.from(n.slice(0,y)),$=Array.from(n.slice((a-Qr)*i,a*i));return t==="complex64"&&(w=ts(w),$=ts($)),["["+w.map((S,T)=>es(S,s[T],t)).join(", ")+", ..., "+$.map((S,T)=>es(S,s[a-Qr+T],t)).join(", ")+"]"]}const g=t==="complex64"?ts(n):Array.from(n);return["["+g.map((y,w)=>es(y,s[w],t)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),h=r[0]*i,p=[];if(a>Tu){for(let g=0;g<Qr;g++){const y=g*h,w=y+h;p.push(...zs(n.slice(y,w),l,t,c,s,!1))}p.push("...");for(let g=a-Qr;g<a;g++){const y=g*h,w=y+h;p.push(...zs(n.slice(y,w),l,t,c,s,g===a-1))}}else for(let g=0;g<a;g++){const y=g*h,w=y+h;p.push(...zs(n.slice(y,w),l,t,c,s,g===a-1))}const d=u===2?",":"";p[0]="["+p[0]+d;for(let g=1;g<p.length-1;g++)p[g]=" "+p[g]+d;let f=`,
`;for(let g=2;g<u;g++)f+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(o?"":f),p}function ts(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class os{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=j(e),r!=null){const s=r.length;I(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||At(t,this.size),this.strides=rt(e)}set(e,...t){t.length===0&&(t=[0]),I(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Kt().makeTensor(this.values,this.shape,this.dtype)}}let Kt=null,fr=null;function ky(n){Kt=n}function Ry(n){fr=n}class Xe{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=j(e),this.strides=rt(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return fr.buffer(this.shape,this.dtype,e)}bufferSync(){return fr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return fi(this.shape,e,this.dtype==="complex64")}arraySync(){return fi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Kt().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>Cr(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Kt().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Kt().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Cr(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Kt().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Kt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return fr.print(this,e)}clone(){return this.throwIfDisposed(),fr.clone(this)}toString(e=!1){const t=this.dataSync();return Ey(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),fr.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Kt().makeVariable(this,e,t,r)}}Object.defineProperty(Xe,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function _y(){return aa("Tensor",()=>Xe)}_y();class Ti extends Xe{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ze(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Kt().disposeTensor(this),this.dataId=e.dataId,Kt().incRef(this,null)}dispose(){Kt().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ti,Symbol.hasInstance,{value:n=>n instanceof Xe&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Cu;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Cu||(Cu={}));var Ci;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Ci||(Ci={}));var Ni;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Ni||(Ni={}));var Ei;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Ei||(Ei={}));var Ii;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Ii||(Ii={}));const Ay={float32:Ei,int32:Ci,bool:Ni,complex64:Ii};function rn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Ay[n][e]}function fa(n){return rn(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Be(n,e){if(n.dtype===e.dtype)return[n,e];const t=rn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function Kp(n){const e=[];return Xp(n,e,new Set),e}function Xp(n,e,t){if(n==null)return;if(n instanceof Xe){e.push(n);return}if(!Oy(n))return;const r=n;for(const s in r){const o=r[s];t.has(o)||(t.add(o),Xp(o,e,t))}}function Oy(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wo(n){return n.kernelName!=null}class Nu{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Nr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Nu}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Xt(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new $y(this.backendInstance),!0}setupRegisteredKernels(){yu(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){yu(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof Jl)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Xt(`Initialization of backend ${e} failed`),Xt(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Xt(`Initialization of backend ${e} failed`),Xt(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,o=this.readSync(t),i=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Nr.nextTensorId++}nextVariableId(){return Nr.nextVariableId++}clone(e){const t=_.runKernel(ca,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",u={x:i},l={dtype:a};return _.runKernel(la,u,l)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,o,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(wi(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let o=0;r.forEach(u=>{o+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u;const l=Wo(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Wo(e)){const{kernelName:f,inputs:g,attrs:y}=e;this.backendName==null&&this.backend;const w=wi(f,this.backendName);I(w!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const $=this.backend.numDataIds();u=w.kernelFunc({inputs:g,attrs:y,backend:this.backend});const S=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,$,S);const T=S.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(s){const N=this.getTensorsForGradient(f,g,T);r=this.saveTensorsForBackwardMode(N)}return T}}else{const{forwardFunc:f}=e,g=y=>{!s||(r=y.map(w=>this.keep(this.clone(w))))};a=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,g));const w=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,y,w),w}}const{inputs:c,attrs:h}=e,p=Wo(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),s&&this.addTapeNode(l,c,t,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=gu(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(I(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=o.map(l=>t[l]);const u=r.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&uo(e[0])&&(o=e.map(u=>Hn(u)));const i=s.write(o,t,r),a=new Xe(t,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const u=this.state.tensorInfo.get(i),l=Ug(o);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const o={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:o}=e,i=new Xe(s,o,r,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new Ti(e,t,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*pi(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Ti||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*pi(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:o},u=gu(e);u!=null&&(s=u.gradFunc),s!=null&&(a.gradient=l=>(l=l.map((c,h)=>{if(c==null){const p=r[h],d=Nn(p.size,p.dtype);return this.makeTensor(d,p.shape,p.dtype)}return c}),s(l.length>1?l:l[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Kp(e),r=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,t,r,s=!1){if(I(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(o instanceof Xe,()=>"The result y returned by f() must be a tensor.");const i=Cy(this.state.activeTape,t,o);if(!s&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r==null?Fy(o.shape):r,Ny(a,i,l=>this.tidy(l),Dy);const u=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return I(fu(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{I(t.every(a=>a instanceof Xe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,u)=>{s[u]=a});const o=(a,u)=>(r=e(...t,u),I(r.value instanceof Xe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(fu(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,u)=>{const l=r.gradFunc(a,u),c=Array.isArray(l)?l:[l];I(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(c.every(p=>p instanceof Xe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((p,d)=>{h[d]=()=>p}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=jt(),r=await this.backend.time(e);return r.wallMs=jt()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Nu;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Nr.nextTensorId=0;Nr.nextVariableId=0;function Fy(n){const e=nc(j(n),"float32");return _.makeTensor(e,n,"float32")}function qp(){const n=ic();if(n._tfengine==null){const e=new Gg(n);n._tfengine=new Nr(e)}return Xg(n._tfengine.ENV),ky(()=>n._tfengine),n._tfengine}const _=qp();function Dy(n,e){const t={a:n,b:e};return _.runKernel(ua,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(){return typeof navigator!="undefined"&&navigator!=null}function Yp(n){if(n||Py()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Qp(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lt=L();Lt.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Lt.registerFlag("IS_BROWSER",()=>Qp());Lt.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Lt.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Lt.registerFlag("PROD",()=>!1);Lt.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Lt.getBool("DEBUG"));Lt.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Lt.registerFlag("IS_TEST",()=>!1);Lt.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Lt.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Lt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys(n,e){let t=n;if(nn(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||nn(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&L().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Zp(n,r,[]),r}function Zp(n,e,t){if(t=t||[],!Array.isArray(n)&&!nn(n)){I(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}I(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),I(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)Zp(n[s],r,t.concat(s))}function Eu(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function C(n,e,t,r="numeric"){if(n instanceof Xe)return Eu(r,n.dtype,e,t),n;let s=lo(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Eu(r,s,e,t),n==null||!nn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=ys(n,s);!nn(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?da(n,s):$r(n,[],!0);return _.makeTensor(a,o,s)}function Jp(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>C(o,`${e}[${i}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ly="__op";function A(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Ly;const s=(...o)=>{_.startScope(t);try{const i=r(...o);return Sr(i)&&console.error("Cannot return a Promise inside of tidy."),_.endScope(i),i}catch(i){throw _.endScope(null),i}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function By(n,e){const t=C(n,"real","complex"),r=C(e,"imag","complex");Qt(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return _.runKernel(Ic,s)}const En=A({complex_:By});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xs(n,e,t,r){if(r==null&&(r=lo(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!nn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){rc(e);const s=j(e),o=j(t);I(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<t.length;++i){const a=t[i],u=i===t.length-1?a!==j(e.slice(i)):!0;I(t[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!nn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?da(n,r):$r(n,[],!0),_.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $n(n,e,t){const r=ys(n,t);return xs(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iu={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ku=4;function Vy(n,e){const t={};let r,s=0;for(const o of e){const i=o.name,a=o.dtype,u=o.shape,l=j(u);let c;if("quantization"in o){const h=o.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${o.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${o.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=Iu[h.dtype],d=n.slice(s,s+l*p),f=h.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(a==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){c=new Float32Array(f.length);for(let g=0;g<f.length;g++){const y=f[g];c[g]=y*h.scale+h.min}}else if(h.dtype==="float16")r===void 0&&(r=Ky()),c=r(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(a==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);c=new Int32Array(f.length);for(let g=0;g<f.length;g++){const y=f[g];c[g]=Math.round(y*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);s+=l*p}else if(a==="string"){const h=j(o.shape);c=[];for(let p=0;p<h;p++){const d=new Uint32Array(n.slice(s,s+ku))[0];s+=ku;const f=new Uint8Array(n.slice(s,s+d));c.push(f),s+=d}}else{const h=Iu[a],p=n.slice(s,s+l*h);if(a==="float32")c=new Float32Array(p);else if(a==="int32")c=new Int32Array(p);else if(a==="bool")c=new Uint8Array(p);else if(a==="complex64"){c=new Float32Array(p);const d=new Float32Array(c.length/2),f=new Float32Array(c.length/2);for(let w=0;w<d.length;w++)d[w]=c[w*2],f[w]=c[w*2+1];const g=$n(d,u,"float32"),y=$n(f,u,"float32");t[i]=En(g,y),g.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);s+=l*h}a!=="complex64"&&(t[i]=$n(c,u,a))}return t}const ma=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function Ru(n){return ma?Buffer.byteLength(n):new Blob([n]).size}function My(n){if(ma)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function Uy(n){if(ma){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function Wy(n){if(n.length===1)return n[0];let e=0;n.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(s=>{t.set(new Uint8Array(s),r),r+=s.byteLength}),t.buffer}function ed(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}async function zy(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),n.weightsManifest!=null){const[r,s]=await e(n.weightsManifest);t.weightSpecs=r,t.weightData=s}return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),t}function ho(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Ru(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Ru(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function Gy(){const n=t=>{let r=t<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Hy(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function jy(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Ky(){const n=Gy(),e=Hy(),t=jy();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],u=n[t[a>>10]+(a&1023)]+e[a>>10];o[i]=u}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ke{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ke.instance==null&&(Ke.instance=new Ke),Ke.instance}static registerSaveRouter(e){Ke.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ke.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ke.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ke.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?Ke.getInstance().loadRouters:Ke.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const Xy=n=>Ke.getSaveHandlers(n),qy=(n,e)=>Ke.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ki="tensorflowjs",Ri=1,Wn="models_store",xn="model_info_store";function td(){if(!L().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window=="undefined"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function _i(n){const e=n.result;e.createObjectStore(Wn,{keyPath:"modelPath"}),e.createObjectStore(xn,{keyPath:"modelPath"})}class Xn{constructor(e){if(this.indexedDB=td(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const o=this.indexedDB.open(ki,Ri);o.onupgradeneeded=()=>_i(o),o.onsuccess=()=>{const i=o.result;if(t==null){const a=i.transaction(Wn,"readonly"),l=a.objectStore(Wn).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=c=>(i.close(),s(l.error)),a.oncomplete=()=>i.close()}else{const a=ho(t),u=i.transaction(xn,"readwrite");let l=u.objectStore(xn);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;c.onsuccess=()=>{h=i.transaction(Wn,"readwrite");const d=h.objectStore(Wn).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});d.onsuccess=()=>r({modelArtifactsInfo:a}),d.onerror=f=>{l=u.objectStore(xn);const g=l.delete(this.modelPath);g.onsuccess=()=>(i.close(),s(d.error)),g.onerror=y=>(i.close(),s(d.error))}},c.onerror=p=>(i.close(),s(c.error)),u.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}Xn.URL_SCHEME="indexeddb://";const nd=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Xn.URL_SCHEME)?Yy(n.slice(Xn.URL_SCHEME.length)):null;Ke.registerSaveRouter(nd);Ke.registerLoadRouter(nd);function Yy(n){return new Xn(n)}function Qy(n){return n.startsWith(Xn.URL_SCHEME)?n.slice(Xn.URL_SCHEME.length):n}class Zy{constructor(){this.indexedDB=td()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(ki,Ri);r.onupgradeneeded=()=>_i(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(xn,"readonly"),a=o.objectStore(xn).getAll();a.onsuccess=()=>{const u={};for(const l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(s.close(),t(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=Qy(e),new Promise((t,r)=>{const s=this.indexedDB.open(ki,Ri);s.onupgradeneeded=()=>_i(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(xn,"readwrite"),a=i.objectStore(xn),u=a.get(e);let l;u.onsuccess=()=>{if(u.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{l=o.transaction(Wn,"readwrite");const d=l.objectStore(Wn).delete(e);d.onsuccess=()=>t(u.result.modelArtifactsInfo),d.onerror=f=>r(u.error)};c.onsuccess=h,c.onerror=p=>(h(),o.close(),r(u.error))}},u.onerror=c=>(o.close(),r(u.error)),i.oncomplete=()=>{l==null?o.close():l.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ln="/",mr="tensorflowjs_models",rd="info",Jy="model_topology",ex="weight_specs",tx="weight_data",nx="model_metadata";function sd(n){return{info:[mr,n,rd].join(ln),topology:[mr,n,Jy].join(ln),weightSpecs:[mr,n,ex].join(ln),weightData:[mr,n,tx].join(ln),modelMetadata:[mr,n,nx].join(ln)}}function od(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function rx(n){const e=n.split(ln);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(ln)}function sx(n){return n.startsWith(qn.URL_SCHEME)?n.slice(qn.URL_SCHEME.length):n}class qn{constructor(e){if(!L().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=sd(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=ho(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,My(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw od(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Uy(i),t}}qn.URL_SCHEME="localstorage://";const id=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(qn.URL_SCHEME)?ox(n.slice(qn.URL_SCHEME.length)):null;Ke.registerSaveRouter(id);Ke.registerLoadRouter(id);function ox(n){return new qn(n)}class ix{constructor(){I(L().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=mr+ln,r=ln+rd;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(t)&&o.endsWith(r)){const i=rx(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=sx(e);const t=sd(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return od(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _u="://";class yn{constructor(){this.managers={}}static getInstance(){return yn.instance==null&&(yn.instance=new yn),yn.instance}static registerManager(e,t){I(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(_u)&&(e=e.slice(0,e.indexOf(_u))),I(e.length>0,()=>"scheme must not be an empty string.");const r=yn.getInstance();I(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ax{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(L().get("IS_BROWSER")){L().setPlatform("browser",new ax);try{yn.registerManager(qn.URL_SCHEME,new ix)}catch{}try{yn.registerManager(Xn.URL_SCHEME,new Zy)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ux={importFetch:()=>require("node-fetch")};let zo;class lx{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return L().global.fetch!=null?L().global.fetch(e,t):(zo==null&&(zo=ux.importFetch()),zo(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}L().get("IS_NODE")&&!L().get("IS_BROWSER")&&L().setPlatform("node",new lx);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ge(n,e="float32",t){return e=e||"float32",rc(n),new os(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(n,e){const t=C(n,"x","cast");if(!Vg(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return _.runKernel(la,r,s)}const _e=A({cast_:cx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hx(n){const t={x:C(n,"x","clone","string_or_numeric")};return _.runKernel(ca,t)}const jn=A({clone_:hx});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function px(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */qp();const dx={buffer:Ge,cast:_e,clone:jn,print:px};Ry(dx);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fx="model",mx=".json",gx=".weights.bin";function Au(n){return new Promise(e=>setTimeout(e)).then(n)}class Yn{constructor(e){if(!L().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Yn.URL_SCHEME)&&(e=e.slice(Yn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=fx),this.modelJsonFileName=e+mx,this.weightDataFileName=e+gx}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],s=ed(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await Au(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await Au(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ho(e)}}}}Yn.URL_SCHEME="downloads://";const yx=n=>L().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Yn.URL_SCHEME)?xx(n.slice(Yn.URL_SCHEME.length)):null;Ke.registerSaveRouter(yx);function xx(n="model"){return new Yn(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ou(n,e,t,r){i(n),t=t==null?0:t,r=r==null?1:r,a(t,r);let s=0;const o=u=>(u.then(l=>{const c=t+ ++s/n.length*(r-t);return e(c),l}),u);function i(u){I(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),I(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),I(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bx(n,e){e==null&&(e={});const t=e.fetchFunc==null?L().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),s=0,o=.5,a=(e.onProgress==null?await Promise.all(r):await Ou(r,e.onProgress,s,o)).map(h=>h.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(a):await Ou(a,e.onProgress,u,l)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wx="application/octet-stream",vx="application/json";class ga{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(I(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=L().platform.fetch,I(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=ed(e,r);t.body.append("model.json",new Blob([JSON.stringify(s)],{type:vx}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:wx}),"model.weights.bin");const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:ho(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return zy(t,o=>this.loadWeights(o))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=$x(t),o=this.weightPathPrefix||r,i=[];for(const c of e)i.push(...c.weights);const a=[],u=[];for(const c of e)for(const h of c.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(h)):a.push(o+h+s);this.weightUrlConverter&&a.push(...await Promise.all(u));const l=await bx(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,Wy(l)]}}ga.URL_SCHEME_REGEX=/^https?:\/\//;function $x(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function Fu(n){return n.match(ga.URL_SCHEME_REGEX)!=null}const ad=(n,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>Fu(r)):t=Fu(n),t)return ud(n,e)}return null};Ke.registerSaveRouter(ad);Ke.registerLoadRouter(ad);function ud(n,e){return new ga(n,e)}function Du(n,e){return ud(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(n,e,t=!1,r=!1){let s=C(n,"a","matMul"),o=C(e,"b","matMul");[s,o]=Be(s,o);const i={a:s,b:o},a={transposeA:t,transposeB:r};return _.runKernel($c,i,a)}const Ye=A({matMul_:Sx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tx(n,e,t=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:C(n,"indices","oneHot","int32")},i={depth:e,onValue:t,offValue:r};return _.runKernel(Uh,o,i)}const Cx=A({oneHot_:Tx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(){return _}function ie(n,e){return _.tidy(n,e)}function it(n){Kp(n).forEach(t=>t.dispose())}function bn(n){return _.keep(n)}function Ys(){return _.backendName}function Nx(n,e,t=1){return _.registerBackend(n,e,t)}function Ex(){return _.backend}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ix(n){const t={input:C(n,"input","imag")};return _.runKernel(hh,t)}const po=A({imag_:Ix});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kx(n){const t={x:C(n,"x","neg")};return _.runKernel(Dh,t)}const Or=A({neg_:kx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rx(n){const t={input:C(n,"input","real")};return _.runKernel(Xh,t)}const is=A({real_:Rx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(n,e,t){const r=C(n,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),I(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{I(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?ie(()=>{let i=is(r),a=po(r);return i=_.runKernel(Ws,{x:i},o),a=_.runKernel(Ws,{x:a},o),t&&(a=Or(a)),En(i,a)}):_.runKernel(Ws,s,o)}const Ai=A({transpose_:_x});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qs(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const o=t-1-s,i=n[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function ld(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&t.unshift(o)}return t}function Se(n,e){const t=[],r=Math.max(n.length,e.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)t.unshift(i);else if(i===1)t.unshift(o);else if(o!==i){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else t.unshift(o)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ax(n,e,t){if(ia(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=ys(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return xs(n,e,r,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dn;function Ox(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(s&&s&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(wi(gi,_.backendName)!=null){const f={pixels:n},g={numChannels:e};return _.runKernel(gi,f,g)}const[l,c]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(i)h=n.getContext("2d").getImageData(0,0,l,c).data;else if(r||t)h=n.data;else if(o||s||a){if(Dn==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Dn=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Dn=document.createElement("canvas").getContext("2d");Dn.canvas.width=l,Dn.canvas.height=c,Dn.drawImage(n,0,0,l,c),h=Dn.getImageData(0,0,l,c).data}let p;if(e===4)p=new Int32Array(h);else{const f=l*c;p=new Int32Array(f*e);for(let g=0;g<f;g++)for(let y=0;y<e;++y)p[g*e+y]=h[g*4+y]}return Ax(p,[c,l,e],"int32")}async function ya(n,e){let t=C(n,"img","toPixels");if(!(n instanceof Xe)){const l=t;t=_e(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[r,s]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const i=await t.data(),a=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const c=[0,0,0,255];for(let p=0;p<o;p++){const d=i[l*o+p];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);o===1?(c[0]=d*a,c[1]=d*a,c[2]=d*a):c[p]=d*a}const h=l*4;u[h+0]=Math.round(c[0]),u[h+1]=Math.round(c[1]),u[h+2]=Math.round(c[2]),u[h+3]=Math.round(c[3])}if(e!=null){e.width=s,e.height=r;const l=e.getContext("2d"),c=new ImageData(u,s,r);l.putImageData(c,0,0)}return t!==n&&t.dispose(),u}const cd=A({fromPixels_:Ox});function hd(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(j(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const a=n.shape,u=s.slice();u.pop();let l=1;for(let h=o;h<t;++h)l*=a[h],u.push(a[h]);const c=[...rt(n.shape).map(h=>h/l),1].slice(0,o);return[u,i,l,c]}function pd(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(o+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(o+` update.rank != ${s+n.length-r}`);for(let i=0;i<s;++i)if(t.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-s;++i)if(t.shape[i+s]!==n[i+r])throw new Error(o+` updates.shape[${i+s}] (${t.shape[i+s]}) != shape[${i+s}] (${n[i+s]})`)}function dd(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}pd(t,e,n)}function xa(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=t.length;let i=1;for(let h=s;h<o;++h)i*=t[h];const a=s<1?1:s,u=j(e.shape)/a,l=[...rt(t.slice(0,s)),1],c=j(t);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oi=-2,Fx=-1;function fd(n,e,t){const r=n.shape.length;I(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),I(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)I(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Dx(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function md(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function gd(n,e,t,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<t;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function yd(n,e,t){return t<=n?t:t-(e-1)}function xd(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function Px(n,e,t,r,s,o,i,a,u){const l=n.length;let c=new Array(l),h=new Array(l),p=new Array(l);if(e.length&&t>0){const d=e[0],f=t+1;c=bd(i,d,f,r,n),h=wd(a,d,f,s,n),p=gd(o,d,f,n)}else for(let d=0;d<l;d++)c[d]=$d(i,r,o,n,d,u),h[d]=Sd(a,s,o,n,d,u),p[d]=vd(o,d,u);return{begin:c,end:h,strides:p}}function bd(n,e,t,r,s){const o=[...s],i=xd(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const u=yd(e,t,a);let l=r[u];n&1<<u&&(l=0),o[a]=l}return o}function wd(n,e,t,r,s){const o=[...s],i=xd(t,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const u=yd(e,t,a);let l=r[u];n&1<<u&&(l=Number.MAX_SAFE_INTEGER),o[a]=l}for(let a=0;a<o.length;a++){const u=s[a];o[a]<0&&(o[a]+=u),o[a]=Ks(0,o[a],s[a])}return o}function vd(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function $d(n,e,t,r,s,o){let i=e[s];const a=t[s]||1;(n&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=Ks(0,i,u-1),i}function Sd(n,e,t,r,s,o){let i=e[s];const a=t[s]||1;(n&1<<s||o&1<<s||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),a>0?i=Ks(0,i,u):i=Ks(-1,i,u-1),i}function ba(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function wa(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function Td(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{I(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(s).fill(-1):typeof t=="number"?o=[t,...new Array(s-1).fill(-1)]:t.length<s?o=t.concat(new Array(s-t.length).fill(-1)):o=t,o=o.map((i,a)=>i>=0?i:(I(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function Cd(n,e,t,r,s,o,i,a,u){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let S=0;S<h.dims;S++)c&&(1<<S&a)!==0&&h.numAddAxisAfterEllipsis++,1<<S&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Lx(h,p);let d=!0,f=!0,g=!0;const y=[],w=[];for(let S=0;S<n.length;++S){if(p.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const T=!!(p.shrinkAxisMask&1<<S),N=n[S];if(N===-1){y.push(T?1:-1);continue}const k=[p.beginMask&1<<S,p.endMask&1<<S],R=[p.strides[S]>0?0:-1,p.strides[S]>0?N:N-1];if(T&&p.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&p.strides[S]===1;const F=!!(p.beginMask&1<<S&&p.endMask&1<<S);if(p.beginValid&&p.endValid){if(T){const H=p.begin[S]<0?N+p.begin[S]:p.begin[S];if(p.begin[S]=H,p.end[S]=p.begin[S]+1,H<0||H>=N)throw Error(`slice index ${p.begin[S]} of dimension ${S} out of bounds.`)}else p.begin[S]=Pu(p.begin[S],0,p.strides[S],N,k,R),p.end[S]=Pu(p.end[S],1,p.strides[S],N,k,R);const M=p.strides[S]===1&&p.begin[S]===0&&p.end[S]===N;d=d&&M,f=f&&(S===0&&p.strides[S]===1||M)}else d=d&&p.strides[S]===1&&F,f=f&&(S===0&&p.strides[S]===1||F);let O,B=!1;if(p.beginValid&&p.endValid?(O=p.end[S]-p.begin[S],B=!0):T?(O=1,B=!0):F&&N>=0&&(p.strides[S]<0?O=-N:O=N,B=!0),B){let M;O===0||O<0!=p.strides[S]<0?M=0:M=Math.trunc(O/p.strides[S])+(O%p.strides[S]!==0?1:0),y.push(M)}else y.push(-1)}for(let S=0;S<p.finalShapeGatherIndices.length;++S){const T=p.finalShapeGatherIndices[S];T>=0?w.push(y[T]):T===Oi&&w.push(1)}return{finalShapeSparse:w.filter((S,T)=>p.finalShapeGatherIndices[T]!==Oi),finalShape:w,isIdentity:d,sliceDim0:f,isSimpleSlice:g,begin:p.begin,end:p.end,strides:p.strides}}function Lx(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(Oi),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(Fx),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function Pu(n,e,t,r,s,o){if(s[e])return t>0?o[e]:o[e+1&1];{const i=n<0?r+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}var Bx=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:fd,maskToAxes:Dx,computeOutShape:md,stridesWithElidedDims:gd,getNormalizedAxes:Px,startIndicesWithElidedDims:bd,stopIndicesWithElidedDims:wd,stridesForAxis:vd,startForAxis:$d,stopForAxis:Sd,isSliceContinous:ba,computeFlatOffset:wa,parseSliceParams:Td,sliceInfo:Cd},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(n,e){let t=C(n,"a","add"),r=C(e,"b","add");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(ua,s)}const ke=A({add_:Vx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(n,e){let t=C(n,"a","floorDiv"),r=C(e,"b","floorDiv");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(sh,s)}const Nd=A({floorDiv_:Mx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ux(n,e){let t=C(n,"a","div"),r=C(e,"b","div");if([t,r]=Be(t,r),t.dtype==="int32"&&r.dtype==="int32")return Nd(t,r);const s={a:t,b:r},o={};return _.runKernel(jc,s,o)}const Ie=A({div_:Ux});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(n,e){let t=C(n,"a","mul"),r=C(e,"b","mul");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(Fh,s)}const ee=A({mul_:Wx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zx(n){const e=C(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return _.runKernel(kc,t)}else{const t={x:e};return _.runKernel(ac,t)}}const kt=A({abs_:zx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gx(n){const t={x:C(n,"x","acos")};return _.runKernel(uc,t)}const Hx=A({acos_:Gx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jx(n){const t={x:C(n,"x","acosh")};return _.runKernel(lc,t)}const Kx=A({acosh_:jx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xx(n){I(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),I(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,o)=>C(s,`tensors${o}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!ze(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return _.runKernel(cc,r)}const qx=A({addN_:Xx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yx(n,e=null,t=!1){const s={x:C(n,"x","all","bool")},o={axis:e,keepDims:t};return _.runKernel(hc,s,o)}const Qx=A({all_:Yx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zx(n,e=null,t=!1){const s={x:C(n,"x","any","bool")},o={axis:e,keepDims:t};return _.runKernel(pc,s,o)}const Jx=A({any_:Zx});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0(n,e=0){const r={x:C(n,"x","argMax")},s={axis:e};return _.runKernel(dc,r,s)}const Ed=A({argMax_:e0});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0(n,e=0){const r={x:C(n,"x","argMin")},s={axis:e};return _.runKernel(fc,r,s)}const n0=A({argMin_:t0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0(n){const t={x:C(n,"x","asin")};return _.runKernel(mc,t)}const s0=A({asin_:r0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0(n){const t={x:C(n,"x","asinh")};return _.runKernel(gc,t)}const i0=A({asinh_:o0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0(n){const t={x:C(n,"x","atan")};return _.runKernel(yc,t)}const u0=A({atan_:a0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0(n,e){let t=C(n,"a","atan2"),r=C(e,"b","atan2");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(bc,s)}const c0=A({atan2_:l0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0(n){const t={x:C(n,"x","atanh")};return _.runKernel(xc,t)}const p0=A({atanh_:h0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Id(n,e,t,r,s="NHWC",o){const i=n[3],a=[...e,i],u=Dr(s);return Ct(n,a,t,o,r,null,null,u)}function Fr(n,e,t,r,s,o,i="channelsLast"){const[a,u]=Zs(e);let l;if(i==="channelsLast")l=[a,u,n[3],n[3]];else if(i==="channelsFirst")l=[a,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Ct(n,l,t,r,s,o,!1,i)}function bs(n,e,t,r,s,o,i="NDHWC"){const[a,u,l]=Fi(e);let c,h;if(i==="NDHWC")h="channelsLast",c=[a,u,l,n[4],n[4]];else if(i==="NCDHW")h="channelsFirst",c=[a,u,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return ws(n,c,t,r,s,!1,h,o)}function Ct(n,e,t,r,s,o,i=!1,a="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,h]=n;else if(a==="channelsFirst")[u,h,l,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[p,d,,f]=e,[g,y]=Zs(t),[w,$]=Zs(r),S=br(p,w),T=br(d,$),{padInfo:N,outHeight:k,outWidth:R}=m0(s,l,c,g,y,S,T,o,a),F=i?f*h:f;let O;return a==="channelsFirst"?O=[u,F,k,R]:a==="channelsLast"&&(O=[u,k,R,F]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:h,outHeight:k,outWidth:R,outChannels:F,padInfo:N,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:d,effectiveFilterHeight:S,effectiveFilterWidth:T,dilationHeight:w,dilationWidth:$,inShape:n,outShape:O,filterShape:e}}function ws(n,e,t,r,s,o=!1,i="channelsLast",a){let[u,l,c,h,p]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,h,p]=n;else if(i==="channelsFirst")[u,p,l,c,h]=n;else throw new Error(`Unknown dataFormat ${i}`);const[d,f,g,,y]=e,[w,$,S]=Fi(t),[T,N,k]=Fi(r),R=br(d,T),F=br(f,N),O=br(g,k),{padInfo:B,outDepth:M,outHeight:H,outWidth:G}=g0(s,l,c,h,w,$,S,R,F,O,a),Y=o?y*p:y;let te;return i==="channelsFirst"?te=[u,Y,M,H,G]:i==="channelsLast"&&(te=[u,M,H,G,Y]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:p,outDepth:M,outHeight:H,outWidth:G,outChannels:Y,padInfo:B,strideDepth:w,strideHeight:$,strideWidth:S,filterDepth:d,filterHeight:f,filterWidth:g,effectiveFilterDepth:R,effectiveFilterHeight:F,effectiveFilterWidth:O,dilationDepth:T,dilationHeight:N,dilationWidth:k,inShape:n,outShape:te,filterShape:e}}function d0(n,e,t,r,s){r==null&&(r=va(n,e,t));const o=n[0],i=n[1],a=Kn((o-e+2*r)/t+1,s),u=Kn((i-e+2*r)/t+1,s);return[a,u]}function f0(n,e,t,r,s,o){s==null&&(s=va(n,e,r));const i=n[0],a=n[1],u=n[2],l=Kn((i-e+2*s)/r+1,o),c=Kn((a-e+2*s)/r+1,o),h=Kn((u-e+2*s)/r+1,o);return[l,c,h,t]}function va(n,e,t,r=1){const s=br(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function Zs(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Fi(n){return typeof n=="number"?[n,n,n]:n}function br(n,e){return e<=1?n:n+(n-1)*(e-1)}function m0(n,e,t,r,s,o,i,a,u){let l,c,h;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=d0([e,t],o,r,n,a);c=d[0],h=d[1]}else if(n==="same"){c=Math.ceil(e/r),h=Math.ceil(t/s);const p=Math.max(0,(c-1)*r+o-e),d=Math.max(0,(h-1)*s+i-t),f=Math.floor(p/2),g=p-f,y=Math.floor(d/2),w=d-y;l={top:f,bottom:g,left:y,right:w,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/r),h=Math.ceil((t-i+1)/s);else if(typeof n=="object"){const p=u==="channelsLast"?n[1][0]:n[2][0],d=u==="channelsLast"?n[1][1]:n[2][1],f=u==="channelsLast"?n[2][0]:n[3][0],g=u==="channelsLast"?n[2][1]:n[3][1];l={top:p,bottom:d,left:f,right:g,type:p===0&&d===0&&f===0&&g===0?"VALID":"EXPLICIT"},c=Kn((e-o+p+d)/r+1,a),h=Kn((t-i+f+g)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:c,outWidth:h}}function g0(n,e,t,r,s,o,i,a,u,l,c){let h,p,d,f;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=f0([e,t,r,1],a,1,s,n,c);p=y[0],d=y[1],f=y[2]}else if(n==="same"){p=Math.ceil(e/s),d=Math.ceil(t/o),f=Math.ceil(r/i);const g=(p-1)*s+a-e,y=(d-1)*o+u-t,w=(f-1)*i+l-r,$=Math.floor(g/2),S=g-$,T=Math.floor(y/2),N=y-T,k=Math.floor(w/2),R=w-k;h={top:T,bottom:N,left:k,right:R,front:$,back:S,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-a+1)/s),d=Math.ceil((t-u+1)/o),f=Math.ceil((r-l+1)/i);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:p,outHeight:d,outWidth:f}}function Kn(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function as(n){const[e,t,r]=Zs(n);return e===1&&t===1&&r===1}function Nt(n,e){return as(n)||as(e)}function Dr(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Bt(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")I(ss(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{I(ss(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0(n,e){const r={x:C(n,"x","reshape","string_or_numeric")},s={shape:e};return _.runKernel(Qh,r,s)}const W=A({reshape_:y0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n,e,t,r,s){const o=C(n,"x","avgPool","float32"),i=1;I(Nt(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=o,u=!1;o.rank===3&&(u=!0,a=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Bt("avgPool",r,s);const l={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=_.runKernel(wc,l,c);return h=_e(h,o.dtype),u?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const b0=A({avgPool_:x0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0(n,e,t,r,s,o="NDHWC"){const i=C(n,"x","avgPool3d","float32");let a=i,u=!1;i.rank===4&&(u=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),I(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Bt("avgPool3d",r,s);const l={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o};let h=_.runKernel(vc,l,c);return h=_e(h,a.dtype),u?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const v0=A({avgPool3d_:w0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $0(n,e=0){I(n.length>=1,()=>"Pass at least one tensor to concat");const t=Jp(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return jn(t[0]);const r=t,s={axis:e};return _.runKernel(Rc,r,s)}const bt=A({concat_:$0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0(n){const t={x:C(n,"x","sigmoid","float32")};return _.runKernel(pp,t)}const vs=A({sigmoid_:S0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0(n,e,t){const r=C(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:t};return _.runKernel(up,s,o)}const $e=A({slice_:T0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0(n){const t={x:C(n,"x","tanh","float32")};return _.runKernel(_p,t)}const N0=A({tanh_:C0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E0(n,e,t){const r=C(n,"x","batchToSpaceND"),s=e.reduce((a,u)=>a*u);I(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),I(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),I(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:t};return _.runKernel(Sc,o,i)}const I0=A({batchToSpaceND_:E0});function k0(n){let e;return n.rank===0||n.rank===1?e=W(n,[1,1,1,n.size]):n.rank===2?e=W(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0(n,e,t,r,s,o){o==null&&(o=.001);const i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm");let l;s!=null&&(l=C(s,"scale","batchNorm"));let c;r!=null&&(c=C(r,"offset","batchNorm")),I(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:k0(i),scale:l,offset:c,mean:a,variance:u},d={varianceEpsilon:o},f=_.runKernel(oh,p,d);return W(f,i.shape)}const Lu=A({batchNorm_:R0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _0(n,e,t){const r=C(n,"x","bincount"),s=C(e,"weights","bincount");I(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:t};return _.runKernel(Tc,o,i)}const kd=A({bincount_:_0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0(n,e){const t=C(n,"s0","broadcastArgs","int32"),r=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return _.runKernel(Cc,s)}const O0=A({broadcastArgs_:A0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0(n,e){let t=C(n,"broadcastTo","x");const r=t.shape;if(e.some(l=>!(l>0)||l%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=W(t,l)}const s=t.shape,o=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])o[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return jn(t);const a={x:t},u={reps:o};return _.runKernel(ha,a,u)}const Gs=A({broadcastTo_:F0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0(n){const t={x:C(n,"x","ceil","float32")};return _.runKernel(Nc,t)}const P0=A({ceil_:D0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0(n,e,t){const r=C(n,"x","clipByValue");I(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const s={x:r},o={clipValueMin:e,clipValueMax:t};return _.runKernel(Ec,s,o)}const Rd=A({clipByValue_:L0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0(n,e,t,r,s="NHWC",o=[1,1],i){const a=C(n,"x","conv2d","float32"),u=C(e,"filter","conv2d","float32");let l=a,c=!1;a.rank===3&&(c=!0,l=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Bt("conv2d",r,i);const h=s==="NHWC"?l.shape[3]:l.shape[1];I(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),I(Nt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const p={x:l,filter:u},d={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},f=_.runKernel(_c,p,d);return c?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const $a=A({conv2d_:B0});function V0(n,e,t,r,s="NWC",o=1,i){const a=C(n,"x","conv1d"),u=C(e,"filter","conv1d");let l=a,c=!1;a.rank===2&&(c=!0,l=W(a,[1,a.shape[0],a.shape[1]])),I(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),I(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Bt("conv1d",r,i),I(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),I(Nt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),I(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=W(u,[1,u.shape[0],u.shape[1],u.shape[2]]),p=W(l,[l.shape[0],1,l.shape[1],l.shape[2]]),y=$a(p,h,[1,t],r,"NHWC",[1,o],i);return c?W(y,[y.shape[2],y.shape[3]]):W(y,[y.shape[0],y.shape[2],y.shape[3]])}const M0=A({conv1d_:V0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0(n,e,t,r,s,o="NHWC",i){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,u=e,l=!1;e.rank===3&&(l=!0,u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),I(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),I(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),I(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?a[3]:a[1],h=o==="NHWC"?u.shape[3]:u.shape[1];I(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),I(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Bt("conv2dDerInput",s,i);const p={dy:u,filter:t},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},f=_.runKernel(Oc,p,d);return l?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const _d=A({conv2DBackpropInput_:U0});function W0(n,e,t,r,s,o){const i=C(n,"x","conv2dTranspose"),a=C(e,"filter","conv2dTranspose");return _d(t,i,a,r,s,"NHWC",o)}const z0=A({conv2dTranspose_:W0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0(n,e,t,r,s="NDHWC",o=[1,1,1]){const i=C(n,"x","conv3d"),a=C(e,"filter","conv3d");let u=i,l=!1;i.rank===4&&(l=!0,u=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),I(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),I(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),I(Nt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:u,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:o},p=_.runKernel(Fc,c,h);return l?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const H0=A({conv3d_:G0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0(n){const t={x:C(n,"x","cos","float32")};return _.runKernel(Dc,t)}const K0=A({cos_:j0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0(n){const t={x:C(n,"x","cosh","float32")};return _.runKernel(Pc,t)}const q0=A({cosh_:X0});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0(n,e=0,t=!1,r=!1){const o={x:C(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:r};return _.runKernel(Lc,o,i)}const Q0=A({cumprod_:Y0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0(n,e=0,t=!1,r=!1){const o={x:C(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:r};return _.runKernel(Bc,o,i)}const J0=A({cumsum_:Z0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1(n,e,t,r=!1){const s=C(n,"x","denseBincount"),o=C(e,"weights","denseBincount");I(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),I(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:t,binaryOutput:r};return _.runKernel(Mc,i,a)}const t1=A({denseBincount_:e1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1(n,e,t="NHWC"){const r=C(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],o=t==="NHWC"?r.shape[2]:r.shape[3],i=t==="NHWC"?r.shape[3]:r.shape[1];I(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),I(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),I(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),I(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},u={blockSize:e,dataFormat:t};return _.runKernel(Uc,a,u)}const r1=A({depthToSpace_:n1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1(n,e,t,r,s="NHWC",o=[1,1],i){const a=C(n,"x","depthwiseConv2d","float32"),u=C(e,"filter","depthwiseConv2d","float32");let l=a,c=!1;a.rank===3&&(c=!0,l=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),I(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Bt("depthwiseConv2d",r,i);const h={x:l,filter:u},p={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},d=_.runKernel(Wc,h,p);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Ad=A({depthwiseConv2d_:s1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1(n,e,t,r,s=[1,1],o="NHWC"){const i=C(n,"x","dilation2d"),a=C(e,"filter","dilation2d");I(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),I(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),I(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,l=!1;i.rank===3&&(u=W(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);const c={x:u,filter:a},h={strides:t,pad:r,dilations:s},p=_.runKernel(Hc,c,h);return l?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const i1=A({dilation2d_:o1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a1(n,e){let t=C(n,"a","equal","string_or_numeric"),r=C(e,"b","equal","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(Yc,s)}const Od=A({equal_:a1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u1(n,e,t){const r=C(e,"a","where"),s=C(t,"b","where"),o=C(n,"condition","where","bool"),i=Se(Se(o.shape,r.shape),s.shape),a=Gs(o,i),u=Gs(r,i),l=Gs(s,i),c={condition:a,t:u,e:l};return _.runKernel(ip,c)}const Er=A({where_:u1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1(n){const t={x:C(n,"x","zerosLike")};return _.runKernel(Pp,t)}const Sa=A({zerosLike_:l1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1(n,e){let t=C(n,"a","div"),r=C(e,"b","div");[t,r]=Be(t,r);const s=Ie(t,r),o=Sa(s),i=Od(r,o);return Er(i,o,s)}const h1=A({divNoNan_:c1});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1(n,...e){const t=e.map((s,o)=>C(s,`tensors${o}`,"einsum")),r={equation:n};return _.runKernel(Kc,t,r)}const d1=A({einsum_:p1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f1(n){const t={x:C(n,"x","elu","float32")};return _.runKernel(Xc,t)}const Fd=A({elu_:f1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1(n){let e=C(n,"x","erf");I(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=_e(e,"float32"));const t={x:e};return _.runKernel(qc,t)}const g1=A({erf_:m1});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ta(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Dd(n,e,t){const r=n.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[o++]):s.push(e[i++]);return s}function on(n,e){const t=[],r=n.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&t.push(n[o]);const s=e.map(o=>n[o]);return[t,s]}function Vt(n,e){const t=e.map(r=>1);return Dd(n,t,e)}function Jt(n,e,t){I(Ta(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Mt(n,e){if(Ta(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Ca(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Ut(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y1(n,e=null,t=!1){const s={x:C(n,"x","max")},o={reductionIndices:e,keepDims:t};return _.runKernel(Sh,s,o)}const wr=A({max_:y1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(n,e=null,t=!1){const s={x:C(n,"x","min")},o={axis:e,keepDims:t};return _.runKernel(kh,s,o)}const Di=A({min_:x1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1(n,e){let t=C(n,"base","pow"),r=C(e,"exp","pow");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(Gh,s)}const Pd=A({pow_:b1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(n,e){if((nn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&nn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return xs(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1(n){const t={x:C(n,"x","sqrt","float32")};return _.runKernel(fp,t)}const Pi=A({sqrt_:w1});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1(n){const e=C(n,"x","square"),t={};return _.runKernel("Square",{x:e},t)}const fo=A({square_:v1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $1(n,e=null,t=!1){let r=C(n,"x","sum");r.dtype==="bool"&&(r=_e(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return _.runKernel(mp,s,o)}const De=A({sum_:$1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1(n,e="euclidean",t=null,r=!1){n=C(n,"x","norm");const s=Ld(n,e,t);let o=s.shape;if(r){const i=et(t,n.shape);o=Vt(s.shape,i)}return W(s,o)}function Ld(n,e,t=null){if(n.rank===0)return kt(n);if(n.rank!==1&&t===null)return Ld(W(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return De(kt(n),t);if(e===1/0)return wr(kt(n),t);if(e===-1/0)return Di(kt(n),t);if(e==="euclidean"||e===2)return Pi(De(Pd(kt(n),de(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return wr(De(kt(n),t[0]),t[1]-1);if(e===1/0)return wr(De(kt(n),t[1]),t[0]);if(e===-1/0)return Di(De(kt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Pi(De(fo(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Na=A({norm_:S1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(n,e=null,t=!1){return Na(n,"euclidean",e,t)}const C1=A({euclideanNorm_:T1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1(n){const t={x:C(n,"x","exp")};return _.runKernel(Qc,t)}const pn=A({exp_:N1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1(n,e=0){const t=C(n,"x","expandDims","string_or_numeric");I(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return _.runKernel(Zc,r,s)}const _t=A({expandDims_:E1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(n){const t={x:C(n,"x","expm1")};return _.runKernel(Jc,t)}const k1=A({expm1_:I1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1(n,e){const t=C(n,"x","tile","string_or_numeric");I(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return _.runKernel(ha,r,s)}const rs=A({tile_:R1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(n,e,t,r="float32"){e==null&&(e=n);const s=Ge([n,e],r),o=n<=e?n:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=W(s.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return rs(_t(i,0),[t[0],1,1]);if(t.length===2)return rs(_t(_t(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return rs(_t(_t(_t(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const A1=A({eye_:_1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(n,e,t){const r={shape:n,value:e,dtype:t};return _.runKernel(th,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1(n){const t={x:C(n,"x","floor","float32")};return _.runKernel(rh,t)}const F1=A({floor_:O1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1(n,e,t=0,r=0){const s=C(n,"x","gather"),o=C(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:t,batchDims:r};return _.runKernel(ih,i,a)}const Bu=A({gather_:D1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1(n,e){let t=C(n,"a","greater","string_or_numeric"),r=C(e,"b","greater","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(uh,s)}const mo=A({greater_:P1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1(n,e){let t=C(n,"a","greaterEqual","string_or_numeric"),r=C(e,"b","greaterEqual","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(lh,s)}const Bd=A({greaterEqual_:L1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B1(n){const t={x:C(n,"x","isNaN")};return _.runKernel(ph,t)}const V1=A({isNaN_:B1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M1(n,e=.2){const r={x:C(n,"x","leakyRelu")},s={alpha:e};return _.runKernel(dh,r,s)}const Vd=A({leakyRelu_:M1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1(n,e){let t=C(n,"a","less","string_or_numeric"),r=C(e,"b","less","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(fh,s)}const W1=A({less_:U1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(n,e){let t=C(n,"a","lessEqual","string_or_numeric"),r=C(e,"b","lessEqual","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(mh,s)}const Ia=A({lessEqual_:z1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return _.runKernel(gh,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1(n,e=5,t=1,r=1,s=.5){const o=C(n,"x","localResponseNormalization");I(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),I(ss(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:i},l={depthRadius:e,bias:t,alpha:r,beta:s},c=_.runKernel($h,u,l);return a?W(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const j1=A({localResponseNormalization_:H1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1(n){const t={x:C(n,"x","log","float32")};return _.runKernel(yh,t)}const us=A({log_:K1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X1(n){const t={x:C(n,"x","log1p")};return _.runKernel(xh,t)}const Md=A({log1p_:X1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function In(n){return _.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q1(n){const t={x:C(n,"x","softplus")};return _.runKernel(dp,t)}const Y1=A({softplus_:q1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1(n,e){let t=C(n,"a","sub"),r=C(e,"b","sub");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(kp,s)}const me=A({sub_:Q1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1(n,e=-1){const t=C(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return In((s,o)=>{const a=wr(s,e,!0),u=me(s,a),l=me(_e(u,"float32"),us(De(pn(u),e,!0)));return o([l]),{value:l,gradFunc:(h,p)=>{const[d]=p,f=!0,g=pn(d);return me(h,ee(De(h,e,f),g))}}})(t)}const J1=A({logSoftmax_:Z1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eb(n,e=null,t=!1){const r=C(n,"x","logSumExp"),s=et(e,r.shape),o=wr(r,s,!0),i=me(r,o),a=pn(i),u=De(a,s),l=us(u),c=ke(W(o,l.shape),l);if(t){const h=Vt(c.shape,s);return W(c,h)}return c}const tb=A({logSumExp_:eb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(n,e){const t=C(n,"a","logicalAnd","bool"),r=C(e,"b","logicalAnd","bool");Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(bh,s)}const Ud=A({logicalAnd_:nb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(n){const t={x:C(n,"x","logicalNot","bool")};return _.runKernel(wh,t)}const sb=A({logicalNot_:rb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ob(n,e){const t=C(n,"a","logicalOr","bool"),r=C(e,"b","logicalOr","bool");Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(vh,s)}const ib=A({logicalOr_:ob});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fs=2147483648;function ab(n,e,t="left"){const r=C(n,"sortedSequence","searchSorted"),s=C(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=W(r,[-1,o]),u=W(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(j(u.shape)>=Fs)throw new Error(`values tensor size must less than ${Fs}`);if(a.shape[1]>=Fs)throw new Error(`trailing dim_size must less than ${Fs} for int32 output type, was ${a.shape[1]}`);const l={sortedSequence:a,values:u},c={side:t};return _.runKernel(op,l,c)}const Wd=A({searchSorted_:ab});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ub(n,e){return Wd(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(n,e,t,r,s){const o=C(n,"x","maxPool"),i=1;let a=o,u=!1;o.rank===3&&(u=!0,a=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),I(Nt(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Bt("maxPool",r,s);const l={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=_.runKernel(Ch,l,c);return u?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const cb=A({maxPool_:lb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hb(n,e=[1,1,1],t,r,s,o="NDHWC"){const i=C(n,"x","maxPool3d");let a=i,u=!1;i.rank===4&&(u=!0,a=W(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),I(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Bt("maxPool3d",r,s);const l={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o},h=_.runKernel(Nh,l,c);return u?W(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const pb=A({maxPool3d_:hb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function db(n,e,t,r,s=!1){const i={x:C(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=_.runKernel(Eh,i,a);return{result:u[0],indexes:u[1]}}const fb=A({maxPoolWithArgmax_:db});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mb(n,e){let t=C(n,"a","maximum"),r=C(e,"b","maximum");[t,r]=Be(t,r),t.dtype==="bool"&&(t=_e(t,"int32"),r=_e(r,"int32")),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(Th,s)}const gb=A({maximum_:mb});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yb(n,e=null,t=!1){const s={x:C(n,"x","mean")},o={axis:e,keepDims:t};return _.runKernel(Ih,s,o)}const zd=A({mean_:yb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kn(n,e="float32"){if(e==="complex64"){const r=kn(n,"float32"),s=kn(n,"float32");return En(r,s)}const t=Nn(j(n),e);return _.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(n,e="float32"){if(e==="complex64"){const r=ka(n,"float32"),s=kn(n,"float32");return En(r,s)}const t=nc(j(n),e);return _.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(n,e){let t=C(n,"a","minimum"),r=C(e,"b","minimum");[t,r]=Be(t,r),t.dtype==="bool"&&(t=_e(t,"int32"),r=_e(r,"int32")),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(Rh,s)}const Ra=A({minimum_:xb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(n,e,t){I(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=C(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)I(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),I(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:t},i={x:r};return _.runKernel(_h,i,o)}const Gd=A({mirrorPad_:bb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wb(n,e){let t=C(n,"a","mod"),r=C(e,"b","mod");[t,r]=Be(t,r);const s={a:t,b:r};return _.runKernel(Ah,s)}const vb=A({mod_:wb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $b(n,e,t,r=!1){const s=C(n,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const u={logits:i===1?W(s,[1,-1]):s},l={numSamples:e,seed:t,normalized:r},c=_.runKernel(Oh,u,l);return i===1?W(c,[c.size]):c}const Sb=A({multinomial_:$b});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(n,e){let t=C(n,"a","notEqual","string_or_numeric"),r=C(e,"b","notEqual","string_or_numeric");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r};return _.runKernel(Ph,s)}const Hd=A({notEqual_:Tb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cb(n){const t={x:C(n,"x","onesLike")};return _.runKernel(Mh,t)}const Nb=A({onesLike_:Cb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eb(n,e,t=0){const r=C(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},o={x:r};return _.runKernel(zh,o,s)}const Js=A({pad_:Eb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ib(n,e,t){const r=C(n,"x","spaceToBatchND");I(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),I(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),I(r.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+t[u-1][0]+t[u-1][1])%e[u-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:t};return _.runKernel(gp,s,o)}const kb=A({spaceToBatchND_:Ib});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rb(n,e){const t=C(n,"x","prelu"),r=C(e,"alpha","prelu"),s={x:t,alpha:r};return _.runKernel(Hh,s)}const jd=A({prelu_:Rb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _b(n,e=null,t=!1){let r=C(n,"x","prod");r.dtype==="bool"&&(r=_e(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return _.runKernel(jh,s,o)}const Kd=A({prod_:_b});var Xd={exports:{}};(function(n){(function(e,t,r){function s(u){var l=this,c=a();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function o(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function i(u,l){var c=new s(u),h=l&&l.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&o(h,c),p.state=function(){return o(c,{})}),p}function a(){var u=4022871197,l=function(c){c=c.toString();for(var h=0;h<c.length;h++){u+=c.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.alea=i})(hn,n,!1)})(Xd);var qd={exports:{}};(function(n){(function(e,t,r){function s(a){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},a===(a|0)?u.x=a:l+=a;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u}function i(a,u){var l=new s(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&o(c,l),h.state=function(){return o(l,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i})(hn,n,!1)})(qd);var Yd={exports:{}};(function(n){(function(e,t,r){function s(a){var u=this,l="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,a===(a|0)?u.x=a:l+=a;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u.v=a.v,u.d=a.d,u}function i(a,u){var l=new s(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&o(c,l),h.state=function(){return o(l,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i})(hn,n,!1)})(Yd);var Qd={exports:{}};(function(n){(function(e,t,r){function s(a){var u=this;u.next=function(){var c=u.x,h=u.i,p,d;return p=c[h],p^=p>>>7,d=p^p<<24,p=c[h+1&7],d^=p^p>>>10,p=c[h+3&7],d^=p^p>>>3,p=c[h+4&7],d^=p^p<<7,p=c[h+7&7],p=p^p<<13,d^=p^p<<9,c[h]=d,u.i=h+1&7,d};function l(c,h){var p,d=[];if(h===(h|0))d[0]=h;else for(h=""+h,p=0;p<h.length;++p)d[p&7]=d[p&7]<<15^h.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8&&(d[7]=-1),c.x=d,c.i=0,p=256;p>0;--p)c.next()}l(u,a)}function o(a,u){return u.x=a.x.slice(),u.i=a.i,u}function i(a,u){a==null&&(a=+new Date);var l=new s(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,c&&(c.x&&o(c,l),h.state=function(){return o(l,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i})(hn,n,!1)})(Qd);var Zd={exports:{}};(function(n){(function(e,t,r){function s(a){var u=this;u.next=function(){var c=u.w,h=u.X,p=u.i,d,f;return u.w=c=c+1640531527|0,f=h[p+34&127],d=h[p=p+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,f=h[p]=f^d,u.i=p,f+(c^c>>>16)|0};function l(c,h){var p,d,f,g,y,w=[],$=128;for(h===(h|0)?(d=h,h=null):(h=h+"\0",d=0,$=Math.max($,h.length)),f=0,g=-32;g<$;++g)h&&(d^=h.charCodeAt((g+32)%h.length)),g===0&&(y=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,g>=0&&(y=y+1640531527|0,p=w[g&127]^=d+y,f=p==0?f+1:0);for(f>=128&&(w[(h&&h.length||0)&127]=-1),f=127,g=4*128;g>0;--g)d=w[f+34&127],p=w[f=f+1&127],d^=d<<13,p^=p<<17,d^=d>>>15,p^=p>>>12,w[f]=d^p;c.w=y,c.X=w,c.i=f}l(u,a)}function o(a,u){return u.i=a.i,u.w=a.w,u.X=a.X.slice(),u}function i(a,u){a==null&&(a=+new Date);var l=new s(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,c&&(c.X&&o(c,l),h.state=function(){return o(l,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i})(hn,n,!1)})(Zd);var Jd={exports:{}};(function(n){(function(e,t,r){function s(a){var u=this,l="";u.next=function(){var h=u.b,p=u.c,d=u.d,f=u.a;return h=h<<25^h>>>7^p,p=p-d|0,d=d<<24^d>>>8^f,f=f-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-d|0,u.d=d<<16^p>>>16^f,u.a=f-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,a===Math.floor(a)?(u.a=a/4294967296|0,u.b=a|0):l+=a;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function o(a,u){return u.a=a.a,u.b=a.b,u.c=a.c,u.d=a.d,u}function i(a,u){var l=new s(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var p=l.next()>>>11,d=(l.next()>>>0)/4294967296,f=(p+d)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&o(c,l),h.state=function(){return o(l,{})}),h}t&&t.exports?t.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i})(hn,n,!1)})(Jd);var ef={exports:{}};(function(n){(function(e,t){var r=this,s=256,o=6,i=52,a="random",u=t.pow(s,o),l=t.pow(2,i),c=l*2,h=s-1,p;function d(T,N,k){var R=[];N=N==!0?{entropy:!0}:N||{};var F=w(y(N.entropy?[T,S(e)]:T==null?$():T,3),R),O=new f(R),B=function(){for(var M=O.g(o),H=u,G=0;M<l;)M=(M+G)*s,H*=s,G=O.g(1);for(;M>=c;)M/=2,H/=2,G>>>=1;return(M+G)/H};return B.int32=function(){return O.g(4)|0},B.quick=function(){return O.g(4)/4294967296},B.double=B,w(S(O.S),e),(N.pass||k||function(M,H,G,Y){return Y&&(Y.S&&g(Y,O),M.state=function(){return g(O,{})}),G?(t[a]=M,H):M})(B,F,"global"in N?N.global:this==t,N.state)}t["seed"+a]=d;function f(T){var N,k=T.length,R=this,F=0,O=R.i=R.j=0,B=R.S=[];for(k||(T=[k++]);F<s;)B[F]=F++;for(F=0;F<s;F++)B[F]=B[O=h&O+T[F%k]+(N=B[F])],B[O]=N;(R.g=function(M){for(var H,G=0,Y=R.i,te=R.j,ne=R.S;M--;)H=ne[Y=h&Y+1],G=G*s+ne[h&(ne[Y]=ne[te=h&te+H])+(ne[te]=H)];return R.i=Y,R.j=te,G})(s)}function g(T,N){return N.i=T.i,N.j=T.j,N.S=T.S.slice(),N}function y(T,N){var k=[],R=typeof T,F;if(N&&R=="object")for(F in T)try{k.push(y(T[F],N-1))}catch{}return k.length?k:R=="string"?T:T+"\0"}function w(T,N){for(var k=T+"",R,F=0;F<k.length;)N[h&F]=h&(R^=N[h&F]*19)+k.charCodeAt(F++);return S(N)}function $(){try{var T;return p&&(T=p.randomBytes)?T=T(s):(T=new Uint8Array(s),(r.crypto||r.msCrypto).getRandomValues(T)),S(T)}catch{var N=r.navigator,k=N&&N.plugins;return[+new Date,r,k,r.screen,S(e)]}}function S(T){return String.fromCharCode.apply(0,T)}if(w(t.random(),e),n.exports){n.exports=d;try{p=require("crypto")}catch{}}})([],Math)})(ef);var Ab=Xd.exports,Ob=qd.exports,Fb=Yd.exports,Db=Qd.exports,Pb=Zd.exports,Lb=Jd.exports,er=ef.exports;er.alea=Ab;er.xor128=Ob;er.xorwow=Fb;er.xorshift7=Db;er.xor4096=Pb;er.tychei=Lb;var tf=er;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bb{constructor(e,t,r,s,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=tf.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Vb{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=tf.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mb(n,e=0,t=1,r="float32",s){const o=Ge(n,r),i=new Vb(e,t,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const Ub=A({randomUniform_:Mb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return _.runKernel(Kh,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(n){const t={x:C(n,"x","reciprocal")};return _.runKernel(qh,t)}const zb=A({reciprocal_:Wb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gb(n){const t={x:C(n,"x","relu")};return _.runKernel(Yh,t)}const go=A({relu_:Gb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hb(n){const t={x:C(n,"x","relu6")};return _.runKernel(ep,t)}const nf=A({relu6_:Hb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jb(n,e){const r={x:C(n,"x","reverse")},s={dims:e};return _.runKernel(tp,r,s)}const eo=A({reverse_:jb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(n){const t={x:C(n,"x","round")};return _.runKernel(np,t)}const rf=A({round_:Kb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xb(n){const t={x:C(n,"x","rsqrt","float32")};return _.runKernel(rp,t)}const qb=A({rsqrt_:Xb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yb(n){const t={x:C(n,"x","selu")};return _.runKernel(ap,t)}const Qb=A({selu_:Yb});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Zb(n,e){const t=C(n,"x","setdiff1d"),r=C(e,"y","setdiff1d");I(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),I(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),I(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),o=await r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const u=new os([a],t.dtype),l=new os([a],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]}const Jb=Zb;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(n){const t={x:C(n,"x","sign")};return _.runKernel(hp,t)}const tw=A({sign_:ew});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n){const t={x:C(n,"x","sin","float32")};return _.runKernel(lp,t)}const rw=A({sin_:nw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(n){const t={x:C(n,"x","sinh")};return _.runKernel(cp,t)}const ow=A({sinh_:sw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(n,e=-1){const t=C(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return _.runKernel(xp,r,s)}const aw=A({softmax_:iw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return _.runKernel(eh,e)}const sf=A({fft_:uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lw(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return _.runKernel(ch,e)}const Li=A({ifft_:lw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=W(n,[t,e]);r=Li(s)}else{const s=[t,2*(e-1)],o=W(is(n),[t,e]),i=W(po(n),[t,e]),a=eo($e(o,[0,1],[t,e-2]),1),u=ee(eo($e(i,[0,1],[t,e-2]),1),de(-1)),l=bt([o,a],1),c=bt([i,u],1),h=W(En(l,c),[s[0],s[1]]);r=Li(h)}if(r=is(r),n.rank===3&&n.shape[0]!==0){const s=r,o=n.shape[0];r=W(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const hw=A({irfft_:cw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pw(n,e,t=0){const s={x:C(n,"x","split")},o={numOrSizeSplits:e,axis:t};return _.runKernel(yp,s,o)}const cs=A({split_:pw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dw(n,e){I(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const f=n.shape.map(y=>0),g=n.shape.map(y=>y);g[n.shape.length-1]=e,s=$e(n,f,g),t=e}else if(e!=null&&e>t){const f=n.shape.map(g=>g);f[n.shape.length-1]=e-t,s=bt([n,kn(f)],n.shape.length-1),t=e}else s=n;const o=Sa(s),i=W(En(s,o),[r,t]),a=sf(i),u=Math.floor(t/2)+1,l=is(a),c=po(a),h=cs(l,[u,t-u],l.shape.length-1),p=cs(c,[u,t-u],c.shape.length-1),d=s.shape.slice();return d[s.shape.length-1]=u,W(En(h[0],p[0]),d)}const of=A({rfft_:dw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(n,e){let t=C(n,"a","squaredDifference"),r=C(e,"b","squaredDifference");[t,r]=Be(t,r),Se(t.shape,r.shape);const s={a:t,b:r},o={};return _.runKernel(Tp,s,o)}const af=A({squaredDifference_:fw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(n,e){const t=C(n,"x","squeeze");return W(t,Rn(t.shape,e).newShape)}const Ne=A({squeeze_:mw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(n,e=0){const t=Jp(n,"tensors","stack","string_or_numeric");I(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&I(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return _.runKernel(Wh,r,s)}const dn=A({stack_:gw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n,e=0){const r={x:C(n,"x","step")},s={alpha:e};return _.runKernel(Lp,r,s)}const xw=A({step_:yw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bw(n,e,t,r,s=0,o=0,i=0,a=0,u=0){const c={x:C(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return _.runKernel(Cp,c,h)}const ww=A({stridedSlice_:bw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vw(n){const t={x:C(n,"x","tan","float32")};return _.runKernel(Rp,t)}const $w=A({tan_:vw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nt(n,e){ia(n);const t=ys(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return xs(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qt(n,e,t){if(ia(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=ys(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return xs(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sw(n,e=1,t=!0){const r=C(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:t},[a,u]=_.runKernel(Ap,o,i);return{values:a,indices:u}}const Tw=A({topk_:Sw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new Bb(e,t,r,!0,s),i=Ge(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Nw=A({truncatedNormal_:Cw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ew(n,e=0){const t=C(n,"x","unique","string_or_numeric");I(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[o,i]=_.runKernel(Fp,r,s);return{values:o,indices:i}}const Vu=A({unique_:Ew});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n,e=0){const t=C(n,"x","unstack","string_or_numeric");I(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return _.runKernel(Dp,r,s)}const tr=A({unstack_:Iw});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kw(n,e){return Wd(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uf(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const r=Ge(n,"int32"),s=Ge([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const i=r.indexToLoc(t[o]),a=o*n.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Rw(n){const e=C(n,"condition","whereAsync","bool"),t=await e.data(),r=uf(e.shape,t);return n!==e&&e.dispose(),r}const _w=Rw;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aw(n,e,t){const r=C(n,"indices","scatterND","int32"),s=C(e,"updates","scatterND");dd(s,r,t);const o={indices:r,updates:s},i={shape:t};return _.runKernel(sp,o,i)}const Ow=A({scatterND_:Aw});function Fw(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(n,e,t,r=0){const s=C(n,"sparseIndices","sparseToDense","int32"),o=C(e,"sparseValues","sparseToDense","string_or_numeric"),i=C(r,"defaultValue","sparseToDense",o.dtype);Fw(s,o,t,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},u={outputShape:t};return _.runKernel(Sp,a,u)}const lf=A({sparseToDense_:Dw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n,e){const t=C(e,"indices","gatherND","int32"),s={params:C(n,"x","gatherND","string_or_numeric"),indices:t};return _.runKernel(ah,s)}const Lw=A({gatherND_:Pw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function cf(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+r-1);s[o]=e-t*Math.cos(i)}return nt(s,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vw(n,e,t,r,s,o="NHWC",i){let a=n;n.rank===3&&(a=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]])),I(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),I(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),I(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=o==="NHWC"?a.shape[3]:a.shape[1],c=o==="NHWC"?u.shape[3]:u.shape[1];I(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),I(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Bt("conv2dDerFilter",s,i);const h={x:a,dy:u},p={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:t};return _.runKernel(Ac,h,p)}const Mw=A({conv2DBackpropFilter_:Vw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yo(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ee(n,xw(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function xo(n,e){let t=e;const r=ld(n.shape,e.shape);return r.length>0&&(t=De(t,r)),W(t,n.shape)}function bo(n,e,t,r){if(e==="linear")return n;if(e==="relu")return go(n);if(e==="elu")return Fd(n);if(e==="relu6")return nf(n);if(e==="prelu")return jd(n,t);if(e==="leakyrelu")return Vd(n,r);if(e==="sigmoid")return vs(n);throw new Error(`Unknown fused activation ${e}.`)}const wo=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",wo(_.state.gradientDepth,u)===!1){I(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=$a(n,e,t,r,s,o,i);return a!=null&&(k=ke(k,a)),bo(k,u,l,c)}const h=C(n,"x","conv2d","float32"),p=C(e,"filter","conv2d","float32");let d=h,f=!1;h.rank===3&&(f=!0,d=W(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),I(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),Bt("fused conv2d",r,i);const g=s==="NHWC"?d.shape[3]:d.shape[1];I(p.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`),I(Nt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const y=Ct(d.shape,p.shape,t,o,r,i);let w;a!=null&&(w=C(a,"bias","fused conv2d"),[w]=Be(w,h),s==="NHWC"?Se(y.outShape,w.shape):(I(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),I(w.shape.length===0||w.shape[0]===y.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let $;if(l!=null){const k=l.shape;if(I(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)I(k[0]===1||k[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${y.outChannels}).`);else if(k.length===3)try{Se(k,y.outShape)}catch{const F=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(F)}$=C(l,"prelu weights","fused conv2d")}const S=(k,R)=>{I(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[F,O,B,M]=R,H=yo(k,B,u);I(as(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const G=_d(O.shape,H,F,t,r),Y=Mw(O,H,F.shape,t,r),te=[G,Y];if(M!=null){const ne=xo(M,H);te.push(ne)}return te},T={x:d,filter:p,bias:w,preluActivationWeights:$},N={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?In((R,F,O)=>{let B=_.runKernel(xi,T,N);return O([F,R,B]),f&&(B=W(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:S}})(d,p):In((R,F,O,B)=>{let M=_.runKernel(xi,T,N);return B([F,R,M,O]),f&&(M=W(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:S}})(d,p,w)}const Ww=A({fusedConv2d_:Uw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n,e,t,r,s,o=[1,1],i){let a=n;n.rank===3&&(a=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:a,dy:u},c={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:t};return _.runKernel(zc,l,c)}const Gw=A({depthwiseConv2dNativeBackpropFilter_:zw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e,t,r,s,o=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:a,filter:t},c={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:n},h=_.runKernel(Gc,l,c);return u?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const jw=A({depthwiseConv2dNativeBackpropInput_:Hw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(wo(_.state.gradientDepth,u)===!1){let N=Ad(n,e,t,r,s,o,i);return a!=null&&(N=ke(N,a)),bo(N,u,l,c)}const h=C(n,"x","depthwiseConv2d","float32"),p=C(e,"filter","depthwiseConv2d","float32");let d=h,f=!1;h.rank===3&&(f=!0,d=W(h,[1,h.shape[0],h.shape[1],h.shape[2]])),I(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),I(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),I(d.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),o==null&&(o=[1,1]),I(Nt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Bt("fused depthwiseConv2d",r,i);const g=Ct(d.shape,p.shape,t,o,r,i,!0);let y;a!=null&&(y=C(a,"bias","fused conv2d"),[y]=Be(y,h),Se(g.outShape,y.shape));let w;l!=null&&(w=C(l,"prelu weights","fused depthwiseConv2d"));const $=(N,k)=>{I(as(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[R,F,O,B]=k,M=yo(N,O,u),H=jw(F.shape,M,R,t,r,o,i),G=Gw(F,M,R.shape,t,r,o,i);if(B!=null){const Y=xo(y,M);return[H,G,Y]}return[H,G]},S={x:d,filter:p,bias:y,preluActivationWeights:w},T={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?In((k,R,F)=>{let O=_.runKernel(bi,S,T);return F([R,k,O]),f&&(O=W(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:$}})(d,p):In((k,R,F,O)=>{let B=_.runKernel(bi,S,T);return O([R,k,B,F]),f&&(B=W(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:$}})(d,p,y)}const Xw=A({fusedDepthwiseConv2d_:Kw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(wo(_.state.gradientDepth,o)===!1){let M=Ye(n,e,t,r);return s!=null&&(M=ke(M,s)),bo(M,o,i,a)}let u=C(n,"a","fused matMul"),l=C(e,"b","fused matMul");[u,l]=Be(u,l);const c=t?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],p=t?u.shape[u.rank-1]:u.shape[u.rank-2],d=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),g=l.shape.slice(0,-2),y=j(f),w=j(g);I(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=Se(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([p,d]),T=t?W(u,[y,c,p]):W(u,[y,p,c]),N=r?W(l,[w,d,h]):W(l,[w,h,d]);let k;s!=null&&(k=C(s,"bias","fused matMul"),[k]=Be(k,u),Se(S,k.shape));let R;i!=null&&(R=C(i,"prelu weights","fused matMul"));const F=(M,H)=>{const[G,Y,te,ne]=H,ue=yo(W(M,te.shape),te,o);let He,Fe;if(!t&&!r?(He=Ye(ue,Y,!1,!0),Fe=Ye(G,ue,!0,!1)):!t&&r?(He=Ye(ue,Y,!1,!1),Fe=Ye(ue,G,!0,!1)):t&&!r?(He=Ye(Y,ue,!1,!0),Fe=Ye(G,ue,!1,!1)):(He=Ye(Y,ue,!0,!0),Fe=Ye(ue,G,!0,!0)),s!=null){const $t=xo(ne,ue);return[He,Fe,$t]}else return[He,Fe]},O={a:T,b:N,bias:k,preluActivationWeights:R},B={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?In((H,G,Y)=>{const te=_.runKernel(yi,O,B);return Y([H,G,te]),{value:W(te,S),gradFunc:F}})(T,N):In((H,G,Y,te)=>{const ne=_.runKernel(yi,O,B);return te([H,G,ne,Y]),{value:W(ne,S),gradFunc:F}})(T,N,k)}const Yw=A({fusedMatMul_:qw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n){return cf(n,.54,.46)}const NP=A({hammingWindow_:Qw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zw(n){return cf(n,.5,.5)}const Jw=A({hannWindow_:Zw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(n,e,t,r=!1,s=0){let o=0;const i=[];for(;o+e<=n.size;)i.push($e(n,o,e)),o+=t;if(r)for(;o<n.size;){const a=o+e-n.size,u=bt([$e(n,o,e-a),Ea([a],s)]);i.push(u),o+=t}return i.length===0?qt([],[0,e]):W(bt(i),[i.length,e])}const tv=A({frame_:ev});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n,e,t,r,s=Jw){r==null&&(r=Bw(e));const o=tv(n,e,t),i=ee(o,s(e));return of(i,r)}const EP=A({stft_:nv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rv(n,e,t,r,s="bilinear",o=0){const i=C(n,"image","cropAndResize"),a=C(e,"boxes","cropAndResize","float32"),u=C(t,"boxInd","cropAndResize","int32"),l=a.shape[0];I(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),I(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),I(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),I(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),I(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),I(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:a,boxInd:u},h={method:s,extrapolationValue:o,cropSize:r};return _.runKernel(Vc,c,h)}const sv=A({cropAndResize_:rv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ov(n){const e=C(n,"image","flipLeftRight","float32");I(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return _.runKernel(nh,t,{})}const iv=A({flipLeftRight_:ov});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(n){const e=C(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];I(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),I(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,rs(e,s)}const uv=A({grayscaleToRGB_:av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lv(n,e,t=0,r=.5){const s=C(n,"image","rotateWithOffset","float32");I(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:t,center:r};return _.runKernel(Bp,o,i)}const cv=A({rotateWithOffset_:lv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pr(n,e,t,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=n.shape[0];return t=Math.min(t,i),I(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),I(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),I(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),I(e.rank===1,()=>"scores must be a 1D tensor"),I(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),I(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=C(n,"boxes","nonMaxSuppression","float32"),i=C(e,"scores","nonMaxSuppression","float32"),a=Pr(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return _.runKernel(Lh,{boxes:o,scores:i},u)}const pv=A({nonMaxSuppression_:hv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dv(n,e,t){const r=fv(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function fv(n,e,t){return gv(n,e,t||mv)}function mv(n,e){return n>e?1:n<e?-1:0}function gv(n,e,t){let r=0,s=n.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=t(e,n[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hf(n,e,t,r,s){return _a(n,e,t,r,s,0)}function pf(n,e,t,r,s,o){return _a(n,e,t,r,s,0,!1,o,!0)}function df(n,e,t,r,s,o){return _a(n,e,t,r,s,o,!0)}function _a(n,e,t,r,s,o,i=!1,a=!1,u=!1){const l=[];for(let y=0;y<e.length;y++)e[y]>s&&l.push({score:e[y],boxIndex:y,suppressBeginIndex:0});l.sort(Mu);const c=o>0?-.5/o:0,h=[],p=[];for(;h.length<t&&l.length>0;){const y=l.pop(),{score:w,boxIndex:$,suppressBeginIndex:S}=y;if(w<s)break;let T=!1;for(let N=h.length-1;N>=S;--N){const k=yv(n,$,h[N]);if(k>=r){T=!0;break}if(y.score=y.score*xv(r,c,k),y.score<=s)break}y.suppressBeginIndex=h.length,T||(y.score===w?(h.push($),p.push(y.score)):y.score>s&&dv(l,y,Mu))}const d=h.length,f=t-d;a&&f>0&&(h.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const g={selectedIndices:h};return i&&(g.selectedScores=p),u&&(g.validOutputs=d),g}function yv(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),p=Math.max(s[1],s[3]),d=(a-o)*(u-i),f=(h-l)*(p-c);if(d<=0||f<=0)return 0;const g=Math.max(o,l),y=Math.max(i,c),w=Math.min(a,h),$=Math.min(u,p),S=Math.max(w-g,0)*Math.max($-y,0);return S/(d+f-S)}function xv(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function Mu(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=C(n,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),a=Pr(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u=await Promise.all([o.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=hf(l,c,t,r,s);return o!==n&&o.dispose(),i!==e&&i.dispose(),nt(h,"int32")}const wv=bv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),u=Pr(i,a,t,r,s,o);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const l={boxes:i,scores:a},c={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},h=_.runKernel(Vh,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}const $v=A({nonMaxSuppressionWithScore_:vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Sv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),u=Pr(i,a,t,r,s,o);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const l=await Promise.all([i.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:p,selectedScores:d}=df(c,h,t,r,s,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:nt(p,"int32"),selectedScores:nt(d)}}const Tv=Sv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),u=Pr(i,a,t,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,p={boxes:i,scores:a},d={maxOutputSize:l,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:o},f=_.runKernel(Bh,p,d);return{selectedIndices:f[0],validOutputs:f[1]}}const Nv=A({nonMaxSuppressionPadded_:Cv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ev(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),u=Pr(i,a,t,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[p,d]=await Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:g}=pf(p,d,l,c,h,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:nt(f,"int32"),validOutputs:de(g,"int32")}}const Iv=Ev;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kv(n,e,t=!1,r=!1){const s=C(n,"images","resizeBilinear");I(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),I(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},u={alignCorners:t,halfPixelCenters:r,size:e},l=_.runKernel(Jh,a,u);return i?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Rv=A({resizeBilinear_:kv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _v(n,e,t=!1,r=!1){const s=C(n,"images","resizeNearestNeighbor");I(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),I(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),I(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=W(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},u={alignCorners:t,halfPixelCenters:r,size:e},l=_.runKernel(Zh,a,u);return i?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Av=A({resizeNearestNeighbor_:_v});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n,e="binary",t=!1,r=.5){const s=C(n,"image","threshold"),o=.2989,i=.587,a=.114,u=s.shape[0]*s.shape[1];let l=ee(nt([r]),255),c,h,p,d;if(I(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),I(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),I(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),I(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,p]=cs(s,[1,1,1],-1);const y=ee(c,o),w=ee(h,i),$=ee(p,a);d=ke(ke(y,w),$)}else d=n;if(e==="otsu"){const y=kd(_e(rf(d),"int32"),$n([]),256);l=Fv(y,u)}const f=t?Ia(d,l):mo(d,l);return _e(ee(f,255),"int32")}function Fv(n,e){let t=nt([-1]),r=nt([0]),s=nt([0]),o,i,a,u,l,c;for(let h=0;h<n.size-1;h++){o=$e(n,0,h+1),i=$e(n,h+1),l=Ie(De(o),e),c=Ie(De(i),e);const p=De(ee(o,ls(0,o.size)));a=Ie(p,De(o));const d=Ea(i.shape,o.size),f=ke(ls(0,i.size),d),g=ee(i,f);u=Ie(De(g),De(i));const y=me(a,u),w=me(a,u),$=ee(l,c);s=ee(ee($,y),w);const S=mo(s,r);r=Er(S,s,r),t=Er(S,nt([h]),t)}return t}const Dv=A({threshold_:Ov});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pv(n,e,t="nearest",r="constant",s=0,o){const i=C(n,"image","transform","float32"),a=C(e,"transforms","transform","float32");I(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),I(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:i,transforms:a},l={interpolation:t,fillMode:r,fillValue:s,outputShape:o};return _.runKernel(Op,u,l)}const Lv=A({transform_:Pv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n,e,t){I(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),I(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=C(n,"a","bandPart");I(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=i))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`);e<0&&(e=o),t<0&&(t=i);const a=W(ls(0,o,1,"int32"),[-1,1]),u=ls(0,i,1,"int32"),l=me(a,u),c=Ud(Ia(l,de(+e,"int32")),Bd(l,de(-t,"int32"))),h=kn([o,i],r.dtype);return W(dn(tr(W(r,[-1,o,i])).map(p=>Er(c,p,h))),s)}const IP=A({bandPart_:Bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(n){let e;if(Array.isArray(n)){e=!1,I(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)I(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else e=!0,n=cs(n,n.shape[0],0).map(s=>Ne(s,[0]));I(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(_.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=ee(De(ee(t[i],o)),t[i]);o=me(o,a)}return Ie(o,Na(o,"euclidean"))}));return e?dn(t,0):t}const kP=A({gramSchmidt_:Vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mv(n,e=!1){if(I(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Uu(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),r=tr(W(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];r.forEach(u=>{const[l,c]=Uu(u,e);s.push(l),o.push(c)});const i=W(dn(s,0),n.shape),a=W(dn(o,0),n.shape);return[i,a]}}function Uu(n,e=!1){return _.tidy(()=>{I(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=A1(t),o=jn(n);const i=qt([[1]],[1,1]);let a=jn(i);const u=t>=r?r:t;for(let l=0;l<u;++l){const c=o,h=a,p=s;[a,o,s]=_.tidy(()=>{const d=$e(o,[l,l],[t-l,1]),f=Na(d),g=$e(o,[l,l],[1,1]),y=Er(mo(g,0),qt([[-1]]),qt([[1]])),w=me(g,ee(y,f)),$=Ie(d,w);$.shape[0]===1?a=jn(i):a=bt([i,$e($,[1,0],[$.shape[0]-1,$.shape[1]])],0);const S=Or(Ie(Ye(y,w),f)),T=$e(o,[l,0],[t-l,r]),N=ee(S,a),k=Ai(a);if(l===0)o=me(T,Ye(N,Ye(k,T)));else{const O=me(T,Ye(N,Ye(k,T)));o=bt([$e(o,[0,0],[l,r]),O],0)}const R=Ai(N),F=$e(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=me(F,Ye(Ye(F,a),R));else{const O=me(F,Ye(Ye(F,a),R));s=bt([$e(s,[0,0],[t,l]),O],1)}return[a,o,s]}),it([c,h,p])}return!e&&t>r&&(s=$e(s,[0,0],[t,r]),o=$e(o,[0,0],[r,r])),[s,o]})}const RP=A({qr_:Mv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ft;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ft||(ft={}));function Uv(n,e,t=ft.SUM_BY_NONZERO_WEIGHTS){const r=C(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=C(e,"weights","computeWeightedLoss"));const o=s==null?r:ee(r,s);if(t===ft.NONE)return o;if(t===ft.SUM)return De(o);if(t===ft.MEAN){if(s==null)return zd(o);{const i=r.size/s.size,a=Ie(De(o),De(s));return i>1?Ie(a,de(i)):a}}if(t===ft.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Ie(De(o),de(r.size));{const i=ee(s,ka(r.shape)),a=_e(De(Hd(i,de(0))),"float32");return Ie(De(o),a)}}throw Error(`Unknown reduction: ${t}`)}const _n=A({computeWeightedLoss_:Uv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e,t,r=ft.SUM_BY_NONZERO_WEIGHTS){const s=C(n,"labels","absoluteDifference"),o=C(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=C(t,"weights","absoluteDifference")),Qt(s.shape,o.shape,"Error in absoluteDifference: ");const a=kt(me(s,o));return _n(a,i,r)}const _P=A({absoluteDifference_:Wv});function zv(n,e,t,r,s=ft.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","cosineDistance"),i=C(e,"predictions","cosineDistance");let a=null;r!=null&&(a=C(r,"weights","cosineDistance")),Qt(o.shape,i.shape,"Error in cosineDistance: ");const u=de(1),l=me(u,De(ee(o,i),t,!0));return _n(l,a,s)}const AP=A({cosineDistance_:zv});function Gv(n,e,t,r=ft.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","hingeLoss");const o=C(e,"predictions","hingeLoss");let i=null;t!=null&&(i=C(t,"weights","hingeLoss")),Qt(s.shape,o.shape,"Error in hingeLoss: ");const a=de(1);s=me(ee(de(2),s),a);const u=go(me(a,ee(s,o)));return _n(u,i,r)}const OP=A({hingeLoss_:Gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hv(n,e,t,r=1,s=ft.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","huberLoss"),i=C(e,"predictions","huberLoss");let a=null;t!=null&&(a=C(t,"weights","huberLoss")),Qt(o.shape,i.shape,"Error in huberLoss: ");const u=de(r),l=kt(me(i,o)),c=Ra(l,u),h=me(l,c),p=ke(ee(de(.5),fo(c)),ee(u,h));return _n(p,a,s)}const FP=A({huberLoss_:Hv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n,e,t,r=1e-7,s=ft.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","logLoss"),i=C(e,"predictions","logLoss");let a=null;t!=null&&(a=C(t,"weights","logLoss")),Qt(o.shape,i.shape,"Error in logLoss: ");const u=de(1),l=de(r),c=Or(ee(o,us(ke(i,l)))),h=ee(me(u,o),us(ke(me(u,i),l))),p=me(c,h);return _n(p,a,s)}const DP=A({logLoss_:jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(n,e,t,r=ft.SUM_BY_NONZERO_WEIGHTS){const s=C(n,"labels","meanSquaredError"),o=C(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=C(t,"weights","meanSquaredError")),Qt(s.shape,o.shape,"Error in meanSquaredError: ");const a=af(s,o);return _n(a,i,r)}const PP=A({meanSquaredError_:Kv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xv(n,e){const t=C(n,"labels","sigmoidCrossEntropyWithLogits"),r=C(e,"logits","sigmoidCrossEntropyWithLogits");Qt(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=go(r),o=ee(r,t),i=Md(pn(Or(kt(r))));return ke(me(s,o),i)}function qv(n,e,t,r=0,s=ft.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"multiClassLabels","sigmoidCrossEntropy");const i=C(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=C(t,"weights","sigmoidCrossEntropy")),Qt(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=de(r),c=de(1),h=de(.5);o=ke(ee(o,me(c,l)),ee(h,l))}const u=Xv(o,i);return _n(u,a,s)}const LP=A({sigmoidCrossEntropy_:qv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return In((s,o,i)=>{const u=tb(o,[t],!0),l=me(_e(o,"float32"),u);i([s,l]);const c=Or(ee(l,s));return{value:De(c,[t]),gradFunc:(d,f)=>{const[g,y]=f,w=Vt(d.shape,[t]);return[ee(W(d,w),me(_e(g,"float32"),pn(y))),ee(W(d,w),me(pn(y),_e(g,"float32")))]}}})(n,e)}function Qv(n,e,t,r=0,s=ft.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"onehotLabels","softmaxCrossEntropy");const i=C(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=C(t,"weights","softmaxCrossEntropy")),Qt(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const l=de(r),c=de(1),h=de(o.shape[1]);o=ke(ee(o,me(c,l)),Ie(l,h))}const u=Yv(o,i);return _n(u,a,s)}const BP=A({softmaxCrossEntropy_:Qv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zv(n,e,t,r){const s=C(n,"indices","sparseFillEmptyRows","int32"),o=C(e,"values","sparseFillEmptyRows"),i=C(t,"denseShape","sparseFillEmptyRows","int32"),a=C(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u={indices:s,values:o,denseShape:i,defaultValue:a},l=_.runKernel(bp,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const Jv=A({sparseFillEmptyRows_:Zv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2(n,e,t){const r=C(n,"inputIndices","sparseReshape","int32"),s=C(e,"inputShape","sparseReshape","int32"),o=C(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=_.runKernel(wp,i);return{outputIndices:a[0],outputShape:a[1]}}const t2=A({sparseReshape_:e2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(n,e,t){const r=C(n,"data","sparseSegmentMean"),s=C(e,"indices","sparseSegmentMean","int32"),o=C(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return _.runKernel(vp,i)}const r2=A({sparseSegmentMean_:n2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n,e,t){const r=C(n,"data","sparseSegmentSum"),s=C(e,"indices","sparseSegmentSum","int32"),o=C(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return _.runKernel($p,i)}const o2=A({sparseSegmentSum_:s2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n,e,t,r,s,o,i,a){const u=C(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=C(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},h={data:u,dataSplits:l},p=_.runKernel(Np,h,c);return{nGrams:p[0],nGramsSplits:p[1]}}const a2=A({stringNGrams_:i2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u2(n,e,t=!0){const r=C(n,"input","stringSplit","string"),s=C(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},i={input:r,delimiter:s},a=_.runKernel(Ep,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const l2=A({stringSplit_:u2});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c2(n,e){const t=C(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return _.runKernel(Ip,s,r)}const h2=A({stringToHashBucketFast_:c2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt={flipLeftRight:iv,grayscaleToRGB:uv,resizeNearestNeighbor:Av,resizeBilinear:Rv,rotateWithOffset:cv,cropAndResize:sv,nonMaxSuppression:pv,nonMaxSuppressionAsync:wv,nonMaxSuppressionWithScore:$v,nonMaxSuppressionWithScoreAsync:Tv,nonMaxSuppressionPadded:Nv,nonMaxSuppressionPaddedAsync:Iv,threshold:Dv,transform:Lv},Ds={sparseFillEmptyRows:Jv,sparseReshape:t2,sparseSegmentMean:r2,sparseSegmentSum:o2},Go={stringNGrams:a2,stringSplit:l2,stringToHashBucketFast:h2};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p2=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:n=>n())();function d2(){return new Promise(n=>p2(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ff(n,e){const t=n[0].length;n.forEach((s,o)=>{I(s.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),I(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,o)=>{for(let i=0;i<t;i++)I(i===e||s[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function Qn(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aa=30;function vo(n){return n<=Aa?n:di(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([n[i+1]/e[i],e[i]]);s=s.concat(n.slice(o+1))}return s}function Fa(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function Da(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?r?s.push(e[o-1]*n[o]):s.push(n[o]/e[o-1]):s.push(n[o]);return s}function gf(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function yf(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xf=1.7580993408473768,bf=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wf=.3275911,vf=.254829592,$f=-.284496736,Sf=1.421413741,Tf=-1.453152027,Cf=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function f2(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function m2(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function g2(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function y2(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function x2(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function b2(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:t,imag:r}}function w2(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),o=Math.sin(r);return{real:s,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ho="->",v2=/->/g,Wu=",",zu="...";function Nf(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(v2,"").length)/Ho.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Ho}").`);const[r,s]=n.split(Ho);I(r.indexOf(zu)===-1,()=>`The ellipsis notation ("${zu}") is not supported yet.`);const o=r.split(Wu),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let p=0;p<s.length;++p){const d=s[p];if(!o.some(f=>f.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let p=0;p<r.length;++p){const d=r[p];a.indexOf(d)===-1&&d!==Wu&&a.push(d)}const u=new Array(o.length);for(let p=0;p<i;++p){if(new Set(o[p].split("")).size!==o[p].length)throw new Error(`Found duplicate axes in input component ${o[p]}. Support for duplicate axes in input is not implemented yet.`);u[p]=[];for(let d=0;d<o[p].length;++d)u[p].push(a.indexOf(o[p][d]))}const l=a.length,c=s.length,h=[];for(let p=c;p<l;++p)h.push(p);return{allDims:a,summedDims:h,idDims:u}}function Ef(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function If(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const o=t[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:I(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function kf(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<t.length;++i){const a=t[i],u=$2(e,a);for(const l of u)o.indexOf(l)===-1&&(r[i].push(l),o.push(l))}return{path:t,steps:r}}function Rf(n){return n.every((e,t)=>e===t)}function $2(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function _f(n,e,t=0){let r=[];if(typeof e=="number")I(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);I(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,u)=>u>0?a+u:a);e[o]=n.shape[t]-i}I(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Af(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Of(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Ff(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Df(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function Pf(n,e){return`size ${n} must be non-negative, not ${e}`}function Lf(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Bf(n,e){const t=j(n),r=j(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function Vf(n,e){const t=j(n),r=j(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vi(){return"segment ids must be >= 0"}function Mf(){return"segment ids are not increasing"}function Uf(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Wf(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zf(n,e){let t=!1,r;for(n<=Aa?(r=n,t=!0):r=di(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=di(n,r+1);return r}function Gf(n,e,t){const r=[],s=n.length;for(let o=0;o<s;o++)o!==e?r.push(n[o]):r.push(t);return r}function Hf(n,e,t,r){const s=e.shape.length,o=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=n.shape[t],a=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)a.push(n.shape[h]),u*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),l*=n.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=t+1;h<o;h++)a.push(n.shape[h]),c*=n.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}var S2=Object.freeze(Object.defineProperty({__proto__:null,segOpComputeOptimalWindowSize:zf,computeOutShape:Gf,collectGatherOpShapeInfo:Hf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hs(n){try{return n.map(e=>Cr(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function jf(n){return n.map(e=>Hn(e))}var T2=Object.freeze(Object.defineProperty({__proto__:null,slice_util:Bx,segment_util:S2,fromUint8ToStringArray:hs,fromStringArrayToUint8:jf,upcastType:rn,axesAreInnerMostDims:Ta,combineLocations:Dd,computeOutAndReduceShapes:on,expandShapeToKeepDim:Vt,assertAxesAreInnerMostDims:Jt,getAxesPermutation:Mt,getUndoAxesPermutation:Ca,getInnerMostAxes:Ut,getBroadcastDims:Qs,getReductionAxes:ld,assertAndGetBroadcastShape:Se,assertParamsConsistent:ff,computeOutShape:Qn,computeDilation2DInfo:Id,computePool2DInfo:Fr,computePool3DInfo:bs,computeConv2DInfo:Ct,computeConv3DInfo:ws,computeDefaultPad:va,tupleValuesAreOne:as,eitherStridesOrDilationsAreOne:Nt,convertConv2DDataFormat:Dr,checkPadOnDimRoundingMode:Bt,getFusedDyActivation:yo,getFusedBiasGradient:xo,applyActivation:bo,shouldFuse:wo,PARALLELIZE_THRESHOLD:Aa,computeOptimalWindowSize:vo,getImageCenter:mf,getReshaped:Oa,getPermuted:Fa,getReshapedPermuted:Da,getSliceBeginCoords:gf,getSliceSize:yf,prepareAndValidate:hd,validateUpdateShape:pd,validateInput:dd,calculateShapes:xa,SELU_SCALEALPHA:xf,SELU_SCALE:bf,ERF_P:wf,ERF_A1:vf,ERF_A2:$f,ERF_A3:Sf,ERF_A4:Tf,ERF_A5:Cf,warn:Xt,log:hy,mergeRealAndImagArrays:Bi,splitRealAndImagArrays:f2,complexWithEvenIndex:m2,complexWithOddIndex:g2,getComplexWithIndex:y2,assignToTypedArray:x2,exponents:b2,exponent:w2,decodeEinsumEquation:Nf,getEinsumPermutation:Ef,checkEinsumDimSizes:If,getEinsumComputePath:kf,isIdentityPermutation:Rf,prepareSplitSize:_f,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Af,getSparseFillEmptyRowsNegativeIndexErrorMessage:Of,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Ff,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Df,getSparseReshapeNegativeOutputDimErrorMessage:Pf,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Lf,getSparseReshapeInputOutputMultipleErrorMessage:Bf,getSparseReshapeInputOutputMismatchErrorMessage:Vf,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Vi,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Mf,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Uf,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Wf},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mn={},jo={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function C2(n,e){Mn[n]=e}function Yt(n,e){if(!(n in Mn)||e!=null){const r=E2(n,e);if(r!==null)Mn[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=Mn[n];return t==null||t.isContextLost()?(delete Mn[n],Yt(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Mn[n])}function N2(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function E2(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e==null?N2(n):e;return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Mn[n]},!1),n===1?t.getContext("webgl",jo)||t.getContext("experimental-webgl",jo):t.getContext("webgl2",jo)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ps;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(ps||(ps={}));var Tt;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Tt||(Tt={}));var Je;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Je||(Je={}));function $s(n,e){return[e,n]}function I2(n,e){return n*e}function Ps(n){const e=j(n),t=Math.ceil(e/4);return hi(t)}function Lr(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function k2(n,e){const[t,r]=Lr(n,e);return t*r*4}function Pa(n,e){const t=n;let r,s,o,i,a,u,l,c,h,p;return L().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,o=t.RGBA16F,i=t.RGBA32F,a=t.RED,l=4,c=1,h=t.HALF_FLOAT,p=t.FLOAT,u=t.RGBA8):(r=n.RGBA,s=n.RGBA,o=n.RGBA,i=t.RGBA,a=n.RGBA,l=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT,u=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q(n,e){const t=e();return L().getBool("DEBUG")&&R2(n),t}function R2(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+F2(n,e))}const _2=596e-10,A2=65504;function O2(n){return!!(L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||_2<Math.abs(n)&&Math.abs(n)<A2)}function F2(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Ls(n,e){return fn(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function D2(n,e){const t=fn(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Q(n,()=>n.shaderSource(t,e)),Q(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function P2(n,e){const t=fn(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Q(n,()=>n.shaderSource(t,e)),Q(n,()=>n.compileShader(t)),L().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw Kf(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const L2=/ERROR: [0-9]+:([0-9]+):/g;function Kf(n,e){const t=L2.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),o=s.length.toString().length+2,i=s.map((h,p)=>xr((p+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const u=i.slice(0,r-1),l=i.slice(r-1,r),c=i.slice(r);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${xr(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function B2(n){return fn(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function V2(n,e){if(Q(n,()=>n.linkProgram(e)),!L().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Ko(n,e){if(Q(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function M2(n,e){const t=fn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Q(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function U2(n,e){const t=fn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Q(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Q(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function W2(n){return fn(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function z2(n,e){const t=L().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function G2(n){return fn(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Gu(n,e,t,r,s,o,i){const a=n.getAttribLocation(e,t);return a===-1?!1:(Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Q(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,o,i)),Q(n,()=>n.enableVertexAttribArray(a)),!0)}function H2(n,e,t){Y2(n,t),Q(n,()=>n.activeTexture(n.TEXTURE0+t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function j2(n,e,t){return fn(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function K2(n,e,t){return n.getUniformLocation(e,t)}function X2(n,e,t,r){Q(n,()=>H2(n,e,r)),Q(n,()=>n.uniform1i(t,r))}function Xo(n,e,t){Q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function Hu(n,e){Q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Bs(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+q2(n,e))}function q2(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function fn(n,e,t){const r=Q(n,()=>e());if(r==null)throw new Error(t);return r}function Y2(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Ir(n,e=2){return j(n.slice(0,n.length-e))}function kr(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function qo(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Ir(n),...kr(n)]),e}function Q2(n,e=!1){let t=L().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,n=n.map((s,o)=>o>=n.length-2?ec(n[o]):n[o]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Rn(n).newShape);let r=j(n);if(n.length<=1&&r<=t)return[1,r];if(n.length===2&&n[0]<=t&&n[1]<=t)return n;if(n.length===3&&n[0]*n[1]<=t&&n[2]<=t)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=t&&n[1]*n[2]<=t)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t)return[n[0],n[1]*n[2]*n[3]];if(e){const s=Ir(n);let o=2,i=2;return n.length&&([o,i]=kr(n)),r=s*(o/2)*(i/2),hi(r).map(a=>a*2)}return hi(r)}function Vs(n){return n%2===0}function to(n,e){if(n=n.slice(-2),e=e.slice(-2),ze(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],r=e.slice(-1)[0];if(t===r||Vs(t)&&Vs(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Vs(n[0])&&Vs(e[0])}let Yo,Qo;function Z2(n){if(Yo==null){const e=Yt(n);Yo=e.getParameter(e.MAX_TEXTURE_SIZE)}return Yo}function J2(n){if(Qo==null){const e=Yt(n);Qo=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Qo)}function e$(n){if(n===0)return 0;let e;const t=Yt(n);return Pt(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Pt(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Pt(n,e){return n.getExtension(e)!=null}function ju(n){try{if(Yt(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function t$(n){if(n===0)return!1;const e=Yt(n);if(n===1){if(!Pt(e,"OES_texture_float"))return!1}else if(!Pt(e,"EXT_color_buffer_float"))return!1;return Mi(e)}function n$(n){if(n===0)return!1;const e=Yt(n);if(n===1){if(!Pt(e,"OES_texture_float")||!Pt(e,"WEBGL_color_buffer_float"))return!1}else{if(Pt(e,"EXT_color_buffer_float"))return Mi(e);const r="EXT_color_buffer_half_float";if(Pt(e,r)){const s=e.getExtension(r);return r$(e,s)}return!1}return Mi(e)}function Mi(n){const e=Pa(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,s=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,s,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(o),i}function r$(n,e){const t=Pa(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const s=1,o=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,s,o,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(i),a}function s$(n){return n!==2?!1:Yt(n).fenceSync!=null}function Ss(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&I(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J=L();J.registerFlag("HAS_WEBGL",()=>J.getNumber("WEBGL_VERSION")>0);J.registerFlag("WEBGL_VERSION",()=>ju(2)?2:ju(1)?1:0);J.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);J.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>J.get("WEBGL_VERSION")===2);J.registerFlag("WEBGL_CPU_FORWARD",()=>!0);J.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);J.registerFlag("WEBGL_PACK",()=>J.getBool("HAS_WEBGL"));J.registerFlag("WEBGL_PACK_NORMALIZATION",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_CLIP",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_PACK_REDUCE",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_LAZILY_UNPACK",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_CONV_IM2COL",()=>J.getBool("WEBGL_PACK"));J.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Z2(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>J2(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=J.getNumber("WEBGL_VERSION");return n===0?0:e$(n)});J.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>J.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Yp());J.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>t$(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>J.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:J.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));J.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>n$(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_FENCE_API_ENABLED",()=>s$(J.getNumber("WEBGL_VERSION")));J.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>J.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);J.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});J.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Yp()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});J.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);J.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);J.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);J.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(){let n,e,t,r,s,o,i,a,u,l;return L().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nr(n,e,t="index"){const r=rt(e);return r.map((s,o)=>{const i=`int ${n[o]} = ${t} / ${s}`,a=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`;return`${i}; ${a};`}).join("")}function $o(n,e,t="index"){const r=rt(e);return r.map((s,o)=>{const i=`int ${n[o]} = ${t} / outShapeStrides[${o}]`,a=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function o$(n,e){const t=n.length,r=n.map(o=>`${e}[${o}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let o=t-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}function i$(n,e,t="index"){const r=n.map((o,i)=>i),s=o$(r,e);return s.map((o,i)=>{const a=`int ${n[i]} = ${t} / ${s[i]}`,u=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${s[i]}`:`index -= ${n[i]} * ${s[i]}`;return`${a}; ${u};`}).join("")}function La(n){const e=rt(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Ba(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Xf=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:qf}=T2;function a$(n,e,t){const r=[];if(n.forEach(d=>{const f=j(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:g}=Va(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const s=r.join(`
`),o=n.map(d=>u$(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=ht(),u=h$(a);let l,c,h=f$(a);return e.isPacked?(l=l$(e.logicalShape,i,t.enableShapeUniforms),c=d$(a)):(l=c$(e.logicalShape,i,t.enableShapeUniforms),c=p$(a)),t.packedInputs&&(h+=x$),[h,u,c,s,l,o,t.userCode].join(`
`)}function Br(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return R$(n,e);case 1:return A$(n,e);case 2:return F$(n,e);case 3:return P$(n,e);case 4:return B$(n,e);case 5:return V$(n);case 6:return M$(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Yf(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return k$(n);case 1:return _$(n,e);case 2:return O$(n,e);case 3:return D$(n,e);default:return L$(n,e)}}function u$(n,e,t=!1,r){let s="";t?s+=Yf(n,r):s+=Br(n,r);const o=n.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(t?s+=U$(n,e):s+=W$(n,e)),s}function l$(n,e,t){switch(n.length){case 0:return Qf();case 1:return b$(n,e,t);case 2:return E$(n,e,t);case 3:return v$(n,e,t);default:return S$(n,e,t)}}function c$(n,e,t){switch(n.length){case 0:return Qf();case 1:return w$(n,e,t);case 2:return I$(n,e,t);case 3:return $$(n,e,t);case 4:return T$(n,e,t);case 5:return C$(n,e);case 6:return N$(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function h$(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function p$(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function d$(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function f$(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${m$}
    ${g$}
    ${y$}
  `}const m$=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,g$=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,y$=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,x$=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Qf(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function b$(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function w$(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function v$(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),o=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function $$(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${$o(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=nr(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function S$(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),o=s*Math.ceil(n[n.length-2]/2);let i=o,a="",u="b, r, c";for(let l=2;l<n.length-1;l++)i*=n[n.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${u});
    }
  `}function T$(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${$o(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=nr(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function C$(n,e){const t=nr(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function N$(n,e){const t=nr(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function E$(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(ze(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function I$(n,e,t){return ze(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function rr(n){return`offset${n}`}function k$(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=ht();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function R$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,o]=n.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=rr(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;const[a,u]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function _$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,o=ht();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${t}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function A$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Vr(n)}
      }
    `;const s=n.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=rr(t);return i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${t}, uv);
      }
    `:o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function O$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=o[0],a=o[1],u=ht();if(o!=null&&ze(t,o))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function F$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape;if(o!=null&&ze(t,o)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const p=o[0],d=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:a}=Rn(t),u=i;if(u.length<t.length){const p=Mr(n,u),d=["row","col"];return`
      ${Br(p,e)}
      float ${s}(int row, int col) {
        return ${s}(${Ur(d,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Vr(n)}
      }
    `;const l=o[0],c=o[1],h=rr(r);return c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function D$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(t[0]===1){const p=t.slice(1),d=[1,2],f=Mr(n,p),g=["b","row","col"];return`
        ${Yf(f,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Ur(g,d)});
        }
      `}const a=ht();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const u=i[0],l=i[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function P$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[1]*t[2],i=t[2],{newShape:a,keptDims:u}=Rn(t),l=a;if(l.length<t.length){const g=Mr(n,l),y=["row","col","depth"];return`
        ${Br(g,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Ur(y,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Vr(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],p=c[1],d=n.shapeInfo.flatOffset;if(p===o&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(p===i&&d==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=rr(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * ${o} + col * ${i} + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${p}, index);
        return sampleTexture(${r}, uv);
      }
  `}function L$(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=ht();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const o=n.shapeInfo.logicalShape,i=o.length,a=n.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],h=Math.ceil(o[i-1]/2);let p=h*Math.ceil(o[i-2]/2),d="int b, int row, int col",f=`b * ${p} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<i-1;g++)d=`int b${g}, `+d,p*=o[i-g-1],f=`b${g} * ${p} + `+f;return`
    vec4 ${r}(${d}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${s.texture2D}(${t}, uv);
    }
  `}function B$(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[3],i=t[2]*o,a=t[1]*i,{newShape:u,keptDims:l}=Rn(t);if(u.length<t.length){const $=Mr(n,u),S=["row","col","depth","depth2"];return`
      ${Br($,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Ur(S,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Vr(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],d=h[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===o&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${p}.0);
        return sampleTexture(${r}, uv);
      }
    `;const w=rr(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${g}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${w});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${p}, ${d}, index + ${w});
      return sampleTexture(${r}, uv);
    }
  `}function V$(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],o=e[3]*s,i=e[2]*o,a=e[1]*i,{newShape:u,keptDims:l}=Rn(e);if(u.length<e.length){const g=Mr(n,u),y=["row","col","depth","depth2","depth3"];return`
      ${Br(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Ur(y,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${s})) +
          depth3;
        ${Vr(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],d=h[1];if(d===a&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=rr(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function M$(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:o}=Rn(e);if(s.length<e.length){const y=Mr(n,s),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${Br(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Ur(w,o)});
      }
    `}const i=e[5],a=e[4]*i,u=e[3]*a,l=e[2]*u,c=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Vr(n)}
      }
    `;const h=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,d=p[0],f=p[1];if(f===c&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===i&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=rr(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Vr(n){const e=n.name,t=j(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function U$(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=n.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=qf(n.shapeInfo.logicalShape,e.logicalShape),u=Ae(i),l=i-o;let c;const h=["x","y","z","w","u","v"];o===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map($=>`coords.${h[$+l]} = 0;`).join(`
`);let p="";i<2&&o>0?p="coords":p=n.shapeInfo.logicalShape.map(($,S)=>`coords.${h[S+l]}`).join(", ");let d="return outputValue;";const g=j(n.shapeInfo.logicalShape)===1,w=j(e.logicalShape)===1;if(o===1&&!g&&!w)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!w)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){const $=o-2,S=o-1;a.indexOf($)>-1&&a.indexOf(S)>-1?d="return vec4(outputValue.x);":a.indexOf($)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(S)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${p});
      ${d}
    }
  `}function W$(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=e.texShape,i=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===u&&n.shapeInfo.flatOffset==null&&ze(i,o))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const l=Ae(u),c=qf(n.shapeInfo.logicalShape,e.logicalShape),h=u-a;let p;const d=["x","y","z","w","u","v"];a===0?p="":u<2&&c.length>=1?p="coords = 0;":p=c.map(g=>`coords.${d[g+h]} = 0;`).join(`
`);let f="";return u<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((g,y)=>`coords.${d[y+h]}`).join(", "),`
    float ${s}() {
      ${l} coords = getOutputCoords();
      ${p}
      return get${r}(${f});
    }
  `}function Ae(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Va(n,e,t){const{newShape:r,keptDims:s}=Rn(e),o=e.length,i=n&&o===3&&e[0]===1,a=i?e.slice(1):r,u=!n&&o>1&&!ze(e,t)&&r.length<o||i;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:s}}function Mr(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Ur(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e,t,r){const s=t.map((c,h)=>{const p={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(p.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:p}}),o=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=a$(s,i,e),u=P2(n.gl,a),l=n.createProgram(u);return L().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:o,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:o,outShapeInfo:i},Zf(n,e,l))}function Zf(n,e,t){const r={},s={},o={},i=[];let a,u,l,c=null,h=null;h=n.getUniformLocation(t,"NAN",!1),L().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));const p=!1;for(let d=0;d<e.variableNames.length;d++){const f=e.variableNames[d];r[f]=n.getUniformLocation(t,f,p),r[`offset${f}`]=n.getUniformLocation(t,`offset${f}`,p),e.enableShapeUniforms&&(s[`${f}Shape`]=n.getUniformLocation(t,`${f}Shape`,p),o[`${f}TexShape`]=n.getUniformLocation(t,`${f}TexShape`,p))}return e.enableShapeUniforms&&(a=n.getUniformLocation(t,"outShape",p),l=n.getUniformLocation(t,"outShapeStrides",p),u=n.getUniformLocation(t,"outTexShape",p)),e.customUniforms&&e.customUniforms.forEach((d,f)=>{i[f]=n.getUniformLocation(t,d.name,p)}),{uniformLocations:r,customUniformLocations:i,infLoc:c,nanLoc:h,inShapesLocations:s,inTexShapesLocations:o,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}}function Ku(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,o=e[r],i=o.shape;if(!ze(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(t.isUniform&&o.isUniform)return;const a=t.texShape,u=o.isUniform?null:o.texData.texShape;if(!ze(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function G$(n,e,t,r,s){e.program.enableShapeUniforms||(Ku(e.inShapeInfos,t),Ku([e.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):n.setOutputMatrixTexture(o.texture,i[0],i[1]),n.setProgram(e.webGLProgram),L().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{const c=e.program.variableNames[l],h=e.uniformLocations[c],p=e.uniformLocations[`offset${c}`],d=e.inShapesLocations[`${c}Shape`],f=e.inTexShapesLocations[`${c}TexShape`];if(d){const{uniformShape:g}=Va(e.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(d,new Int32Array(g));break;case 2:n.gl.uniform2iv(d,new Int32Array(g));break;case 3:n.gl.uniform3iv(d,new Int32Array(g));break;case 4:n.gl.uniform4iv(d,new Int32Array(g));break}}if(f&&n.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),h!=null){if(u.isUniform){if(j(u.shape)<2)n.gl.uniform1f(h,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(h,g)}return}u.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,h,l)}});const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const u=rt(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s&&e.program.customUniforms.forEach((u,l)=>{const c=e.customUniformLocations[l],h=s[l];if(u.type==="float")n.gl.uniform1fv(c,h);else if(u.type==="vec2")n.gl.uniform2fv(c,h);else if(u.type==="vec3")n.gl.uniform3fv(c,h);else if(u.type==="vec4")n.gl.uniform4fv(c,h);else if(u.type==="int")n.gl.uniform1iv(c,h);else if(u.type==="ivec2")n.gl.uniform2iv(c,h);else if(u.type==="ivec3")n.gl.uniform3iv(c,h);else if(u.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}),n.executeProgram()}function H$(n,e,t){let r="";e.concat(t).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:h}=Va(n.packedInputs,i.shape,u);let p="",d="",f="";if(c.length===1&&n.packedInputs){const N=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];p=`${N[0]>1}_${N[1]>1}`}else if(c.length===2&&!n.packedInputs)d=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const N=rt(c);f=`${N[0]===u[1]}_${N[N.length-1]===u[1]}`}const g=i.shape.length,y=c.length===2&&ze(i.shape,u),w=j(i.shape)===1,$=Qs(i.shape,t.shape),S=!n.packedInputs&&g===t.shape.length&&ze(u,t.texData.texShape),T=n.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${g}_${S}_${l?h:""}_${c.length}_${w}_${$}_${y}_${p}_${d}_${f}_${T}_${a}`}else{const u=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${u}_${a}`}});const s=n.userCode;let o=n.constructor.name;return o+="_"+r+"_"+s+`${L().getNumber("WEBGL_VERSION")}`,o}function mt(n){return L().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j${constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ps.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ht();this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?$o(["r","c","d"],e):nr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ps.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ht();this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?$o(["r","c","d"],e):nr(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X${constructor(e){this.variableNames=["A"],this.outTexUsage=Tt.DOWNLOAD;const t=ht();this.outputShape=e,this.userCode=`
      ${Xf}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Tt.DOWNLOAD;const t=ht();this.outputShape=e,this.userCode=`
      ${Xf}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y${constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ht();this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Ba():La(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q${constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ht();this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length);let s="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const u=i*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Ba():La(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(n){const e=ht(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return D2(n,t)}function J$(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return M2(n,e)}function eS(n){const e=new Uint16Array([0,1,2,2,1,3]);return U2(n,e)}function Ts(n,e,t,r,s,o){z2(e,t);const i=W2(n),a=n.TEXTURE_2D;return Q(n,()=>n.bindTexture(a,i)),Q(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Q(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Q(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Q(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),L().getNumber("WEBGL_VERSION")===1?Q(n,()=>n.texImage2D(a,0,r,e,t,0,s,o,null)):Q(n,()=>n.texStorage2D(a,1,r,e,t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[t,e]}}function Jf(n){return n.internalFormatFloat}function tS(n,e,t,r){const[s,o]=$s(e,t);return Ts(n,s,o,Jf(r),r.textureFormatFloat,n.FLOAT)}function em(n){return n.internalFormatHalfFloat}function nS(n,e,t,r){const[s,o]=$s(e,t);return Ts(n,s,o,em(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function tm(n){return n.downloadTextureFormat}function rS(n,e,t,r){const[s,o]=$s(e,t);return Ts(n,s,o,tm(r),n.RGBA,n.UNSIGNED_BYTE)}function nm(n){return n.internalFormatPackedFloat}function sS(n,e,t,r){const[s,o]=Lr(e,t);return Ts(n,s,o,nm(r),n.RGBA,n.FLOAT)}function rm(n){return n.internalFormatPackedHalfFloat}function oS(n,e,t,r){const[s,o]=Lr(e,t);return Ts(n,s,o,rm(r),n.RGBA,r.textureTypeHalfFloat)}function iS(n,e,t){return Q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Gu(n,e,"clipSpacePos",t,3,20,0)&&Gu(n,e,"uv",t,2,20,12)}function aS(n,e,t,r,s,o){Q(n,()=>n.bindTexture(n.TEXTURE_2D,e));let i,a,u;s instanceof Uint8Array?(i=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,u=n.RGBA):(i=new Float32Array(t*r*4),a=n.FLOAT,u=o.internalFormatPackedFloat),i.set(s),L().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,i)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,t,r,0,n.RGBA,a,i)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function uS(n,e,t){Q(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?L().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):L().getNumber("WEBGL_VERSION")===2?Q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function lS(n,e,t,r){const s=n.createBuffer();Q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=4*4*e*t;return Q(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Q(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function cS(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function hS(n,e,t,r){const[s,o]=$s(e,t),i=4,a=new Uint8Array(I2(e*t,i));return Q(n,()=>n.readPixels(0,0,s,o,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function pS(n,e,t,r,s,o,i,a){const u=n,l=new Float32Array(k2(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function dS(n,e,t){const r=new Float32Array(e*t*4);return Q(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zo{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=L().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,C2(t,e)):this.gl=Yt(t);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),L().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Ls(this.gl,o),Pt(this.gl,i))this.textureHalfFloatExtension=Ls(this.gl,i);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Pt(this.gl,s))this.colorBufferHalfFloatExtension=Ls(this.gl,s);else if(L().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Pt(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Pt(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=J$(this.gl),this.indexBuffer=eS(this.gl),this.framebuffer=G2(this.gl),this.textureConfig=Pa(this.gl,this.textureHalfFloatExtension)}get debug(){return L().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Q(e,()=>e.finish()),Q(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Q(e,()=>e.deleteFramebuffer(this.framebuffer)),Q(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Q(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Q(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),tS(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),nS(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),rS(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),uS(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),aS(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),oS(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),sS(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Hu(this.gl,this.framebuffer),this.outputTexture=null),Q(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>hS(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,o,i){return pS(this.gl,e,t,r,s,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return cS(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=lS(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(L().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},t=o}else L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>dS(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=Z$(t));const r=B2(t);return Q(t,()=>t.attachShader(r,this.vertexShader)),Q(t,()=>t.attachShader(r,e)),V2(t,r),this.debug&&Ko(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=iS(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Q(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Ko(this.gl,this.program),Q(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?j2(this.gl,e,t):K2(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Q(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),X2(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,o]=Lr(t,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Ko(this.gl,this.program),Bs(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),Q(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Q(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Ls(this.gl,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await du(()=>this.disposed||this.isQueryAvailable(e,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=fS(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&du(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Xo(this.gl,e,this.framebuffer),this.debug&&Bs(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Xo(this.gl,this.outputTexture,this.framebuffer),this.debug&&Bs(this.gl)):Hu(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;Xo(s,e,this.framebuffer),this.debug&&Bs(s),this.outputTexture=e,Q(s,()=>s.viewport(0,0,t,r)),Q(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Q(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function fS(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mS(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wt(n){return(e,t,r,s,o)=>{const i=Se(e,t),a=i.length,u=rt(i),l=j(i),c=Cn(o,l),h=e.length,p=t.length,d=rt(e),f=rt(t),g=Qs(e,i),y=Qs(t,i);if(g.length+y.length===0)for(let w=0;w<c.length;++w)c[w]=n(r[w%r.length],s[w%s.length]);else for(let w=0;w<c.length;++w){const $=sc(w,a,u),S=$.slice(-h);g.forEach(R=>S[R]=0);const T=mi(S,h,d),N=$.slice(-p);y.forEach(R=>N[R]=0);const k=mi(N,p,f);c[w]=n(r[T],s[k])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gS=Wt((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(n,e,t,r,s){const o=j(r),i=Nn(s,t);for(let a=0;a<n.length;a++){const u=n[a];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o>0?i[u]+=e[a]:i[u]+=1)}return i}function xS(n,e,t,r=!1){const s=n.shape[0],o=n.shape[1],i=Ge([s,t],e.dtype);for(let a=0;a<s;a++)for(let u=0;u<o;u++){const l=n.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function An(n){return(e,t,r)=>{const s=Cn(t,e.length);for(let o=0;o<e.length;++o)s[o]=n(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bS=An(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n,e,t,r){const s=At(t,j(e));if(r&&t!=="string"){let o=0;n.forEach(i=>{const a=j(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a=t==="string"?hs(i.vals):i.vals;let u=0;for(let l=0;l<i.shape[0];++l){const c=l*e[1]+o;for(let h=0;h<i.shape[1];++h)s[c+h]=a[u++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vS=Wt((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $S=An(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SS=An(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TS=An(n=>Math.floor(n));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CS(n,e,t,r,s,o,i,a,u){const l=Ge([r,o],t);for(let c=0;c<r;c++){const h=[];let p=0;for(let d=0;d<s;d++){const f=n[c*s+d];p+=f*i[d],h.push(f)}if(p<0||p>=u/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let d=0;d<o;d++)l.values[c*o+d]=e.get(...e.indexToLoc(p*o+d))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n,e,t){const r=Ge(t,n.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],u=i[2],l=e.locToIndex([a,u]);i[2]=e.values[l];const c=n.locToIndex(i);0<=c&&c<n.values.length&&(r.values[s]=n.values[c])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ES=Wt((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IS=Wt((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kS=Wt((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RS=Wt((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _S(n,e,t){const r=(e-n)/(t-1),s=Nn(t,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AS=An(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n,e,t,r){const s=Cn(r,j(t));for(let o=0;o<s.length;++o){const i=o*e;let a=n[i];for(let u=0;u<e;++u){const l=n[i+u];(Number.isNaN(l)||l>a)&&(a=l)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FS=Wt((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DS=Wt((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sm=Wt((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PS(n,e,t){const r=Ar(-1,t);return sm([],e,r,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LS=Wt((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BS(n,e,t,r,s){const o=e.length,i=j(e),a=rt(e),u=rt(s),l=Cn(t,j(s));for(let c=0;c<i;++c){const h=sc(c,o,a),p=new Array(h.length);for(let f=0;f<p.length;f++)p[f]=h[r[f]];const d=mi(p,o,u);l[d]=n[c]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VS(n,e,t,r){const[s,o]=on(n,r),i=rn(e,"int32"),a=Nn(j(s),i),u=j(o);for(let l=0;l<a.length;++l){const c=l*u;let h=1;for(let p=0;p<u;++p)h*=t[c+p];a[l]=h}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MS(n,e,t,r){const s=n===e,o=n<e&&t<0,i=e<n&&t>1;if(s||o||i)return Nn(0,r);const a=Math.abs(Math.ceil((e-n)/t)),u=Nn(a,r);e<n&&t===1&&(t=-1),u[0]=n;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const US=An(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n,e,t,r,s,o,i,a,u,l){const c=[r/s,s],h=n.values,p=e.values;if(r===0)return Ge(t,e.dtype);const d=Ge(c,e.dtype);typeof u=="string"||typeof u=="number"?d.values.fill(u):typeof u=="boolean"&&d.values.fill(+u);for(let f=0;f<o;f++){const g=[];let y=0;for(let w=0;w<i;w++){const $=h[f*i+w];g.push($),y+=$*a[w]}if(y<0||y>=r/s)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let w=0;w<s;w++)l?d.values[y*s+w]+=p[f*s+w]:d.values[y*s+w]=e.rank===0?p[0]:p[f*s+w]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zS=An(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GS(n,e,t,r,s){const o=ba(r,e,t),i=j(t),a=rt(r);if(o){const h=wa(e,a);return s==="string"?n.slice(h,h+i):n.subarray(h,h+i)}const u=s==="string"?hs(n):n,l=Ge(r,s,u),c=Ge(t,s);for(let h=0;h<c.size;++h){const p=c.indexToLoc(h),d=p.map((f,g)=>f+e[g]);c.set(l.get(...d),...p)}return s==="string"?jf(c.values):c.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HS(n,e,t,r,s,o,i){const a=e[0],u=o[0],l=new Array(u),c=new Array(a),h=e[1];if(u===0){if(a!==0)throw new Error(Af(a));const y=At(t,0),w=At(s,0);return[y,[0,h],w,l,c]}let p=!0,d=0;const f=new Array(u).fill(0);for(let y=0;y<a;++y){const w=n[y*h];if(w<0)throw new Error(Of(y,w));if(w>=u)throw new Error(Ff(y,w,u));++f[w],p=p&&w>=d,d=w}let g=!0;for(let y=0;y<u;++y){const w=f[y]===0;l[y]=w,g=g&&!w,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(g&&p){const y=n,w=r;for(let $=0;$<a;++$)c[$]=$;return[y,[a,h],w,l,c]}else{const y=f[u-1],w=At(t,y*h),$=At(s,y),S=new Array(u).fill(0);for(let T=0;T<a;++T){const N=n[T*h],k=S[N],R=(N===0?0:f[N-1])+k;S[N]++;for(let F=0;F<h;++F)w[R*h+F]=n[T*h+F];$[R]=r[T],c[T]=R}for(let T=0;T<u;++T)if(S[T]===0){const k=T===0?0:f[T-1];w[k*h+0]=T;for(let R=1;R<h;++R)w[k*h+R]=0;$[k]=i}return[w,[y,h],$,l,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(n,e,t,r,s){const o=j(r),i=e[0],a=s.length,u=[];let l=1,c=-1;for(let y=0;y<a;++y){const w=s[y];if(w===-1){if(c!==-1)throw new Error(Df(c,y));c=y,u.push(1)}else{if(w<0)throw new Error(Pf(y,w));l*=w,u.push(w)}}if(c!==-1){if(l<=0)throw new Error(Lf());const y=Math.trunc(o/l);if(l*y!==o)throw new Error(Bf(r,u));u[c]=y}if(j(u)!==o)throw new Error(Vf(r,u));const p=r.length,d=[];if(p>0){d[p-1]=1;for(let y=p-2;y>=0;--y)d[y]=d[y+1]*r[y+1]}const f=[];if(a>0){f[a-1]=1;for(let y=a-2;y>=0;--y)f[y]=f[y+1]*u[y+1]}const g=At(t,i*a);for(let y=0;y<i;++y){let w=0;for(let $=0;$<p;++$)w+=n[y*p+$]*d[$];for(let $=0;$<a;++$)g[y*a+$]=Math.trunc(w/f[$]),w%=f[$]}return[g,[i,a],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(n,e,t,r,s,o=!1,i=0){const a=r.length,u=[e[0],n.length/e[0]],l=u[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(Vi());const p=e.slice();p[0]=h;const d=p.reduce((S,T)=>S*T,1),f=At(t,d);if(a===0)return h>0&&f.fill(i),[f,p];if(h<=0)throw new Error(Vi());let g=0,y=1,w=0,$=s[g];for(;;){let S=0;if(y<a){if(S=s[y],$===S){++y;continue}if($>=S)throw new Error(Mf())}if($<0||$>=h)throw new Error(Uf($,h));$>w&&f.fill(i,w*l,$*l);for(let T=g;T<y;++T){const N=r[T];if(N<0||N>=u[0])throw new Error(Wf(T,r[T],u[0]));for(let k=0;k<l;k++)f[$*l+k]+=n[N*l+k]}if(o)for(let T=0;T<l;T++)f[$*l+T]/=y-g;if(g=y,++y,w=$+1,$=S,y>a)break}return w<h&&f.fill(i,w*l,h*l),[f,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XS=An(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qS=Wt((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YS(n,e,t,r){const s=Ge(n,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*t[u]+r[u];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QS{constructor(e,t,r,s,o,i){this.separator=Hn(e),this.nGramWidths=t,this.leftPad=Hn(r),this.rightPad=Hn(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,o,i){for(let a=0;a<o;++a){const u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(o-(a+1))),h=i-(l+c),p=t+(l>0?0:a-u);let d=0;d+=l*this.leftPad.length;for(let $=0;$<h;++$)d+=e[p+$].length;d+=c*this.rightPad.length,d+=(l+c+h-1)*this.separator.length,r[s+a]=new Uint8Array(d);const g=r[s+a];let y=0;const w=$=>$.forEach(S=>g[y++]=S);for(let $=0;$<l;++$)w(this.leftPad),w(this.separator);for(let $=0;$<h-1;++$)w(e[p+$]),w(this.separator);if(h>0){w(e[p+h-1]);for(let $=0;$<c;++$)w(this.separator),w(this.rightPad)}else{for(let $=0;$<c-1;++$)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<s;++l){let c=t[l]>=u;if(c=c&&t[l]<=r,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${r}]`);u=t[l]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const o=s-1,i=At("int32",s);if(r===0||s===0){const u=new Array(r);for(let l=0;l<=o;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=o;++u){const l=t[u]-t[u-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(l,h)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}const a=new Array(i[o]);for(let u=0;u<o;++u){const l=t[u];let c=i[u];if(this.nGramWidths.forEach(h=>{const p=t[u+1]-t[u],d=this.getNumNGrams(p,h);this.createNGrams(e,l,a,c,d,h),c+=d}),this.preserveShort&&c===i[u]){const h=t[u+1]-t[u];if(h===0)continue;const p=h+2*this.padWidth,d=1;this.createNGrams(e,l,a,c,d,p)}}return[a,i]}}function ZS(n,e,t,r,s,o,i,a){return new QS(t,r,s,o,i,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JS(n,e,t,r){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=n.indexOf(o);for(;i!==-1;){const a=n.subarray(0,i);(!t||a.length!==0)&&r.push(a),n=n.subarray(i+1),i=n.indexOf(o)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const i=n.subarray(s,o);(!t||i.length!==0)&&r.push(i),s=o+1}}function eT(n,e,t){const r=n.length,s=[];let o=0,i=0;const a=new Array(r);for(let p=0;p<r;++p){const d=s.length;JS(n[p],e,t,s);const f=s.length-d;a[p]=f,o+=f,i=Math.max(i,f)}const u=At("int32",o*2),l=new Array(o),c=[r,i];let h=0;for(let p=0;p<r;++p)for(let d=0;d<a[p];++d)u[h*2]=p,u[h*2+1]=d,l[h]=s[h],++h;return[u,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tT(n,e){const t=At("int32",n.length);for(let r=0;r<n.length;++r)t[r]=wy(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT=Wt((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rT(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Ge(t,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(n.rank);for(let u=0;u<i.length;u++)i[u]=o[u]%n.shape[u];const a=n.locToIndex(i);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ns=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function om(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,u=e-t+1,l=Math.log(a),c=.5*Math.exp(2*l/3),h=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),p=Math.max(t,Math.floor(e-u*c/a+h)),d=Math.min(r,Math.floor(e+(a-u)*c/a+h));om(n,e,p,d)}const s=n[e];let o=t,i=r;for(Yr(n,t,e),ns(n[r],s)>0&&Yr(n,t,r);o<i;){for(Yr(n,o,i),o++,i--;ns(n[o],s)<0;)o=o+1;for(;ns(n[i],s)>0;)i=i-1}ns(n[t],s)===0?Yr(n,t,i):(i=i+1,Yr(n,i,r)),i<=e&&(t=i+1),e<=i&&(r=i-1)}}function sT(n,e,t,r,s){const o=e[e.length-1],[i,a]=[n.length/o,o],u=Cn(t,i*r),l=Cn("int32",i*r);for(let h=0;h<i;h++){const p=h*a,d=n.subarray(p,p+a);let f=new Array(d.length);d.forEach(($,S)=>f[S]={value:$,index:S}),r<f.length&&(om(f,r),f=f.slice(0,r)),s&&f.sort(ns);const g=h*r,y=u.subarray(g,g+r),w=l.subarray(g,g+r);for(let $=0;$<r;$++)y[$]=f[$].value,w[$]=f[$].index}const c=e.slice();return c[c.length-1]=r,[Ge(c,t,u),Ge(c,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oT(n,e,t,r){const s=et(e,t)[0],o=[1,t[0],1];for(let f=0;f<s;f++)o[0]*=t[f];o[1]=t[s];for(let f=s+1;f<t.length;f++)o[2]*=t[f];const i={},a=new Int32Array(t[s]),u=new os(o,r,n),l=[],c=o[0]===1&&o[2]===1;for(let f=0;f<t[s];f++){let g;if(c)g=n[f].toString();else{const y=[];for(let w=0;w<o[0];w++)for(let $=0;$<o[2];$++)y.push(u.get(w,f,$));g=y.join(",")}if(i[g]!==void 0)a[f]=i[g];else{const y=Object.keys(i).length;i[g]=y,a[f]=y,l.push(f)}}const h=o.slice();h[1]=Object.keys(i).length;const p=new os(h,r);l.forEach((f,g)=>{for(let y=0;y<o[0];y++)for(let w=0;w<o[2];w++)p.set(u.get(y,f,w),y,g,w)});const d=t.slice();return d[s]=h[1],{outputValues:p.values,outputShape:d,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var iT=Object.freeze(Object.defineProperty({__proto__:null,simpleAbsImpl:mS,addImpl:gS,bincountImpl:yS,bincountReduceImpl:xS,ceilImpl:bS,concatImpl:wS,equalImpl:vS,expImpl:$S,expm1Impl:SS,floorImpl:TS,gatherNdImpl:CS,gatherV2Impl:NS,greaterImpl:ES,greaterEqualImpl:IS,lessImpl:kS,lessEqualImpl:RS,linSpaceImpl:_S,logImpl:AS,maxImpl:OS,maximumImpl:FS,minimumImpl:DS,multiplyImpl:sm,negImpl:PS,notEqualImpl:LS,prodImpl:VS,rangeImpl:MS,rsqrtImpl:US,scatterImpl:WS,sigmoidImpl:zS,sliceImpl:GS,sparseFillEmptyRowsImpl:HS,sparseReshapeImpl:jS,sparseSegmentReductionImpl:KS,sqrtImpl:XS,squaredDifferenceImpl:qS,stridedSliceImpl:YS,stringNGramsImpl:ZS,stringSplitImpl:eT,stringToHashBucketFastImpl:tT,subImpl:nT,tileImpl:rT,topKImpl:sT,transposeImpl:BS,uniqueImpl:oT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:aT,bincountImpl:im,bincountReduceImpl:uT,ceilImpl:lT,concatImpl:cT,equalImpl:hT,expImpl:pT,expm1Impl:dT,floorImpl:fT,gatherNdImpl:mT,gatherV2Impl:gT,greaterImpl:yT,greaterEqualImpl:xT,lessImpl:bT,lessEqualImpl:wT,linSpaceImpl:vT,logImpl:$T,maxImpl:ST,maximumImpl:TT,minimumImpl:CT,multiplyImpl:NT,negImpl:ET,notEqualImpl:IT,prodImpl:kT,rangeImpl:RT,rsqrtImpl:_T,scatterImpl:AT,sigmoidImpl:OT,simpleAbsImpl:am,sliceImpl:FT,sparseFillEmptyRowsImpl:DT,sparseReshapeImpl:PT,sparseSegmentReductionImpl:um,sqrtImpl:LT,stridedSliceImpl:BT,stringNGramsImpl:VT,stringSplitImpl:MT,stringToHashBucketFastImpl:UT,subImpl:WT,tileImpl:zT,topKImpl:GT,transposeImpl:Ma,uniqueImpl:HT}=iT;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lm(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function lt(n,e){return e===1?[n]:lm(n,e)}function jT(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KT{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=mt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=lt("rc",this.rank),r=Ae(this.rank),s=this.getOutOfBoundsCondition(t),o=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;t.push(o)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cm{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2===1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${XT(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Ba():La(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function XT(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?i$(["r","c","d"],"inputShape"):nr(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qT{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,r){const s=qu(t,r),o=Yu(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=Xu(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[o].shift();return this.usedTextures[o].push(u),u}let a;return s===Je.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===Je.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===Je.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===Je.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===Je.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const o=qu(r,s),i=Yu(t,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=Xu(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=L().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function YT(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function Xu(n,e,t,r,s){const o=QT(e,r);let i;if(s){const[u,l]=Lr(n[0],n[1]);i=u*l}else{const[u,l]=$s(n[0],n[1]);i=u*l}const a=YT(t,o);return i*a}function QT(n,e){switch(n){case Je.PACKED_2X2_FLOAT32:return nm(e);case Je.PACKED_2X2_FLOAT16:return rm(e);case Je.UNPACKED_FLOAT32:return Jf(e);case Je.UNPACKED_FLOAT16:return em(e);case Je.PACKED_4X1_UNSIGNED_BYTE:return tm(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function ZT(n){return L().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Je.PACKED_2X2_FLOAT32:Je.UNPACKED_FLOAT32:n?Je.PACKED_2X2_FLOAT16:Je.UNPACKED_FLOAT16}function qu(n,e){if(n===Tt.UPLOAD)return Je.PACKED_2X2_FLOAT32;if(n===Tt.RENDER||n==null)return ZT(e);if(n===Tt.DOWNLOAD||n===Tt.PIXELS)return Je.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function Yu(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const zt="if (isnan(x)) return x;",JT="return x;",Qu="return abs(x);",eC="return (x >= 0.0) ? x : (exp(x) - 1.0);",tC=zt+`
  return (x < 0.0) ? 0.0 : x;
`,nC=zt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,hr="return x;",rC="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sC="return x;",oC=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,iC=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,aC=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uC="return 1.0 / (1.0 + exp(-1.0 * x));";class zn{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length);const t=e.length,r=lt("rc",t),s=Ae(t),o=jT(t,r),i=r.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cC=uf,hC=1e-7,pC=1e-4,Ms={};function dC(n){return n in Ms||(Ms[n]={}),Ms[n]}const fC=L().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),mC=600;function gC(){return L().global.screen==null?1024:L().global.screen.height*L().global.screen.width*window.devicePixelRatio*mC/1024/1024}class So extends Jl{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!L().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Zo)t=e;else{const r=Yt(L().getNumber("WEBGL_VERSION"),e);t=new Zo(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Yt(L().getNumber("WEBGL_VERSION"));t=new Zo(r),this.binaryCache=dC(L().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new qT(this.gpgpu),this.numMBBeforeWarning=gC(),this.texData=new Dg(this,Bn())}nextDataId(){return So.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,r){if((L().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||L().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:Tt.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,o){if(L().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:Tt.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:i,shape:a,isPacked:u}=t;if(i!=null){let p;u?p=new zn(a,hr):p=new cn(a,hr);const d=this.runWebGLProgram(p,[{dataId:e,shape:a,dtype:s}],s),f=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),f}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const l=this.activeTimers!=null;let c;l&&(c=jt());let h;if(s==="complex64"){const p=this.readSync(o.real.dataId),d=this.readSync(o.imag.dataId);h=Bi(p,d)}else h=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=jt()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(g=>f.push(g))}const t=this.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:u}=t;if(o!=null){let f;u?f=new zn(s,hr):f=new cn(s,hr);const g=this.runWebGLProgram(f,[{dataId:e,shape:s,dtype:i}],i),y=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(L().getBool("DEBUG")&&!L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&L().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&L().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const f=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...Ps(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),g=f[0],y=f[1];h=Bi(g,y)}else if(l==null)h=this.getValuesFromTexture(e);else{const f=j(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){const f=this.gpgpu.gl;Q(f,()=>f.deleteBuffer(l))}const p=this.convertAndCacheOnCPU(e,h),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(f=>f(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Bn().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:o,slice:i,dtype:a,isPacked:u,texture:l}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let d;u?d=new zn(o,hr):d=new cn(o,hr);const f=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:a}],a),g=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),g}if(l==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=Bn().makeTensorFromTensorInfo(c),p=this.texData.get(c.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Cr(s));return Ge(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ge(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!O2(r))throw L().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),o=j(t);if(L().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),d=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...Ps(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),f}const i=L().getBool("WEBGL_PACK")&&s===!0,a=i?qo(t):t,u=i?new q$(a):new X$(a),l=this.runWebGLProgram(u,[{shape:a,dtype:r,dataId:e}],"float32"),c=this.texData.get(l.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),h}timerAvailable(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=$r(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=$r(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);a.kernelMs=Pg(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:jt(),endMs:null}}endTimer(e){return L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=jt(),e)}async getQueryTime(e){if(L().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:o,isPacked:i,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,o,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=fC){return L().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&j(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Xt("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return cC(e.shape,t)}packedUnaryOp(e,t,r){const s=new zn(e.shape,t),o=this.compileAndRun(s,[e],r);return Bn().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=am(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(L().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Qu,e.dtype);const t=new cn(e.shape,Qu),r=this.compileAndRun(t,[e]);return Bn().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&uo(r[0])){const o=r.map(i=>Hn(i));s=this.write(o,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return Bn().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new lC(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new KT(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[Ir(e.shape),...kr(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Ir(t),...kr(t)],i=new cm(o,r),a=!0,u=[r],l=this.runWebGLProgram(i,[s],e.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:o,dtype:i}=r;if(t!=null){const p=j(o),d=t[0]*t[1]*4;I(p<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=qo(o);let u;s?u=new K$(a):u=new j$(a);const l=!0,c=[t!=null?t:Ps(a)],h=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:e}],i,c,l,t);return{dtype:i,shape:o,dataId:h.dataId}}runWebGLProgram(e,t,r,s,o=!1,i){const a=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(a.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===ps.DENSE){const w=i!=null?i:Ps(e.outputShape);u.texShape=w.map($=>$*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),j(a.shape)===0)return u.values=Cn(a.dtype,0),a;const l=[],c=t.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let $=this.texData.get(w.dataId);if($.texture==null){if(!e.packedInputs&&j(w.shape)<=L().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:$.values};e.packedInputs&&($.isPacked=!0,$.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!$.isPacked!=!!e.packedInputs)w=$.isPacked?this.unpackTensor(w):this.packTensor(w),l.push(w),$=this.texData.get(w.dataId);else if($.isPacked&&!to($.shape,w.shape)){const S=w,T=w.shape;w.shape=$.shape,w=this.packedReshape(w,T),l.push(w),$=this.texData.get(w.dataId),S.shape=T}return{shape:w.shape,texData:$,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:u,isUniform:!1},p=H$(e,c,h),d=this.getAndSaveBinary(p,()=>z$(this.gpgpu,e,c,h)),f=this.activeTimers!=null;let g;f&&(g=this.startTimer()),L().get("ENGINE_COMPILE_ONLY")||G$(this.gpgpu,d,c,h,s),l.forEach(w=>this.disposeIntermediateTensorInfo(w)),f&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=L().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const w=jt();w-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!L().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const w=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),w}return a}compileAndRun(e,t,r,s,o=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(L().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ie(()=>{if(!L().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=L().getBool("DEBUG");L().set("DEBUG",!1);const t=this.abs(de(1e-8)).dataSync()[0];if(L().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?hC:pC}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:o,texture:i,usage:a,isPacked:u}=t;if(i!=null)return;const l=this.activeTimers!=null;let c;l&&(c=jt());let h=t.texShape;if(h==null&&(h=Q2(r,u),t.texShape=h),o!=null){const p=qo(r);let d,f=h[1],g=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!y)&&([f,g]=Lr(h[0],h[1])),u?d=new Q$(p,y):d=new Y$(p,y);const w=y?[g,f]:h,$=this.makeTensorInfo(w,s),S=this.texData.get($.dataId);y?S.usage=Tt.PIXELS:S.usage=Tt.UPLOAD,S.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture($.dataId),f,g,o);const T=[[g,f]],N=!0,k=this.runWebGLProgram(d,[$],s,T,N),R=this.texData.get(k.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,L().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo($),l&&(this.uploadWaitMs+=jt()-c)}else{const p=this.acquireTexture(h,a,s,u);t.texture=p}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return this.releaseGPUData(e),t!=null&&(r.values=yC(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*pi(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(o){throw o}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await d2(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Kf(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:r,infLoc:s,nanLoc:o,inShapesLocations:i,inTexShapesLocations:a,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:c}=Zf(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=o,e.inShapesLocations=i,e.inTexShapesLocations=a,e.outShapeLocation=u,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}}So.nextDataId=0;function yC(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Qp()&&Nx("webgl",()=>new So,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hm=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Rr{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=Se(t,r),this.enableShapeUniforms=mt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const To=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class Cs{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Se(t,r);const o=this.outputShape.length;this.enableShapeUniforms=mt(o);let i="";if(s)if(o===0||j(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Ae(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=lt("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wt(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const xC={kernelName:ca,backendName:"webgl",kernelFunc:wt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function On(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,o=t.makeTensorInfo(r.shape,"complex64"),i=t.texData.get(o.dataId),a=wt({inputs:{x:r},backend:t}),u=wt({inputs:{x:s},backend:t});return i.complexTensorInfos={real:a,imag:u},o}const bC={kernelName:Ic,backendName:"webgl",kernelFunc:On};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pm="return (a < 0.) ? b * a : a;",dm=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function wC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:o}=r,i=t.makeTensorInfo([],"float32",Ar(o,"float32")),a=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cs(dm,s.shape,i.shape):new Rr(pm,s.shape,i.shape),u=t.runWebGLProgram(a,[s,i],"float32");return t.disposeIntermediateTensorInfo(i),u}const vC={kernelName:dh,backendName:"webgl",kernelFunc:wC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fm="return (a < 0.) ? b * a : a;",mm=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $C(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,o=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cs(mm,r.shape,s.shape):new Rr(fm,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],"float32")}const SC={kernelName:Hh,backendName:"webgl",kernelFunc:$C};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wr="if (isnan(x)) return x;",TC=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,CC=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function ge({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,u=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){const h=a.texData.get(i.dataId),p=t(h.values,u);return a.makeTensorInfo(i.shape,u,p)}const l=L().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return l?c=new zn(i.shape,e):c=new cn(i.shape,n),a.runWebGLProgram(c,[i],u)}}function tt({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:l}=i,c=a;if(r&&u.dtype==="complex64"){const f=c.texData.get(u.dataId),g=c.texData.get(l.dataId),[y,w]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(S=>{const[T,N]=S,k={dataId:T.dataId,dtype:T.dtype,shape:u.shape},R={dataId:N.dataId,dtype:N.dtype,shape:l.shape},F=new Rr(n,u.shape,l.shape);return c.runWebGLProgram(F,[k,R],rn(T.dtype,N.dtype))}),$=On({inputs:{real:y,imag:w},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(w),$}const h=o||rn(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&s!=null){const f=c.texData.get(u.dataId).values,g=c.texData.get(l.dataId).values,y=u.dtype==="string"?hs(f):f,w=u.dtype==="string"?hs(g):g,[$,S]=s(u.shape,l.shape,y,w,h),T=c.makeTensorInfo(S,h),N=c.texData.get(T.dataId);return N.values=$,T}const p=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let d;return p?d=new Cs(e,u.shape,l.shape,t):d=new Rr(n,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function Co(n,e=!1){if(n==="linear")return e?sC:JT;if(n==="relu")return e?iC:tC;if(n==="elu")return e?oC:eC;if(n==="relu6")return e?aC:nC;if(n==="prelu")return e?mm:fm;if(n==="leakyrelu")return e?dm:pm;if(n==="sigmoid")return e?uC:rC;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gm{constructor(e,t,r,s=!1,o=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=mt(this.outputShape.length);const c=s?e[1]:e[2],h=Math.ceil(c/2),p=s?"i * 2, rc.y":"rc.y, i * 2",d=o?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",w="";a&&(u?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,w="result = activation(result);");const $=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let S="rc.x",T="rc.x";e[0]<t[0]?S=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(T=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${h}; i++) {
          int batchA = ${S};
          int batchB = ${T};
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${g[0]});
          result += (${f[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${$}

        ${w}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zu={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Ju{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Se(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const el="return a * b;";function Ua(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,o=rn(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),u=t.texData.get(s.dataId),l=new Ju(Zu.REAL,r.shape,s.shape),c=new Ju(Zu.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],p=t.runWebGLProgram(l,h,"float32"),d=t.runWebGLProgram(c,h,"float32"),f=On({inputs:{real:p,imag:d},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),f}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),u=t.texData.get(s.dataId),[l,c]=NT(r.shape,s.shape,a.values,u.values,o),h=t.makeTensorInfo(c,o),p=t.texData.get(h.dataId);return p.values=l,h}let i;return L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Cs(el,r.shape,s.shape):i=new Rr(el,r.shape,s.shape),t.runWebGLProgram(i,[r,s],o)}const NC={kernelName:Fh,backendName:"webgl",kernelFunc:Ua};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EC(n,e,t){const r=[Ir(n.shape),...kr(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},o=[Ir(e),...kr(e)],i=new cm(o,r),a=!0,u=[r],l=t.runWebGLProgram(i,[s],n.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:o}=r,i=t,a=j(s.shape),u=Lg(o,a),l=j(u);I(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return c.isPacked&&!to(s.shape,u)&&!(c.texture!==null&&to(c.shape,u))?EC(s,u,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}const IC={kernelName:Qh,backendName:"webgl",kernelFunc:X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tl{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];const a=Math.floor(r/4)*4,u=r%4;let l="sumValue += dot(values, ones);";if(t!=null){const h=1/t;l=`sumValue += dot(values * ${ss(h)?h.toPrecision(2):h}, ones);`}let c="";o%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kC{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=e;this.outputShape=[s,i];let a="0.0",u="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",u="min"):t==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const c=Math.floor(r/4)*4,h=r%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";o%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${h===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RC(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=vo(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function sr(n,e,t,r){const s=RC(n.shape);let o=n;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:u,outSize:l}=s[i];let c,h;t==="mean"?c=i===0?new tl({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l},a):new tl({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l}):c=new kC({windowSize:u,inSize:a,batchSize:n.shape[0],outSize:l},t),h=o,o=r.runWebGLProgram(c,[o],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _C{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[t[i]];this.outputShape=r,this.rank=r.length;const s=Ae(this.rank),o=AC(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function AC(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OC{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let c=0;c<r.length;c++)r[c]=e[t[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Ae(this.rank),o=lm("rc",this.rank),i=new Array(this.rank);for(let c=0;c<t.length;c++)i[t[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function No(n,e,t){const r=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OC(n.shape,e):new _C(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FC(n,e,t,r){const s=e,o=n.shape.length,i=et(s,n.shape);let a=i;const u=Mt(a,o),l=u!=null;let c=n;l&&(c=No(n,u,r),a=Ut(a.length,o)),Jt("sum",a,o);const[h,p]=on(c.shape,a);let d=h;t&&(d=Vt(h,i));const f=j(p),y=j(n.shape)/f,w=X({inputs:{x:c},attrs:{shape:[y,f]},backend:r}),$=fa(n.dtype),S=sr(w,$,"sum",r),T=X({inputs:{x:S},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),l&&r.disposeIntermediateTensorInfo(c),T}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eo(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r;return FC(s,o,i,t)}const DC={kernelName:mp,backendName:"webgl",kernelFunc:Eo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:o}=r,i=t,a=s.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=s.shape[o[c]];let l;if(i.shouldExecuteOnCPU([s])){const h=i.texData.get(s.dataId).values,p=Ma(h,s.shape,s.dtype,o,u);l=i.makeTensorInfo(u,s.dtype);const d=i.texData.get(l.dataId);d.values=p}else l=No(s,o,i);return l}const PC={kernelName:Ws,backendName:"webgl",kernelFunc:We};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ym=1e3;function no({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,c=e.shape.length,h=t?n.shape[l-2]:n.shape[l-1],p=r?e.shape[c-1]:e.shape[c-2],d=t?n.shape[l-1]:n.shape[l-2],f=r?e.shape[c-2]:e.shape[c-1],g=n.shape.slice(0,-2),y=e.shape.slice(0,-2),w=j(g),$=j(y),T=Se(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);I(h===p,()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const N=t?[w,h,d]:[w,d,h],k=r?[$,f,p]:[$,p,f],R=X({inputs:{x:n},backend:s,attrs:{shape:N}}),F=X({inputs:{x:e},backend:s,attrs:{shape:k}}),O=[R,F],B=Math.max(w,$),M=t?R.shape[1]:R.shape[2],H=o!=null,G=i!=null,Y=u==="leakyrelu",te=u!=null?Co(u,!0):null,ne=H||G||Y||te!=null;let ue;if((d===1||f===1)&&M>ym&&ne===!1){let Fe=R,$t=F;t&&(Fe=We({inputs:{x:R},backend:s,attrs:{perm:[0,2,1]}}),O.push(Fe)),r&&($t=We({inputs:{x:F},backend:s,attrs:{perm:[0,2,1]}}),O.push($t));const je=f!==1,or=f===1;let Gr=Fe;je&&(Gr=X({inputs:{x:Fe},backend:s,attrs:{shape:[B,M,1]}}),O.push(Gr));const ko=f===1?2:1;let ir=$t;or&&(ir=X({inputs:{x:$t},backend:s,attrs:{shape:[B,1,M]}}),O.push(ir));const Is=Ua({inputs:{a:Gr,b:ir},backend:s});ue=Eo({inputs:{x:Is},backend:s,attrs:{axis:ko,keepDims:!0}}),O.push(Is)}else{const Fe=rn(n.dtype,e.dtype),$t=new gm(N,k,[B,d,f],t,r,H,te,G,Y),je=[R,F];if(o!=null&&je.push(o),G&&je.push(i),Y){const or=s.makeTensorInfo([],"float32",Ar(a,"float32"));je.push(or),O.push(or)}ue=s.runWebGLProgram($t,je,Fe)}const He=X({inputs:{x:ue},backend:s,attrs:{shape:T}});O.push(ue);for(const Fe of O)s.disposeIntermediateTensorInfo(Fe);return He}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LC(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return no({a:s,b:o,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const BC={kernelName:yi,backendName:"webgl",kernelFunc:LC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nl="return abs(x);";function VC(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=t.texData.get(r.dataId),i=am(o.values);return t.makeTensorInfo(r.shape,r.dtype,i)}let s;return L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new zn(r.shape,nl):s=new cn(r.shape,nl),t.runWebGLProgram(s,[r],r.dtype)}const MC={kernelName:ac,backendName:"webgl",kernelFunc:VC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UC=zt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,WC=ge({opSnippet:UC}),zC={kernelName:uc,backendName:"webgl",kernelFunc:WC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GC=zt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,HC=ge({opSnippet:GC}),jC={kernelName:lc,backendName:"webgl",kernelFunc:HC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rl="return a + b;",KC=tt({opSnippet:rl,packedOpSnippet:rl,supportsComplex:!0,cpuKernelImpl:aT}),XC={kernelName:ua,backendName:"webgl",kernelFunc:KC};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qC{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YC{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return wt({inputs:{x:r[0]},backend:t});if(r.length>L().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),l=Hs({inputs:r.slice(0,u),backend:t}),c=Hs({inputs:r.slice(u),backend:t});return Hs({inputs:[l,c],backend:t})}const s=r.map(u=>u.dtype).reduce((u,l)=>rn(u,l)),o=r.map(u=>u.shape),a=L().getBool("WEBGL_PACK")?new YC(r[0].shape,o):new qC(r[0].shape,o);return t.runWebGLProgram(a,r,s)}const QC={kernelName:cc,backendName:"webgl",kernelFunc:Hs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=et(o,s.shape);let l=u;const c=Mt(l,a);let h=s;c!=null&&(h=We({inputs:{x:s},backend:t,attrs:{perm:c}}),l=Ut(l.length,a)),Jt("all",l,a);const[p,d]=on(h.shape,l),f=j(d),g=X({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=sr(g,g.dtype,"all",t);let w;if(i){const $=Vt(p,u);w=X({inputs:{x:y},backend:t,attrs:{shape:$}})}else w=X({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),w}const JC={kernelName:hc,backendName:"webgl",kernelFunc:ZC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=et(o,s.shape);let l=u;const c=Mt(l,a);let h=s;c!=null&&(h=We({inputs:{x:s},backend:t,attrs:{perm:c}}),l=Ut(l.length,a)),Jt("any",l,a);const[p,d]=on(h.shape,l),f=j(d),g=X({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=sr(g,g.dtype,"any",t);let w;if(i){const $=Vt(p,u);w=X({inputs:{x:y},backend:t,attrs:{shape:$}})}else w=X({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),w}const tN={kernelName:pc,backendName:"webgl",kernelFunc:eN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nN{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=t==="max"?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rN{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,l=Ae(u),c=lt("coords",u);let h,p;if(i===1){p=u+1;const F=Ae(p);h=`
        ${F} sourceLocR = ${F}(${c.join()}, 0);
        ++${c[u-1]};
        ${F} sourceLocG = ${F}(${c.join()}, 0);
        ++${c[u-2]};
        ${F} sourceLocA = ${F}(${c.join()}, 0);
        --${c[u-1]};
        ${F} sourceLocB = ${F}(${c.join()}, 0);
        --${c[u-2]};`}else p=u,h=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;const d=["x","y","z","w","u","v"].slice(0,p),f="."+d[p-1],g=d.map(F=>"int "+F),y=lt("sourceLocR",p-1).concat("inIdx.r"),w=lt("sourceLocG",p-1).concat("inIdx.g"),$=lt("sourceLocB",p-1).concat("inIdx.b"),S=lt("sourceLocA",p-1).concat("inIdx.a"),T=r==="max"?"greaterThan":"lessThan",N=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${$.join()}),
                             getBestIndicesAChannel(${S.join()})));`,k=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${$.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,R=s?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${T}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xm(n,e,t,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const i=vo(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},u=new nN(a,t,r==null),l=[e];r!=null&&l.push(r);const c=n.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;const h=xm(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function bm(n,e,t,r=null){const s=r!=null?r.shape:e.shape,o=s[s.length-1],i=vo(o),a=new rN(s,i,t,r==null),u=r==null?[e]:[e,r],l=n.runWebGLProgram(a,u,"int32");if(l.shape.length===e.shape.length){const c=bm(n,e,t,l);return n.disposeIntermediateTensorInfo(l),c}return l}function wm(n,e,t,r){const s=[t];if(Jt("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!L().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=n.texData.get(e.dataId),a=i!==null&&i.isPacked;let u=e;a&&(u=n.unpackTensor(e),o.push(u));const[l,c]=on(u.shape,s),h=j(c),p=X({inputs:{x:u},backend:n,attrs:{shape:[-1,h]}});o.push(p);const d=xm(n,p,r);o.push(d);const f=X({inputs:{x:d},backend:n,attrs:{shape:l}});return o.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return bm(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let i=et(o,s.shape);const a=Mt(i,s.shape.length);let u=s;const l=[];a!=null&&(u=We({inputs:{x:s},backend:t,attrs:{perm:a}}),l.push(u),i=Ut(i.length,u.shape.length)),Jt("argMax",[i[0]],u.shape.length);const c=wm(t,u,i[0],"max");return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const oN={kernelName:dc,backendName:"webgl",kernelFunc:sN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let i=et(o,s.shape);const a=Mt(i,s.shape.length);let u=s;const l=[];a!=null&&(u=We({inputs:{x:s},backend:t,attrs:{perm:a}}),l.push(u),i=Ut(i.length,u.shape.length)),Jt("argMin",[i[0]],u.shape.length);const c=wm(t,u,i[0],"min");return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const aN={kernelName:fc,backendName:"webgl",kernelFunc:iN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uN=zt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,lN=ge({opSnippet:uN}),cN={kernelName:mc,backendName:"webgl",kernelFunc:lN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hN=zt+"return log(x + sqrt(x * x + 1.0));",pN=ge({opSnippet:hN}),dN={kernelName:gc,backendName:"webgl",kernelFunc:pN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fN=zt+`
  return atan(x);
`,mN=ge({opSnippet:fN}),gN={kernelName:yc,backendName:"webgl",kernelFunc:mN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yN=TC+`
  return atan(a, b);
`,xN=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CC+`
  return result;
`,bN=tt({opSnippet:yN,packedOpSnippet:xN}),wN={kernelName:bc,backendName:"webgl",kernelFunc:bN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vN=zt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,$N=ge({opSnippet:vN}),SN={kernelName:xc,backendName:"webgl",kernelFunc:$N};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ds{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,w=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let $="0.0";if(g||($="-1.0 / 1e-20"),r){const F=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${F} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?y:w:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let T=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(T="avgValue / count");const N=Math.floor(i/4)*4,k=i%4,R=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${N};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${T});
      }
    `}}class Wa{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,g=e.effectiveFilterWidth,y=e.padInfo.front,w=e.padInfo.top,$=e.padInfo.left;this.outputShape=e.outShape;const S=t==="avg";let T="0.0";if(S||(T="-1.0 / 1e-20"),r){const B=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${y}, ${w}, ${$});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${B} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / count");const R=Math.floor(i/4)*4,F=i%4,O=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${y}, ${w}, ${$});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${O}
            }

            int xC = xCCorner + ${R};
            if (${F===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${F===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${O}
            } else if (${F===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${O}
            }
          }
          setOutput(${k});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Ss(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r,l=1;I(Nt(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Fr(s.shape,o,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&ze(c.inShape,c.outShape))return wt({inputs:{x:s},backend:t});const h=new ds(c,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}const CN={kernelName:wc,backendName:"webgl",kernelFunc:TN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=r,c=[1,1,1],h=bs(s.shape,o,i,c,a,u,l),p=new Wa(h,"avg",!1);return t.runWebGLProgram(p,[s],"float32")}const EN={kernelName:vc,backendName:"webgl",kernelFunc:NN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IN{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.top,h=l-1-e.padInfo.left,p=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class kN{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=h-1-e.padInfo.front,g=p-1-e.padInfo.top,y=d-1-e.padInfo.left,w=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${g}, ${y});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RN(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=r,h=[1,1,1],p=bs(i.shape,a,u,h,l,c),d=new kN(p);return t.runWebGLProgram(d,[s],i.dtype)}const _N={kernelName:Qg,backendName:"webgl",kernelFunc:RN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AN(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o;Ss([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=r,c=Fr(i.shape,a,u,1,l),h=new IN(c);return t.runWebGLProgram(h,[s],i.dtype)}const ON={kernelName:Yg,backendName:"webgl",kernelFunc:AN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FN(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return no({a:s,b:o,transposeA:i,transposeB:a,backend:t})}const DN={kernelName:$c,backendName:"webgl",kernelFunc:FN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PN{constructor(e,t,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Se(e,t),Se(e,r);let a="0.0";s!=null&&(Se(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";o!=null&&(Se(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LN{constructor(e,t,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Se(e,t),Se(e,r);let a="vec4(0.0)";s!=null&&(Se(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(Se(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BN=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=n;I(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);const l=[r,s,o];let c=null;i!=null&&(c=i.shape,l.push(i));let h=null;a!=null&&(h=a.shape,l.push(a));const p=L().getBool("WEBGL_PACK_NORMALIZATION")?new LN(r.shape,s.shape,o.shape,c,h,u):new PN(r.shape,s.shape,o.shape,c,h,u);return e.runWebGLProgram(p,l,l[0].dtype)},VN={kernelName:oh,backendName:"webgl",kernelFunc:BN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MN{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ae(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=UN(this.rank);let s;const o=e.map((i,a)=>`sourceLoc.${Ui[a]} = start[${a}] + coords.${Ui[a]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const Ui=["x","y","z","w","u","v"];function UN(n){if(n===1)return"sourceLoc";if(n<=6)return Ui.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WN{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Ae(this.rank),r=lt("coords",this.rank),s=lt("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(n,e,t,r){const s=r.texData.get(n.dataId),o=r.makeTensorInfo(t,n.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=t,i.dtype=n.dtype;let a=wa(e,rt(n.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),o}function zr(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,size:i}=r,[a,u]=Td(s,o,i);if(fd(s,a,u),j(u)===0)return t.makeTensorInfo(u,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.texData.get(s.dataId),p=FT(h.values,a,u,s.shape,s.dtype);return t.makeTensorInfo(u,s.dtype,p)}const{isPacked:l}=t.texData.get(s.dataId),c=ba(s.shape,a,u);if(l||!c){const h=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WN(u):new MN(u),p=[a];return t.runWebGLProgram(h,[s],s.dtype,p)}return t.uploadToGPU(s.dataId),zN(s,a,u,t)}const GN={kernelName:up,backendName:"webgl",kernelFunc:zr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HN=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:i}=r;I(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce(($,S)=>$*S),u=Oa(s.shape,o,a),l=Fa(u.length,o.length),c=Da(s.shape,o,a),h=gf(i,o.length),p=yf(c,i,o.length),d=[],f=X({inputs:{x:s},backend:t,attrs:{shape:u}}),g=We({inputs:{x:f},backend:t,attrs:{perm:l}}),y=X({inputs:{x:g},backend:t,attrs:{shape:c}}),w=zr({inputs:{x:y},backend:t,attrs:{begin:h,size:p}});return d.push(f),d.push(g),d.push(y),d.forEach($=>t.disposeIntermediateTensorInfo($)),w},jN={kernelName:Sc,backendName:"webgl",kernelFunc:HN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:i}=r,a=t.readSync(s.dataId),u=t.readSync(o.dataId),l=im(a,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,l)}const XN={kernelName:Tc,backendName:"webgl",kernelFunc:KN};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qN(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,o=t.readSync(r.dataId),i=t.readSync(s.dataId),a=Se(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const YN={kernelName:Cc,backendName:"webgl",kernelFunc:qN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QN="return float(a != b);",vm=tt({opSnippet:QN,cpuKernelImpl:IT,dtype:"bool"}),ZN={kernelName:Ph,backendName:"webgl",kernelFunc:vm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ns(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return wt({inputs:{x:s.complexTensorInfos.real},backend:t})}const JN={kernelName:Xh,backendName:"webgl",kernelFunc:Ns};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eE="return float(int(x));";function tE(n,e){const t=new cn(n.shape,eE),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wi(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return wt({inputs:{x:s},backend:t});const i=kn(s.shape),a=Wi({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),u=On({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),u}if(s.dtype==="complex64"){const i=Ns({inputs:{input:s},backend:t}),a=Wi({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(i),a}if(!Mg(s.dtype,o)){const i=wt({inputs:{x:s},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(o==="int32")return tE(s,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",Cn("bool",1)),u=vm({inputs:{a:s,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const nE={kernelName:la,backendName:"webgl",kernelFunc:Wi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sl="return ceil(x);",rE=ge({opSnippet:sl,packedOpSnippet:sl,cpuKernelImpl:lT}),sE={kernelName:Nc,backendName:"webgl",kernelFunc:rE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oE{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iE{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;L().getBool("WEBGL_PACK_CLIP")?a=new iE(s.shape):a=new oE(s.shape);const u=[[o],[i]];return t.runWebGLProgram(a,[s],s.dtype,u)}const uE={kernelName:Ec,backendName:"webgl",kernelFunc:aE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lE{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function cE(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),o=new lE(r.shape),i=[ol(r,s.complexTensorInfos.real),ol(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}const hE={kernelName:kc,backendName:"webgl",kernelFunc:cE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pE{constructor(e){this.outputShape=[],this.outputShape=Qn(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const a=t[i-1];r.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const s=t.length,o=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dE{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Qn(e,t);const r=this.outputShape,s=r.length,o=Ae(s),i=lt("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((g,y)=>`T${y}`);const u=new Array(e.length-1);u[0]=e[0][t];for(let g=1;g<u.length;g++)u[g]=u[g-1]+e[g][t];const l=a[t],c=a.slice(-2),h=a.join();let p=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let g=1;g<u.length;g++){const y=u[g-1];p+=`
        if (${l} < ${u[g]}  && ${l} >= ${u[g-1]}) {
          return getChannel(
            getT${g}(${Us(a,l,y)}),
            vec2(${Us(c,l,y)}));
        }`}const d=u.length,f=u[u.length-1];p+=`
        return getChannel(
          getT${d}(${Us(a,l,f)}),
          vec2(${Us(c,l,f)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${p}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Us(n,e,t){const r=n.indexOf(e);return n.map((o,i)=>i===r?`${o} - ${t}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Io(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return wt({inputs:{x:s.complexTensorInfos.imag},backend:t})}const fE={kernelName:hh,backendName:"webgl",kernelFunc:Io};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr(n,e,t){const r=n[0].dtype;if(r==="complex64"){const c=n.map(g=>Ns({inputs:{input:g},backend:t})),h=n.map(g=>Io({inputs:{input:g},backend:t})),p=gr(c,e,t),d=gr(h,e,t),f=On({inputs:{real:p,imag:d},backend:t});return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),h.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),f}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const c=n.map(w=>{const $=j(w.shape.slice(e));return X({inputs:{x:w},backend:t,attrs:{shape:[-1,$]}})}),h=c.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),p=Qn(c.map(w=>w.shape),1),d=c[0].shape[0]===1,f=cT(h,p,r,d),g=Qn(n.map(w=>w.shape),e),y=t.makeTensorInfo(g,r,f);return c.forEach(w=>t.disposeIntermediateTensorInfo(w)),y}if(n.length>L().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(n.length/2),h=gr(n.slice(0,c),e,t),p=gr(n.slice(c),e,t),d=gr([h,p],e,t);return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),d}if(L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const c=new dE(n.map(h=>h.shape),e);return t.runWebGLProgram(c,n,r)}const{tensors2D:o,outShape:i}=mE(n,e,t),a=new pE(o.map(c=>c.shape)),u=t.runWebGLProgram(a,o,r);o.forEach(c=>t.disposeIntermediateTensorInfo(c));const l=X({inputs:{x:u},attrs:{shape:i},backend:t});return t.disposeIntermediateTensorInfo(u),l}function mE(n,e,t){const r=Qn(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>X({inputs:{x:o},attrs:{shape:[-1,j(o.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $m(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,o=et(s,e[0].shape)[0],i=Qn(e.map(l=>l.shape),o);if(j(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);const a=e.filter(l=>j(l.shape)>0);if(a.length===1)return wt({inputs:{x:a[0]},backend:t});const u=a.map(l=>l.shape);return ff(u,o),gr(a,o,t)}const gE={kernelName:Rc,backendName:"webgl",kernelFunc:$m};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sm{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,y=e.dataFormat==="channelsLast",w=y?1:2,$=y?2:3,S=y?3:1;let T="",N="";r&&(s?T=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?T=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:T=`
          float activation(float x) {
            ${r}
          }
        `,N="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${T}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${$}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${N}
        setOutput(result);
      }
    `}}class yE{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,p=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xE{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=mt(this.outputShape.length);const{dataFormat:r}=t,s=ht(),o=r==="channelsLast",i=o?0:1,a=o?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let l="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)l+=`
          blockIndex = rc.y + ${h};
          pos = rc.x + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tm({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=n.shape,l=r.texData.get(n.dataId),c=t.inChannels,h=u[0]*u[1]*u[2],p=t.outChannels,d=t.dataFormat==="channelsLast",f=!1,g=!1;let y;const w=[];if(o!=null&&!d&&o.shape.length===3){const T=We({inputs:{x:o},backend:r,attrs:{perm:[1,2,0]}});w.push(T),o=T}if(!((h===1||p===1)&&c>ym)&&l.isPacked&&d&&l.texture!=null&&u[2]%2!==0&&ze(l.shape.slice(-3),u.slice(-3))){const T=u[0]*u[1]*(u[2]+1),N={dataId:n.dataId,shape:[1,T,t.inChannels],dtype:n.dtype},k=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,I(to(l.shape,N.shape),()=>`packed reshape ${l.shape} to ${N.shape} isn't free`);const R=X({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});w.push(R);const F=no({a:N,b:R,backend:r,transposeA:f,transposeB:g,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),O=r.texData.get(F.dataId);I(O.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=k,O.shape=t.outShape,y=wt({inputs:{x:F},backend:r}),y.shape=t.outShape,w.push(F)}else{const T=d?n:We({inputs:{x:n},backend:r,attrs:{perm:[0,2,3,1]}}),N=T.shape,k=N[0]*N[1]*N[2],R=X({inputs:{x:T},backend:r,attrs:{shape:[1,k,t.inChannels]}}),F=X({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),O=no({a:R,b:F,transposeA:f,transposeB:g,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),B=[t.batchSize,t.outHeight,t.outWidth,t.outChannels],M=X({inputs:{x:O},backend:r,attrs:{shape:B}});y=d?M:We({inputs:{x:M},backend:r,attrs:{perm:[0,3,1,2]}}),d||(w.push(T),w.push(M)),w.push(R),w.push(F),w.push(O)}for(const T of w)r.disposeIntermediateTensorInfo(T);return y}function Cm({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:p,dataFormat:d}=t,f=d==="channelsLast",g=u*l*c,y=p*h,w=[g,y],$=!0,S=!1,T=[];if(o!=null&&!f&&o.shape.length===3){const je=We({inputs:{x:o},backend:r,attrs:{perm:[1,2,0]}});T.push(je),o=je}const N=X({inputs:{x:n},backend:r,attrs:{shape:n.shape.slice(1)}}),k=X({inputs:{x:e},backend:r,attrs:{shape:[1,g,j(e.shape)/g]}});T.push(N),T.push(k);const R=new xE(w,t),F=[N.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],O=r.runWebGLProgram(R,[N],"float32",F),B=X({inputs:{x:O},backend:r,attrs:{shape:[1,w[0],w[1]]}});T.push(O),T.push(B);const M=s!=null,H=o!=null,G=a==="leakyrelu",Y=a?Co(a,!0):null,te=new gm(B.shape,k.shape,[1,y,t.outChannels],$,S,M,Y,H,G),ne=[B,k];if(s&&ne.push(s),H&&ne.push(o),G){const je=r.makeTensorInfo([],"float32",Ar(i,"float32"));ne.push(je),T.push(je)}const ue=r.runWebGLProgram(te,ne,"float32"),He=[1,p,h,t.outChannels],Fe=X({inputs:{x:ue},backend:r,attrs:{shape:He}}),$t=f?Fe:We({inputs:{x:Fe},backend:r,attrs:{perm:[0,3,1,2]}});f||T.push(Fe),T.push(ue);for(const je of T)r.disposeIntermediateTensorInfo(je);return $t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=Dr(u),p=Ct(s.shape,o.shape,i,l,a,c,!1,h);let d;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))d=Tm({x:s,filter:o,convInfo:p,backend:t});else if(L().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)d=Cm({x:s,filter:o,convInfo:p,backend:t});else{const g=new Sm(p);d=t.runWebGLProgram(g,[s,o],"float32")}const f=X({inputs:{x:d},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(d),f}const wE={kernelName:_c,backendName:"webgl",kernelFunc:bE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vE{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $E{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,u=r-1-e.padInfo.left,l=i?1:2,c=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class SE{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class TE{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=t-1-e.padInfo.front,l=r-1-e.padInfo.top,c=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=Dr(u),p=Ct(s.shape,c,i,1,a,l,!1,h),d=new vE(p);return t.runWebGLProgram(d,[s,o],"float32")}const NE={kernelName:Ac,backendName:"webgl",kernelFunc:CE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=Dr(l),p=Ct(i,o.shape,a,1,u,c,!1,h),d=new $E(p);return t.runWebGLProgram(d,[s,o],"float32")}const IE={kernelName:Oc,backendName:"webgl",kernelFunc:EE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u}=r,l=ws(s.shape,o.shape,i,u,a),c=new yE(l);return t.runWebGLProgram(c,[s,o],"float32")}const RE={kernelName:Fc,backendName:"webgl",kernelFunc:kE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _E(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:u}=r,l=ws(s.shape,u,i,1,a),c=new SE(l);return t.runWebGLProgram(c,[s,o],"float32")}const AE={kernelName:Zg,backendName:"webgl",kernelFunc:_E};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OE(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{pad:i,strides:a,inputShape:u}=r,l=ws(u,o.shape,a,1,i),c=new TE(l);return t.runWebGLProgram(c,[s,o],"float32")}const FE={kernelName:Jg,backendName:"webgl",kernelFunc:OE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DE=Wr+`
  return cos(x);
`,PE=ge({opSnippet:DE}),LE={kernelName:Dc,backendName:"webgl",kernelFunc:PE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BE=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,VE=ge({opSnippet:BE}),ME={kernelName:Pc,backendName:"webgl",kernelFunc:VE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UE{constructor(e,t,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,u,l]=e,[c]=t,[h,p]=r;this.outputShape=[c,h,p,l];const d=s==="bilinear"?1:0,[f,g]=[`${a-1}.0`,`${u-1}.0`],[y,w,$]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[S,T,N]=p>1?[`${(u-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${T};

        float in_y = ${$};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WE=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=r,c=new UE(s.shape,o.shape,a,u,l);return t.runWebGLProgram(c,[s,o,i],"float32")},zE={kernelName:Vc,backendName:"webgl",kernelFunc:WE};var fs;(function(n){n.Prod="*",n.Sum="+"})(fs||(fs={}));class il{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===fs.Prod?"1.0":"0.0",a=r?i:`getX(${al(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",c="";r?(l=s?`end != ${u-1}`:"end != 0",c=s?"end + 1":"end - 1"):(l=s?`end + pow2 < ${u}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ae(o)} coords = getOutputCoords();
        int end = ${ul(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${ul(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${al(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function al(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function ul(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nm(n,e,t,r,s,o){const i=e.shape.length,a=Mt([r],i);let u=e;a!=null&&(u=We({inputs:{x:e},backend:t,attrs:{perm:a}}));const l=Ut(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=u.shape[l];let h=wt({inputs:{x:u},backend:t});for(let p=0;p<=Math.ceil(Math.log2(c))-1;p++){const d=new il(n,u.shape,!1,o),f=[[p]],g=h;h=t.runWebGLProgram(d,[h],h.dtype,f),t.disposeIntermediateTensorInfo(g)}if(s){const p=new il(n,u.shape,s,o),d=h;h=t.runWebGLProgram(p,[h],h.dtype),t.disposeIntermediateTensorInfo(d)}if(a!=null){const p=Ca(a),d=We({inputs:{x:h},backend:t,attrs:{perm:p}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(u),d}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return Nm(fs.Prod,s,t,o,i,a)}const HE={kernelName:Lc,backendName:"webgl",kernelFunc:GE};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return Nm(fs.Sum,s,t,o,i,a)}const KE={kernelName:Bc,backendName:"webgl",kernelFunc:jE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r;if(s.shape.length===1){const u=t.readSync(s.dataId),l=t.readSync(o.dataId),c=im(u,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}else if(s.shape.length===2){const u=t.bufferSync(s),l=t.bufferSync(o),c=uT(u,l,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const qE={kernelName:Mc,backendName:"webgl",kernelFunc:XE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YE{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],l=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],h=u*o,p=l*o,d=c/(o*o),f=i==="NHWC"?[a,h,p,d]:[a,d,h,p],g=new YE(f,o,i);return t.runWebGLProgram(g,[s],s.dtype)}const ZE={kernelName:Uc,backendName:"webgl",kernelFunc:QE};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Em{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=mt(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels;let l="",c="";r&&(s?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:l=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Im{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=mt(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,p=h;let d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<h;w++)d+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;d+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let w=0;w<h;w++)d+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(p+1)/2;w++){const $=w*2;if(d+=`
          xC = xCCorner + ${$*l};
          `,u===1){if($<h&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }
              `,l===1&&$>0?d+=`
                xC${$} = vec4(xTexelC${$-2}.zw, xTexelC${$}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${$} = vec4(previous.zw, xTexelC${$}.xy);
                  } else {
                    xC${$} = vec4(0.0, 0.0, xTexelC${$}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xC${$} = xTexelC${$};
                `,$+1<h)){const S=a%2===0?ec(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                    xTexelC${$+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${$+1}.zw = vec2(0.0);
                    }
                    xTexelC${$+1}Ready = 1;
                  }
                  `,l>1&&(d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                      xTexelC${$} = getX(batch, xR, xCOffset, d1);
                      xTexelC${$}Ready = 1;
                    }
                    `),d+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.xy);
                  `):S===1?d+=`
                    xC${$+1} = xTexelC${$};
                    `:d+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                      xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${$+1}.zw = vec2(0.0);
                      }
                      xTexelC${$+1}Ready = 1;
                    }

                    xC${$+1} = xTexelC${$+1};
                    `}}else $<h&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.0);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
              `,$+1<h&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${$+1} = vec4(xTexelC${$+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${$}Ready == 0) {
                  xTexelC${$} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${$}.zw = vec2(0.0);
                  }
                  xTexelC${$}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${$+1}Ready == 0) {
                  xTexelC${$+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${$+1}.zw = vec2(0.);
                  }
                  xTexelC${$+1}Ready = 1;
                }

                xC${$} = vec4(
                  xTexelC${$}.xy, xTexelC${$+1}.xy);
              `,$+1<h&&(d+=`
                  xC${$+1} = vec4(xTexelC${$}.zw, xTexelC${$+1}.zw);
                `)));$<h&&(d+=`
            wTexel = getW(r, ${$}, d1, q);
            dotProd += xC${$} * vec4(wTexel.xz, wTexel.xz);
          `,$+1<h&&(d+=`
              wTexel = getW(r, ${$+1}, d1, q);
              dotProd += xC${$+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let f="",g="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=r;let c=u;c==null&&(c=[1,1]),I(Nt(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=Ct(s.shape,o.shape,i,c,a,l,!0);let p;L().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?p=new Im(h):p=new Em(h);const d=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(p,[s,o],"float32",d)}const eI={kernelName:Wc,backendName:"webgl",kernelFunc:JE};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tI{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nI{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.top,a=r-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=r,h=Ct(s.shape,c,i,a,u,l,!0),p=new tI(h);return t.runWebGLProgram(p,[s,o],"float32")}const sI={kernelName:zc,backendName:"webgl",kernelFunc:rI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=r,h=Ct(c,o.shape,i,a,u,l,!0),p=new nI(h);return t.runWebGLProgram(p,[s,o],"float32")}const iI={kernelName:Gc,backendName:"webgl",kernelFunc:oI};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aI{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],o=j(r.shape),i=X({inputs:{x:r},backend:t,attrs:{shape:[o]}}),a=new aI(o),u=t.runWebGLProgram(a,[i],i.dtype),l=X({inputs:{x:u},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}const lI={kernelName:ey,backendName:"webgl",kernelFunc:uI};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cI{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=e,{top:h,left:p}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${h}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u}=r,l=Id(s.shape,o.shape,i,a,"NHWC",u);let c;const h=new cI(l);c=t.runWebGLProgram(h,[s,o],"float32");const p=X({inputs:{x:c},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(c),p}const pI={kernelName:Hc,backendName:"webgl",kernelFunc:hI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:u}=Nf(s,o.length);If(i.length,u,o);const{path:l,steps:c}=kf(a,u),h=c.length;let p=null,d=i.length;const f=[];for(let g=0;g<h;++g){for(const y of c[g]){const{permutationIndices:w,expandDims:$}=Ef(d,u[y]);let S;Rf(w)?S=o[y]:(S=We({inputs:{x:o[y]},backend:t,attrs:{perm:w}}),f.push(S));const T=S.shape.slice();for(let N=0;N<$.length;++N)T.splice($[N],0,1);ze(S.shape,T)||(S=X({inputs:{x:S},backend:t,attrs:{shape:T}}),f.push(S)),p===null?p=S:(p=Ua({inputs:{a:S,b:p},backend:t}),f.push(p))}g<h-1&&(l[g]>=0&&(p=Eo({inputs:{x:p},backend:t,attrs:{axis:l[g]-(i.length-d),keepDims:!1}}),f.push(p)),d--)}for(const g of f)g!==p&&t.disposeIntermediateTensorInfo(g);return p}const fI={kernelName:Kc,backendName:"webgl",kernelFunc:dI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mI="return (x >= 0.0) ? x : (exp(x) - 1.0);",gI=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,yI=ge({opSnippet:mI,packedOpSnippet:gI}),xI={kernelName:Xc,backendName:"webgl",kernelFunc:yI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bI="return (b >= 1.0) ? a : a * (b + 1.0);",wI=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,vI=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,o=L().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Cs(wI,r.shape,s.shape):new Rr(bI,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],r.dtype)},$I={kernelName:ty,backendName:"webgl",kernelFunc:vI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SI=`
  return vec4(equal(a, b));
`,TI="return float(a == b);",CI=tt({opSnippet:TI,packedOpSnippet:SI,dtype:"bool",cpuKernelImpl:hT}),NI={kernelName:Yc,backendName:"webgl",kernelFunc:CI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EI=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${wf};
  float a1 = ${vf};
  float a2 = ${$f};
  float a3 = ${Sf};
  float a4 = ${Tf};
  float a5 = ${Cf};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,II=ge({opSnippet:EI}),kI={kernelName:qc,backendName:"webgl",kernelFunc:II};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RI=Wr+`
  return exp(x);
`,_I=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,km=ge({opSnippet:RI,packedOpSnippet:_I,cpuKernelImpl:pT,dtype:"float32"}),AI={kernelName:Qc,backendName:"webgl",kernelFunc:km};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=s;return s<0&&(I(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),X({inputs:{x:o},backend:r,attrs:{shape:a}})}const OI={kernelName:Zc,backendName:"webgl",kernelFunc:zi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ll="return exp(x) - 1.0;",FI=ge({opSnippet:ll,packedOpSnippet:ll,cpuKernelImpl:dT}),DI={kernelName:Jc,backendName:"webgl",kernelFunc:FI};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cl{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rm(n,e,t){const r=t.texData.get(n.dataId),s=j(n.shape),o=n.shape[n.shape.length-1],i=s/o,a=X({inputs:{x:n},backend:t,attrs:{shape:[i,o]}}),u=a.shape,l=new cl("real",u,e),c=new cl("imag",u,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],p=t.runWebGLProgram(l,h,"float32"),d=t.runWebGLProgram(c,h,"float32"),f=On({inputs:{real:p,imag:d},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d);const g=X({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n){const{inputs:e,backend:t}=n,{input:r}=e;return Rm(r,!1,t)}const LI={kernelName:eh,backendName:"webgl",kernelFunc:PI};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BI{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Es(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:o}=t;if(o=o||lo(s),o==="string"){const i=At(o,j(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new BI(r,s),a=[[s]];return e.runWebGLProgram(i,[],o,a)}}const VI={kernelName:th,backendName:"webgl",kernelFunc:Es};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MI{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UI={kernelName:nh,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new MI(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hl="return floor(x);",WI=ge({opSnippet:hl,packedOpSnippet:hl,cpuKernelImpl:fT}),zI={kernelName:rh,backendName:"webgl",kernelFunc:WI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GI=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,HI=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,jI=tt({opSnippet:GI,packedOpSnippet:HI,dtype:"int32"}),KI={kernelName:sh,backendName:"webgl",kernelFunc:jI};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XI{constructor(e){this.variableNames=["A"];const t=ht(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qI{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ht(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YI={kernelName:gi,backendName:"webgl",kernelFunc:QI};let pr;function QI(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:o}=r,i=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,[u,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],h=[l,u,o];(a||i)&&(pr==null&&(pr=document.createElement("canvas").getContext("2d")),pr.canvas.width=u,pr.canvas.height=l,pr.drawImage(s,0,0,u,l),s=pr.canvas);const p=t.makeTensorInfo(c,"int32");t.texData.get(p.dataId).usage=Tt.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),s);const d=L().getBool("WEBGL_PACK")?new qI(h):new XI(h),f=t.runWebGLProgram(d,[p],"int32");return t.disposeData(p.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZI(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:p,activation:d,leakyreluAlpha:f}=r,g=Dr(c),y=Ct(s.shape,o.shape,u,h,l,p,!1,g);let w;const $=[];if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))w=Tm({x:s,filter:o,convInfo:y,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:f});else if(L().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)w=Cm({x:s,filter:o,convInfo:y,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:f});else{const T=i!=null,N=a!=null,k=d==="leakyrelu",R=d?Co(d,!1):null,F=new Sm(y,T,R,N,k),O=[s,o],B=(M,H)=>{if(H==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const G=X({inputs:{x:M},backend:t,attrs:{shape:[M.shape[0],1,1]}});return $.push(G),G}return M};if(T&&O.push(B(i,c)),N&&O.push(B(a,c)),k){const M=t.makeTensorInfo([],"float32",Ar(f,"float32"));O.push(M),$.push(M)}w=t.runWebGLProgram(F,O,"float32")}const S=X({inputs:{x:w},backend:t,attrs:{shape:y.outShape}});return $.push(w),$.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}const JI={kernelName:xi,backendName:"webgl",kernelFunc:ZI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:p,leakyreluAlpha:d}=r,f=[];let g=c;g==null&&(g=[1,1]),I(Nt(u,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${g}'`);const y=Ct(s.shape,o.shape,u,g,l,h,!0),w=L().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,$=p?Co(p,w):null,S=[s,o],T=i!=null,N=a!=null,k=p==="leakyrelu";if(T&&S.push(i),N&&S.push(a),k){const B=t.makeTensorInfo([],"float32",Ar(d,"float32"));S.push(B),f.push(B)}let R;w?R=new Im(y,T,$,N,k):R=new Em(y,T,$,N,k);const F=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],O=t.runWebGLProgram(R,S,"float32",F);return f.forEach(B=>t.disposeIntermediateTensorInfo(B)),O}const tk={kernelName:bi,backendName:"webgl",kernelFunc:ek};class nk{constructor(e,t,r){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=r;const s=Ae(t.length),o=Ae(r.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${i};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rk(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=j(r.shape),[u,l,c,h]=hd(r,s),p=X({inputs:{x:s},backend:t,attrs:{shape:[l,i]}}),d=X({inputs:{x:r},backend:t,attrs:{shape:[j(r.shape)/c,c]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const w=t.readSync(s.dataId),$=t.bufferSync(r),S=mT(w,$,r.dtype,l,i,c,h,r.shape,a);return t.makeTensorInfo(u,r.dtype,S.values)}const f=new nk(i,h,[l,c]),g=t.runWebGLProgram(f,[d,p],d.dtype),y=X({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),y}const sk={kernelName:ah,backendName:"webgl",kernelFunc:rk};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ok{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Ae(this.rank),s=ik(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function ik(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _m(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,u=et(i,s.shape)[0];if(L().get("DEBUG")){const $=t.readSync(o.dataId),S=s.shape[u];for(let T=0;T<$.length;++T){const N=$[T];I(N<=S-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${S-1}]`)}}const l=Hf(s,o,u,a),c=j(o.shape),h=[],p=X({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=X({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,c/l.batchSize]}});h.push(p),h.push(d);const f=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const $=t.bufferSync(d),S=t.bufferSync(p),T=gT(S,$,f);return h.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.makeTensorInfo(l.outputShape,T.dtype,T.values)}const g=new ok(p.shape,f),y=t.runWebGLProgram(g,[p,d],p.dtype);h.push(y);const w=X({inputs:{x:y},backend:t,attrs:{shape:l.outputShape}});return h.forEach($=>t.disposeIntermediateTensorInfo($)),w}const ak={kernelName:ih,backendName:"webgl",kernelFunc:_m};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uk="return float(a > b);",lk=`
  return vec4(greaterThan(a, b));
`,ck=tt({opSnippet:uk,packedOpSnippet:lk,cpuKernelImpl:yT,dtype:"bool"}),hk={kernelName:uh,backendName:"webgl",kernelFunc:ck};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pk="return float(a >= b);",dk=`
  return vec4(greaterThanEqual(a, b));
`,fk=tt({opSnippet:pk,packedOpSnippet:dk,dtype:"bool",cpuKernelImpl:xT}),mk={kernelName:lh,backendName:"webgl",kernelFunc:fk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){const{inputs:e,backend:t}=n,{input:r}=e;return Rm(r,!0,t)}const yk={kernelName:ch,backendName:"webgl",kernelFunc:gk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xk="return float(!isnan(x) && !isinf(x));",bk=ge({opSnippet:xk,dtype:"bool"}),wk={kernelName:ny,backendName:"webgl",kernelFunc:bk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vk="return float(isinf(x));",$k=ge({opSnippet:vk,dtype:"bool"}),Sk={kernelName:ry,backendName:"webgl",kernelFunc:$k};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tk="return float(isnan(x));",Ck=ge({opSnippet:Tk,dtype:"bool"}),Nk={kernelName:ph,backendName:"webgl",kernelFunc:Ck};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ek="return float(a < b);",Ik=`
  return vec4(lessThan(a, b));
`,kk=tt({opSnippet:Ek,packedOpSnippet:Ik,cpuKernelImpl:bT,dtype:"bool"}),Rk={kernelName:fh,backendName:"webgl",kernelFunc:kk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k="return float(a <= b);",Ak=`
  return vec4(lessThanEqual(a, b));
`,Ok=tt({opSnippet:_k,packedOpSnippet:Ak,cpuKernelImpl:wT,dtype:"bool"}),Fk={kernelName:mh,backendName:"webgl",kernelFunc:Ok};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dk(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:o}=t,i=vT(r,s,o);return e.makeTensorInfo([i.length],"float32",i)}const Pk={kernelName:gh,backendName:"webgl",kernelFunc:Dk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lk=Wr+`
  return x < 0.0 ? 0./0. : log(x);
`,Bk=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Vk=ge({opSnippet:Lk,packedOpSnippet:Bk,cpuKernelImpl:$T}),Mk={kernelName:yh,backendName:"webgl",kernelFunc:Vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uk=Wr+`
  return log(1.0 + x);
`,Wk=ge({opSnippet:Uk}),zk={kernelName:xh,backendName:"webgl",kernelFunc:Wk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gk="return float(a >= 1.0 && b >= 1.0);",Hk=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,jk=tt({opSnippet:Gk,packedOpSnippet:Hk,dtype:"bool"}),Kk={kernelName:bh,backendName:"webgl",kernelFunc:jk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xk="return float(!(x >= 1.0));",qk=ge({opSnippet:Xk}),Yk={kernelName:wh,backendName:"webgl",kernelFunc:qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk="return float(a >= 1.0 || b >= 1.0);",Zk=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Jk=tt({opSnippet:Qk,packedOpSnippet:Zk,dtype:"bool"}),eR={kernelName:vh,backendName:"webgl",kernelFunc:Jk};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tR{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;this.outputShape=e;let u;const l=`float(${r}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${l})`:o===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nR{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;this.outputShape=e;let u;const l=`float(${r}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${l})`:o===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rR=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=r,l=L().getBool("WEBGL_PACK_NORMALIZATION")?new nR(s.shape,o,i,a,u):new tR(s.shape,o,i,a,u);return t.runWebGLProgram(l,[s],s.dtype)},sR={kernelName:$h,backendName:"webgl",kernelFunc:rR};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oR{constructor(e,t,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iR=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=r,h=new oR(s.shape,a,u,l,c);return t.runWebGLProgram(h,[s,o,i],s.dtype)},aR={kernelName:sy,backendName:"webgl",kernelFunc:iR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n,e,t,r){const s=j(e),i=j(n.shape)/s,a=X({inputs:{x:n},attrs:{shape:[i,s]},backend:r}),u=sr(a,n.dtype,"max",r),l=X({inputs:{x:u},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Am(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,u=et(o,s.shape);let l=u;const c=Mt(l,a),h=c!=null,p=t.shouldExecuteOnCPU([s]);let d=s;if(h){if(p){const S=t.texData.get(d.dataId).values,T=new Array(a);for(let R=0;R<T.length;R++)T[R]=s.shape[c[R]];const N=Ma(S,s.shape,s.dtype,c,T);d=t.makeTensorInfo(T,s.dtype);const k=t.texData.get(d.dataId);k.values=N}else d=No(s,c,t);l=Ut(l.length,a)}Jt("max",l,a);const[f,g]=on(d.shape,l);let y=f;i&&(y=Vt(f,u));let w;if(p){const S=t.texData.get(d.dataId).values,T=ST(S,j(g),y,s.dtype);w=t.makeTensorInfo(y,s.dtype);const N=t.texData.get(w.dataId);N.values=T}else w=uR(d,g,y,t);return h&&t.disposeIntermediateTensorInfo(d),w}const lR={kernelName:Sh,backendName:"webgl",kernelFunc:Am};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cR=hm+`
  return max(a, b);
`,hR=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+To+`
  return result;
`,pR=tt({opSnippet:cR,packedOpSnippet:hR,cpuKernelImpl:TT}),dR={kernelName:Th,backendName:"webgl",kernelFunc:pR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Ss(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r,l=1;I(Nt(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Fr(s.shape,o,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&ze(c.inShape,c.outShape))return wt({inputs:{x:s},backend:t});const h=new ds(c,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}const mR={kernelName:Ch,backendName:"webgl",kernelFunc:fR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=r,c=[1,1,1],h=bs(s.shape,o,i,c,a,l,u),p=new Wa(h,"max",!1);return t.runWebGLProgram(p,[s],s.dtype)}const yR={kernelName:Nh,backendName:"webgl",kernelFunc:gR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xR{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,u=i-1-e.padInfo.left,l=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class bR{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=u-1-e.padInfo.front,p=l-1-e.padInfo.top,d=c-1-e.padInfo.left,f=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${p}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wR(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=r,h=[1,1,1],p=bs(i.shape,a,u,h,l,c),d=new Wa(p,"max",!0),f=t.runWebGLProgram(d,[i],i.dtype),g=new bR(p),y=t.runWebGLProgram(g,[s,f],i.dtype);return t.disposeIntermediateTensorInfo(f),y}const vR={kernelName:iy,backendName:"webgl",kernelFunc:wR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o,output:i}=e,a=o;Ss([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,p=Fr(a.shape,u,l,1,c,h),d=!0,f=new ds(p,"max",d),g=t.runWebGLProgram(f,[a],a.dtype),y=new xR(p),w=t.runWebGLProgram(y,[s,g],a.dtype);return t.disposeIntermediateTensorInfo(g),w}const SR={kernelName:oy,backendName:"webgl",kernelFunc:$R};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TR(n,e,t,r){let s=new ds(t,"max",!1);const o=r.runWebGLProgram(s,[n],"float32");s=new ds(t,"max",!0,!0,e);const i=r.runWebGLProgram(s,[n],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CR={kernelName:Eh,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=e,u=t;I(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];I(Nt(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Fr(r.shape,s,o,l,i),[h,p]=TR(r,a,c,u);return[h,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NR(n,e,t,r){const s=j(e),i=j(n.shape)/s,a=X({inputs:{x:n},attrs:{shape:[i,s]},backend:r}),u=sr(a,"float32","mean",r),l=X({inputs:{x:u},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ER={kernelName:Ih,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:o}=e,i=t,a=r.shape.length,u=et(o,r.shape);let l=u;const c=Mt(l,a),h=c!=null,p=i.shouldExecuteOnCPU([r]),d=[];let f=r;if(h){if(p){const T=i.texData.get(f.dataId).values,N=new Array(a);for(let F=0;F<N.length;F++)N[F]=r.shape[c[F]];const k=Ma(T,r.shape,r.dtype,c,N);f=i.makeTensorInfo(N,r.dtype);const R=i.texData.get(f.dataId);R.values=k}else f=No(r,c,i);d.push(f),l=Ut(l.length,a)}Jt("sum",l,a);const[g,y]=on(f.shape,l);let w=g;s&&(w=Vt(g,u));const $=NR(f,y,w,i);for(const S of d)i.disposeIntermediateTensorInfo(S);return $}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=et(o,s.shape);let l=u;const c=Mt(l,a);let h=s;c!=null&&(h=We({inputs:{x:s},backend:t,attrs:{perm:c}}),l=Ut(l.length,s.shape.length)),Jt("min",l,a);const[p,d]=on(h.shape,l),f=j(d),g=X({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=sr(g,g.dtype,"min",t);let w;if(i){const $=Vt(p,u);w=X({inputs:{x:y},backend:t,attrs:{shape:$}})}else w=X({inputs:{x:y},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),w}const kR={kernelName:kh,backendName:"webgl",kernelFunc:IR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RR=hm+`
  return min(a, b);
`,_R=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+To+`
  return result;
`,AR=tt({opSnippet:RR,packedOpSnippet:_R,cpuKernelImpl:CT}),OR={kernelName:Rh,backendName:"webgl",kernelFunc:AR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FR{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const s=e.length,o=Ae(s),i=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DR{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,g)=>f[0]+e[g]+f[1]);const s=e.length,o=Ae(s),i=t.map(f=>f[0]).join(","),a=t.map((f,g)=>f[0]+e[g]).join(","),u=lt("rc",s),l=lt("source",s),c=`${u[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${l.slice(-2).join()})`,p=r==="reflect"?0:1;let d="";if(s===1){const f=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${u[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
      `}else{const f=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;d=`
        ${o} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${u[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${h});
          ${u[s-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PR=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:o}=t,i=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DR(r.shape,s,o):new FR(r.shape,s,o);return e.runWebGLProgram(i,[r],r.dtype)},LR={kernelName:_h,backendName:"webgl",kernelFunc:PR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=`if (b == 0.0) return NAN;
  return mod(a, b);`,VR=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+To+`
  return result;
`,MR=tt({opSnippet:BR,packedOpSnippet:VR}),UR={kernelName:Ah,backendName:"webgl",kernelFunc:MR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WR{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zR=`
if (a == b) {
  return 1.0;
};
return a / b;`,GR=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Om=tt({opSnippet:zR,packedOpSnippet:GR,checkOutOfBounds:!0}),HR={kernelName:jc,backendName:"webgl",kernelFunc:Om};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pl="return a - b;",Fm=tt({opSnippet:pl,packedOpSnippet:pl,supportsComplex:!0,cpuKernelImpl:WT}),jR={kernelName:kp,backendName:"webgl",kernelFunc:Fm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dm(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:o}=r,i=et([o],s.shape),a=Am({inputs:{x:s},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),u=Vt(a.shape,i),l=X({inputs:{x:a},backend:t,attrs:{shape:u}}),c=Fm({inputs:{a:s,b:l},backend:t}),h=km({inputs:{x:c},backend:t}),p=Eo({inputs:{x:h},backend:t,attrs:{axis:i,keepDims:!1}}),d=X({inputs:{x:p},backend:t,attrs:{shape:u}}),f=Om({inputs:{a:h,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(d),f}const KR={kernelName:xp,backendName:"webgl",kernelFunc:Dm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XR(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,u=a?s:Dm({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new WR(l,c,o),p=[[i]],d=t.runWebGLProgram(h,[u],"int32",p);return a||t.disposeIntermediateTensorInfo(u),d}const qR={kernelName:Oh,backendName:"webgl",kernelFunc:XR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YR=zt+`
  return -x;
`,QR=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ZR(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId),[i,a]=ET(o.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}let s;return L().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new zn(r.shape,QR):s=new cn(r.shape,YR),t.runWebGLProgram(s,[r],r.dtype)}const JR={kernelName:Dh,backendName:"webgl",kernelFunc:ZR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e_=hf;function t_(n){Xt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r,l=t.readSync(s.dataId),c=t.readSync(o.dataId),{selectedIndices:h}=e_(l,c,i,a,u);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const n_={kernelName:Lh,backendName:"webgl",kernelFunc:t_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_=pf;function s_(n){Xt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=r,c=t.readSync(s.dataId),h=t.readSync(o.dataId),{selectedIndices:p,validOutputs:d}=r_(c,h,i,a,u,l);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}const o_={kernelName:Bh,backendName:"webgl",kernelFunc:s_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i_=df;function a_(n){Xt("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=r,c=t.readSync(s.dataId),h=t.readSync(o.dataId),p=i,d=a,f=u,g=l,{selectedIndices:y,selectedScores:w}=i_(c,h,p,d,f,g);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const u_={kernelName:Vh,backendName:"webgl",kernelFunc:a_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l_{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c_=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{depth:o,onValue:i,offValue:a}=r,u=j(s.shape),l=new l_(u,o,i,a),c=X({inputs:{x:s},backend:t,attrs:{shape:[u]}}),h=t.runWebGLProgram(l,[c],s.dtype);t.disposeIntermediateTensorInfo(c);const p=[...s.shape,o],d=X({inputs:{x:h},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(h),d},h_={kernelName:Uh,backendName:"webgl",kernelFunc:c_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ro(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=Ns({inputs:{input:r},backend:t}),o=ro({inputs:{x:s},backend:t}),i=Io({inputs:{input:r},backend:t}),a=ro({inputs:{x:i},backend:t}),u=On({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Es({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const p_={kernelName:Pp,backendName:"webgl",kernelFunc:ro};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pm(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Ns({inputs:{input:r},backend:t}),o=Pm({inputs:{x:s},backend:t}),i=Io({inputs:{input:r},backend:t}),a=ro({inputs:{x:i},backend:t}),u=On({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Es({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const d_={kernelName:Mh,backendName:"webgl",kernelFunc:Pm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return zi({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Qt(o,c.shape,"All tensors passed to stack must have matching shapes"),I(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(c=>{const h=zi({inputs:{input:c},backend:t,attrs:{dim:s}});return a.push(h),h}),l=$m({inputs:u,backend:t,attrs:{axis:s}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),l}const m_={kernelName:Wh,backendName:"webgl",kernelFunc:f_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g_{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);const s=e.length,o=Ae(s),i=t.map(l=>l[0]).join(","),a=t.map((l,c)=>l[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y_{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const s=e.length,o=Ae(s),i=t.map(g=>g[0]).join(","),a=t.map((g,y)=>g[0]+e[y]).join(","),u=lt("rc",s),l=lt("source",s),c=`${u[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${l.slice(-2).join()})`,p=[`${o} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${c}) {`],d=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,y=s===1?2:4;g<y;g++)f+=`
        ${p[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${g}] = getChannel(getX(${l.join()}), ${h});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lm=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,constantValue:i}=r;if(j(s.shape)===0){const l=o.map((c,h)=>c[0]+s.shape[h]+c[1]);return Es({backend:t,attrs:{shape:l,value:i,dtype:s.dtype}})}const a=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new y_(s.shape,o,i):new g_(s.shape,o,i),u=[[i]];return t.runWebGLProgram(a,[s],s.dtype,u)},x_={kernelName:zh,backendName:"webgl",kernelFunc:Lm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b_=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,w_=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+To+`
  return result;
`,v_=tt({opSnippet:b_,packedOpSnippet:w_}),$_={kernelName:Gh,backendName:"webgl",kernelFunc:v_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r,a=s.shape.length,u=[],l=et(o,s.shape);let c=l;const h=Mt(c,a);let p=s;h!=null&&(p=We({inputs:{x:s},backend:t,attrs:{perm:h}}),c=Ut(c.length,a),u.push(p)),Jt("prod",c,a);let d;if(t.shouldExecuteOnCPU([p])){const f=t.texData.get(p.dataId).values,{outVals:g,outShape:y,outDtype:w}=kT(p.shape,p.dtype,f,c);d=t.makeTensorInfo(y,w,g)}else{const[f,g]=on(p.shape,c),y=j(g),w=X({inputs:{x:p},backend:t,attrs:{shape:[-1,y]}}),$=fa(s.dtype),S=sr(w,$,"prod",t);d=X({inputs:{x:S},backend:t,attrs:{shape:f}}),u.push(w),u.push(S)}if(i){u.push(d);const f=Vt(d.shape,l);d=X({inputs:{x:d},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}const T_={kernelName:jh,backendName:"webgl",kernelFunc:S_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bm=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:o,dtype:i}=t,a=RT(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},C_={kernelName:Kh,backendName:"webgl",kernelFunc:Bm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_="return 1.0 / x;",E_=ge({opSnippet:N_}),I_={kernelName:qh,backendName:"webgl",kernelFunc:E_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k_=zt+`
  return (x < 0.0) ? 0.0 : x;
`,R_=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,__=ge({opSnippet:k_,packedOpSnippet:R_}),A_={kernelName:Yh,backendName:"webgl",kernelFunc:__};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_=zt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,F_=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,D_=ge({opSnippet:O_,packedOpSnippet:F_}),P_={kernelName:ep,backendName:"webgl",kernelFunc:D_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L_{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,r,l];const c=[s&&t>1?a-1:a,s&&r>1?u-1:u],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let p;o?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B_{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,r,l];const c=[s&&t>1?a-1:a,s&&r>1?u-1:u],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let p;o?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new B_(s.shape,u,l,o,i):new L_(s.shape,u,l,o,i);return t.runWebGLProgram(c,[s],"float32")}const M_={kernelName:Jh,backendName:"webgl",kernelFunc:V_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U_{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,i,a]=e,u=[r&&i>1?s-1:s,r&&a>1?o-1:o],l=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=u[0]/l[0],h=u[1]/l[1],p=1/c,d=1/h,f=Math.ceil(p)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:i}=r,a=new U_(o.shape,s.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const z_={kernelName:uy,backendName:"webgl",kernelFunc:W_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G_{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,r,l];const c=[s&&t>1?a-1:a,s&&r>1?u-1:u],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],p=s?"0.5":"0.0";let d;o?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H_{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,t,r,l];const c=[s&&t>1?a-1:a,s&&r>1?u-1:u],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],p=s?"0.5":"0.0";let d;o?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,c=L().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new H_(s.shape,u,l,o,i):new G_(s.shape,u,l,o,i);return t.runWebGLProgram(c,[s],s.dtype)}const K_={kernelName:Zh,backendName:"webgl",kernelFunc:j_};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X_{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,i,a]=e,u=[r&&i>1?s-1:s,r&&a>1?o-1:o],l=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=u[0]/l[0],h=u[1]/l[1],p=1/c,d=1/h,f=Math.ceil(p)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:i}=r,a=new X_(o.shape,s.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}const Y_={kernelName:ay,backendName:"webgl",kernelFunc:q_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q_{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,u)=>s(u)).join(","),i=Ae(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=lt("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Ae(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${o}){
            result.g = ${l(s.slice())};
          }
          if(${i}) {
            result.b = ${c(s.slice())};
            if(${o}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return p(f)}function l(f){return f[r-1]="("+f[r-1]+" + 1)",p(f)}function c(f){return f[r-2]="("+f[r-2]+" + 1)",p(f)}function h(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",p(f)}function p(f){const g=e.map(($,S)=>d(S,f)),y=g.join(","),w=g.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${w}))`}function d(f,g){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${g[f]} - 1`:`${g[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r,i=s.shape.length,a=et(o,s.shape);if(i===0)return wt({inputs:{x:s},backend:t});const u=L().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Z_(s.shape,a):new Q_(s.shape,a);return t.runWebGLProgram(u,[s],s.dtype)}const eA={kernelName:tp,backendName:"webgl",kernelFunc:J_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tA{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";typeof t=="number"?o=`float outputValue = ${t.toFixed(2)};`:o=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nA={kernelName:Bp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=e,a=t,u=new tA(r.shape,o),[l,c]=mf(i,r.shape[1],r.shape[2]),h=[[l,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(u,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rA=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,sA=ge({opSnippet:rA}),oA={kernelName:np,backendName:"webgl",kernelFunc:sA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iA="return inversesqrt(x);",aA=ge({opSnippet:iA,cpuKernelImpl:_T}),uA={kernelName:rp,backendName:"webgl",kernelFunc:aA};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vm{constructor(e,t,r,s,o,i,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Ae(o.length),l=Ae(i.length);let c="";r===1?c="i":r===2&&(c="i, j");const h=`getIndices(${c})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const d=`getUpdates(${p})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lA(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=xa(o,s,i),p=[h/l,l];if(h===0)return t.makeTensorInfo(i,s.dtype);const d=X({inputs:{x:s},backend:t,attrs:{shape:[u,a]}}),f=X({inputs:{x:o},backend:t,attrs:{shape:[u,l]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new Vm(u,a,d.shape.length,f.shape.length,c,p),w=t.runWebGLProgram(y,[f,d,g],f.dtype),$=X({inputs:{x:w},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(g),$}const cA={kernelName:sp,backendName:"webgl",kernelFunc:lA};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hA{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=L().getNumber("WEBGL_VERSION")===2?o:i,u=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pA(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:o}=e,{side:i}=r,a=new hA(s.shape[0],s.shape[1],o.shape[1],i),u=[[s.shape[1]]];return t.runWebGLProgram(a,[s,o],"int32",u)}const dA={kernelName:op,backendName:"webgl",kernelFunc:pA};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fA{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,o;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<t.length;c++)l.push(`${a[c]}`),c<e&&u.push(`${a[c]}`);s=u.join(),o=l.join()}const i=Ae(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mA(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e,i=new fA(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(i,[r,s,o],rn(s.dtype,o.dtype))}const gA={kernelName:ip,backendName:"webgl",kernelFunc:mA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yA=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${xf};
  float scale = ${bf};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,xA=ge({opSnippet:yA}),bA={kernelName:ap,backendName:"webgl",kernelFunc:xA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wA=Wr+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,vA=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$A=ge({opSnippet:wA,packedOpSnippet:vA,cpuKernelImpl:OT}),SA={kernelName:pp,backendName:"webgl",kernelFunc:$A};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TA=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,CA=ge({opSnippet:TA}),NA={kernelName:hp,backendName:"webgl",kernelFunc:CA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EA=Wr+`
  return sin(x);
`,IA=ge({opSnippet:EA}),kA={kernelName:lp,backendName:"webgl",kernelFunc:IA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RA=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,_A=ge({opSnippet:RA}),AA={kernelName:cp,backendName:"webgl",kernelFunc:_A};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OA=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,FA=ge({opSnippet:OA}),DA={kernelName:dp,backendName:"webgl",kernelFunc:FA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PA=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:i}=r;I(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((w,$)=>w*$),u=[[0,0]];u.push(...i);for(let w=1+o.length;w<s.shape.length;++w)u.push([0,0]);const l=[],c=Lm({inputs:{x:s},backend:t,attrs:{paddings:u,constantValue:0}}),h=Oa(c.shape,o,a,!1),p=Fa(h.length,o.length,!1),d=Da(c.shape,o,a,!1),f=X({inputs:{x:c},backend:t,attrs:{shape:h}}),g=We({inputs:{x:f},backend:t,attrs:{perm:p}}),y=X({inputs:{x:g},backend:t,attrs:{shape:d}});return l.push(c),l.push(f),l.push(g),l.forEach(w=>t.disposeIntermediateTensorInfo(w)),y},LA={kernelName:gp,backendName:"webgl",kernelFunc:PA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=t.readSync(r.dataId),u=t.readSync(s.dataId),l=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[h,p,d,f,g]=DT(a,r.shape,r.dtype,u,s.dtype,l,c);return[t.makeTensorInfo(p,r.dtype,h),t.makeTensorInfo([p[0]],s.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const VA={kernelName:bp,backendName:"webgl",kernelFunc:BA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MA(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),u=Array.from(t.readSync(o.dataId)),[l,c,h]=PT(a,r.shape,r.dtype,i,u);return[t.makeTensorInfo(c,r.dtype,l),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const UA={kernelName:wp,backendName:"webgl",kernelFunc:MA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WA(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=t.readSync(r.dataId),a=t.readSync(s.dataId),u=t.readSync(o.dataId),[l,c]=um(i,r.shape,r.dtype,a,u,!0);return t.makeTensorInfo(c,r.dtype,l)}const zA={kernelName:vp,backendName:"webgl",kernelFunc:WA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=t.readSync(r.dataId),a=t.readSync(s.dataId),u=t.readSync(o.dataId),[l,c]=um(i,r.shape,r.dtype,a,u);return t.makeTensorInfo(c,r.dtype,l)}const HA={kernelName:$p,backendName:"webgl",kernelFunc:GA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:p}=xa(o,s,a),d=!1;if(o.dtype==="string"){const w=t.bufferSync(s),$=t.bufferSync(o),S=Cr(t.readSync(i.dataId)[0]),T=AT(w,$,a,p,c,l,u,h,S,d);return t.makeTensorInfo(a,T.dtype,T.values)}const f=new Vm(l,u,s.shape.length,o.shape.length,h,[p,1],d),g=t.runWebGLProgram(f,[o,s,i],o.dtype),y=X({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(g),y}const KA={kernelName:Sp,backendName:"webgl",kernelFunc:jA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=et(i,s.shape)[0],u=_f(s,o,a),l=s.shape.length,c=new Array(l).fill(0),h=s.shape.slice();return u.map(p=>{const d=[...h];d[a]=p;const f=zr({inputs:{x:s},backend:t,attrs:{begin:c,size:d}});return c[a]+=p,f})}const qA={kernelName:yp,backendName:"webgl",kernelFunc:XA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dl="return sqrt(x);",YA=ge({opSnippet:dl,packedOpSnippet:dl,cpuKernelImpl:LT}),QA={kernelName:fp,backendName:"webgl",kernelFunc:YA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZA="return x * x;",JA=ge({opSnippet:ZA}),eO={kernelName:ly,backendName:"webgl",kernelFunc:JA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fl="return (a - b) * (a - b);",tO=tt({opSnippet:fl,packedOpSnippet:fl}),nO={kernelName:Tp,backendName:"webgl",kernelFunc:tO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rO({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=zt+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new cn(r.shape,s);return t.runWebGLProgram(o,[r],r.dtype)}const sO={kernelName:Lp,backendName:"webgl",kernelFunc:rO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oO{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Ae(r.length),i=Ae(r.length);let a="";if(s===1)a="coords * strides + begin";else{let u=0;a=r.map((l,c)=>(u++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:p}=r,{finalShapeSparse:d,finalShape:f,isIdentity:g,sliceDim0:y,isSimpleSlice:w,begin:$,end:S,strides:T}=Cd(s.shape,o,i,a,u,l,c,h,p);let N;if(g)N=X({inputs:{x:s},backend:t,attrs:{shape:f}});else if(y||w){I(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const R=md($,S,T),F=zr({inputs:{x:s},backend:t,attrs:{begin:$,size:R}});N=X({inputs:{x:F},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(F)}else if(t.shouldExecuteOnCPU([s])){const F=t.readSync(s.dataId),O=Ge(s.shape,s.dtype,F),B=BT(d,O,T,$);N=t.makeTensorInfo(f,s.dtype,B.values)}else{const F=new oO($,T,d);N=t.runWebGLProgram(F,[s],s.dtype)}const k=X({inputs:{x:N},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(N),k}const aO={kernelName:Cp,backendName:"webgl",kernelFunc:iO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uO(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=e,p=t.readSync(c.dataId),d=t.readSync(h.dataId),[f,g]=VT(p,d,s,o,i,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",g)]}const lO={kernelName:Np,backendName:"webgl",kernelFunc:uO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.readSync(o.dataId),u=t.readSync(i.dataId)[0],[l,c,h]=MT(a,u,s),p=c.length;return[t.makeTensorInfo([p,2],"int32",l),t.makeTensorInfo([p],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const hO={kernelName:Ep,backendName:"webgl",kernelFunc:cO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),a=UT(i,s);return t.makeTensorInfo(o.shape,"int32",a)}const dO={kernelName:Ip,backendName:"webgl",kernelFunc:pO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fO="return tan(x);",mO=ge({opSnippet:fO}),gO={kernelName:Rp,backendName:"webgl",kernelFunc:mO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yO=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,xO=ge({opSnippet:yO}),bO={kernelName:_p,backendName:"webgl",kernelFunc:xO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wO{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let i=0;i<r.length;i++)r[i]=e[i]*t[i];this.outputShape=r,this.rank=r.length;const s=Ae(this.rank),o=vO(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function vO(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mm(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const u=t.readSync(s.dataId),l=s.dtype==="string"?u.map(p=>Cr(p)):u,c=Ge(s.shape,s.dtype,l),h=zT(c,o);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new wO(s.shape,o);return t.runWebGLProgram(i,[s],s.dtype)}const $O={kernelName:ha,backendName:"webgl",kernelFunc:Mm};class SO{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class TO{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pn(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function ml(n){let e=1;for(;e<n;)e*=2;return e}function CO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:o,sorted:i}=r,a=L().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=L().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,c=l[l.length-1];if(t.shouldExecuteOnCPU([s])||c<a||o>u){const B=t.readSync(s.dataId),[M,H]=GT(B,l,s.dtype,o,i);return[t.makeTensorInfo(M.shape,M.dtype,M.values),t.makeTensorInfo(H.shape,H.dtype,H.values)]}if(o===0)return l[l.length-1]=0,[t.makeTensorInfo(l,s.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(c===1)return[s,Es({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const h=t.texData.get(s.dataId),p=h!==null&&h.isPacked,d=p?t.unpackTensor(s):s,g=j(l)/c,y=X({inputs:{x:d},attrs:{shape:[g,c]},backend:t});p&&Pn(t,d);const w=ml(o),$=ml(c);let S=null;const T=()=>S===null?[y,y]:[y,S],N=(B,M,H)=>{const G=T(),Y=new SO(H),ne=[[c],[S===null?1:0],[Number.NEGATIVE_INFINITY],[B],[M]],ue=S;S=t.runWebGLProgram(Y,G,"int32",ne),Pn(t,ue)};for(let B=1;B<w;B*=2){const M=B*2;for(let H=B;H>=1;H/=2)N(M,H,[g,$])}for(let B=$;B>w;B/=2){const M=T(),H=new TO([g,B/2]),Y=[[c],[S===null?1:0],[w]],te=S;S=t.runWebGLProgram(H,M,"int32",Y),Pn(t,te);const ne=w/2,ue=ne*2;for(let He=ne;He>=1;He/=2)N(ue,He,S.shape)}let k=S;S=zr({inputs:{x:S},backend:t,attrs:{begin:0,size:[g,o]}}),Pn(t,k);let R=_m({inputs:{x:y,indices:S},backend:t,attrs:{axis:1,batchDims:1}});Pn(t,y);const F=l.slice(0,-1);F.push(o),k=S,S=X({inputs:{x:S},attrs:{shape:F},backend:t}),Pn(t,k);const O=R;return R=X({inputs:{x:R},attrs:{shape:F},backend:t}),Pn(t,O),[R,S]}const NO={kernelName:Ap,backendName:"webgl",kernelFunc:CO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EO{constructor(e,t,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=r==="nearest"?1:2;let u;switch(s){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IO(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=r,[c,h,p,d]=s.shape,[f,g]=l!=null?l:[h,p],y=[c,f,g,d],w=new EO(h,p,i,a,u,y);return t.runWebGLProgram(w,[s,o],"float32")}const kO={kernelName:Op,backendName:"webgl",kernelFunc:IO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RO(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:o}=e;Ss(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:u,indices:l}=HT(i,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}const _O={kernelName:Fp,backendName:"webgl",kernelFunc:RO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AO(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,u=s.shape[o],l=new Array(a-1);let c=0;for(let g=0;g<a;g++)g!==o&&(l[c++]=i.shape[g]);const h=[],p=new Array(a).fill(0),d=i.shape.slice();d[o]=1;const f=new Array(u);for(let g=0;g<f.length;g++){p[o]=g;const y=zr({inputs:{x:i},backend:t,attrs:{begin:p,size:d}}),w=X({inputs:{x:y},backend:t,attrs:{shape:l}});f[g]=w,h.push(y)}return h.forEach(g=>t.disposeIntermediateTensorInfo(g)),f}const OO={kernelName:Dp,backendName:"webgl",kernelFunc:AO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FO{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const u="0.0",l="sumValue",c=Math.floor(r/4)*4,h=r%4,p=`
        sumValue += dot(values, segFilter);
    `;let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let f="";o%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,u=[];let l=0;const c=Mt([l],a);let h=s;c!=null&&(h=We({inputs:{x:s},backend:t,attrs:{perm:c}}),u.push(h),l=Ut(1,a)[0]);const p=Gf(h.shape,l,i),d=j([h.shape[l]]),f=X({inputs:{x:h},backend:t,attrs:{shape:[-1,d]}});u.push(f);const g=fa(s.dtype),y=(T,N,k,R,F)=>{const O=T.shape[0],B=T.shape[1],M=zf(B,F),H={windowSize:M,inSize:B,batchSize:O,numSegments:F},G=new FO(H,N),Y=t.compileAndRun(G,[T,k],R);if(u.push(Y),Y.shape[1]===F)return Y;const te=Bm({backend:t,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),ne=Mm({inputs:{x:te},backend:t,attrs:{reps:[B/M]}});return u.push(te),u.push(ne),y(Y,N,ne,R,F)},w=y(f,"unsortedSegmentSum",o,g,i),$=X({inputs:{x:w},backend:t,attrs:{shape:p}});let S=$;if(c!=null){u.push($);const T=Ca(c);S=We({inputs:{x:S},backend:t,attrs:{perm:T}})}return u.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}const PO={kernelName:cy,backendName:"webgl",kernelFunc:DO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LO=[BC,MC,zC,jC,XC,QC,JC,tN,oN,aN,cN,dN,gN,wN,SN,CN,EN,_N,ON,DN,VN,jN,XN,YN,nE,sE,uE,bC,hE,gE,wE,NE,IE,RE,AE,FE,LE,ME,zE,HE,KE,qE,ZE,eI,sI,iI,lI,pI,fI,xI,$I,NI,kI,AI,OI,DI,LI,VI,UI,zI,KI,YI,JI,tk,sk,ak,hk,mk,xC,yk,fE,wk,Sk,Nk,vC,Rk,Fk,Pk,Mk,zk,Kk,Yk,eR,sR,aR,lR,dR,mR,yR,vR,SR,CR,ER,kR,OR,LR,UR,qR,NC,JR,n_,o_,u_,ZN,h_,d_,m_,x_,$_,SC,T_,C_,JN,HR,I_,A_,P_,IC,M_,z_,K_,Y_,eA,nA,oA,uA,cA,dA,gA,bA,SA,NA,kA,AA,GN,KR,DA,LA,VA,UA,zA,HA,KA,qA,QA,eO,nO,sO,aO,lO,hO,dO,jR,DC,gO,bO,$O,NO,kO,PC,_O,OO,PO,p_];for(const n of LO)dy(n);var BO={};(function(){var n;function e(m){var b=0;return function(){return b<m.length?{done:!1,value:m[b++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(m,b,v){return m==Array.prototype||m==Object.prototype||(m[b]=v.value),m};function r(m){m=[typeof globalThis=="object"&&globalThis,m,typeof window=="object"&&window,typeof self=="object"&&self,typeof hn=="object"&&hn];for(var b=0;b<m.length;++b){var v=m[b];if(v&&v.Math==Math)return v}throw Error("Cannot find global object")}var s=r(this);function o(m,b){if(b)e:{var v=s;m=m.split(".");for(var E=0;E<m.length-1;E++){var D=m[E];if(!(D in v))break e;v=v[D]}m=m[m.length-1],E=v[m],b=b(E),b!=E&&b!=null&&t(v,m,{configurable:!0,writable:!0,value:b})}}o("Symbol",function(m){function b(U){if(this instanceof b)throw new TypeError("Symbol is not a constructor");return new v(E+(U||"")+"_"+D++,U)}function v(U,P){this.g=U,t(this,"description",{configurable:!0,writable:!0,value:P})}if(m)return m;v.prototype.toString=function(){return this.g};var E="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",D=0;return b}),o("Symbol.iterator",function(m){if(m)return m;m=Symbol("Symbol.iterator");for(var b="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),v=0;v<b.length;v++){var E=s[b[v]];typeof E=="function"&&typeof E.prototype[m]!="function"&&t(E.prototype,m,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return m});function i(m){return m={next:m},m[Symbol.iterator]=function(){return this},m}function a(m){var b=typeof Symbol!="undefined"&&Symbol.iterator&&m[Symbol.iterator];return b?b.call(m):{next:e(m)}}function u(m){if(!(m instanceof Array)){m=a(m);for(var b,v=[];!(b=m.next()).done;)v.push(b.value);m=v}return m}var l=typeof Object.create=="function"?Object.create:function(m){function b(){}return b.prototype=m,new b},c;if(typeof Object.setPrototypeOf=="function")c=Object.setPrototypeOf;else{var h;e:{var p={a:!0},d={};try{d.__proto__=p,h=d.a;break e}catch{}h=!1}c=h?function(m,b){if(m.__proto__=b,m.__proto__!==b)throw new TypeError(m+" is not extensible");return m}:null}var f=c;function g(m,b){if(m.prototype=l(b.prototype),m.prototype.constructor=m,f)f(m,b);else for(var v in b)if(v!="prototype")if(Object.defineProperties){var E=Object.getOwnPropertyDescriptor(b,v);E&&Object.defineProperty(m,v,E)}else m[v]=b[v];m.ea=b.prototype}function y(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function w(m){if(m.l)throw new TypeError("Generator is already running");m.l=!0}y.prototype.o=function(m){this.h=m};function $(m,b){m.j={U:b,V:!0},m.g=m.m||m.s}y.prototype.return=function(m){this.j={return:m},this.g=this.s};function S(m,b,v){return m.g=v,{value:b}}function T(m){this.g=new y,this.h=m}function N(m,b){w(m.g);var v=m.g.i;return v?k(m,"return"in v?v.return:function(E){return{value:E,done:!0}},b,m.g.return):(m.g.return(b),R(m))}function k(m,b,v,E){try{var D=b.call(m.g.i,v);if(!(D instanceof Object))throw new TypeError("Iterator result "+D+" is not an object");if(!D.done)return m.g.l=!1,D;var U=D.value}catch(P){return m.g.i=null,$(m.g,P),R(m)}return m.g.i=null,E.call(m.g,U),R(m)}function R(m){for(;m.g.g;)try{var b=m.h(m.g);if(b)return m.g.l=!1,{value:b.value,done:!1}}catch(v){m.g.h=void 0,$(m.g,v)}if(m.g.l=!1,m.g.j){if(b=m.g.j,m.g.j=null,b.V)throw b.U;return{value:b.return,done:!0}}return{value:void 0,done:!0}}function F(m){this.next=function(b){return w(m.g),m.g.i?b=k(m,m.g.i.next,b,m.g.o):(m.g.o(b),b=R(m)),b},this.throw=function(b){return w(m.g),m.g.i?b=k(m,m.g.i.throw,b,m.g.o):($(m.g,b),b=R(m)),b},this.return=function(b){return N(m,b)},this[Symbol.iterator]=function(){return this}}function O(m,b){return b=new F(new T(b)),f&&m.prototype&&f(b,m.prototype),b}function B(m,b){m instanceof String&&(m+="");var v=0,E=!1,D={next:function(){if(!E&&v<m.length){var U=v++;return{value:b(U,m[U]),done:!1}}return E=!0,{done:!0,value:void 0}}};return D[Symbol.iterator]=function(){return D},D}var M=typeof Object.assign=="function"?Object.assign:function(m,b){for(var v=1;v<arguments.length;v++){var E=arguments[v];if(E)for(var D in E)Object.prototype.hasOwnProperty.call(E,D)&&(m[D]=E[D])}return m};o("Object.assign",function(m){return m||M}),o("Promise",function(m){function b(P){this.h=0,this.i=void 0,this.g=[],this.o=!1;var V=this.j();try{P(V.resolve,V.reject)}catch(z){V.reject(z)}}function v(){this.g=null}function E(P){return P instanceof b?P:new b(function(V){V(P)})}if(m)return m;v.prototype.h=function(P){if(this.g==null){this.g=[];var V=this;this.i(function(){V.l()})}this.g.push(P)};var D=s.setTimeout;v.prototype.i=function(P){D(P,0)},v.prototype.l=function(){for(;this.g&&this.g.length;){var P=this.g;this.g=[];for(var V=0;V<P.length;++V){var z=P[V];P[V]=null;try{z()}catch(q){this.j(q)}}}this.g=null},v.prototype.j=function(P){this.i(function(){throw P})},b.prototype.j=function(){function P(q){return function(re){z||(z=!0,q.call(V,re))}}var V=this,z=!1;return{resolve:P(this.C),reject:P(this.l)}},b.prototype.C=function(P){if(P===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(P instanceof b)this.F(P);else{e:switch(typeof P){case"object":var V=P!=null;break e;case"function":V=!0;break e;default:V=!1}V?this.u(P):this.m(P)}},b.prototype.u=function(P){var V=void 0;try{V=P.then}catch(z){this.l(z);return}typeof V=="function"?this.G(V,P):this.m(P)},b.prototype.l=function(P){this.s(2,P)},b.prototype.m=function(P){this.s(1,P)},b.prototype.s=function(P,V){if(this.h!=0)throw Error("Cannot settle("+P+", "+V+"): Promise already settled in state"+this.h);this.h=P,this.i=V,this.h===2&&this.D(),this.A()},b.prototype.D=function(){var P=this;D(function(){if(P.B()){var V=s.console;typeof V!="undefined"&&V.error(P.i)}},1)},b.prototype.B=function(){if(this.o)return!1;var P=s.CustomEvent,V=s.Event,z=s.dispatchEvent;return typeof z=="undefined"?!0:(typeof P=="function"?P=new P("unhandledrejection",{cancelable:!0}):typeof V=="function"?P=new V("unhandledrejection",{cancelable:!0}):(P=s.document.createEvent("CustomEvent"),P.initCustomEvent("unhandledrejection",!1,!0,P)),P.promise=this,P.reason=this.i,z(P))},b.prototype.A=function(){if(this.g!=null){for(var P=0;P<this.g.length;++P)U.h(this.g[P]);this.g=null}};var U=new v;return b.prototype.F=function(P){var V=this.j();P.J(V.resolve,V.reject)},b.prototype.G=function(P,V){var z=this.j();try{P.call(V,z.resolve,z.reject)}catch(q){z.reject(q)}},b.prototype.then=function(P,V){function z(he,oe){return typeof he=="function"?function(Z){try{q(he(Z))}catch(se){re(se)}}:oe}var q,re,Ce=new b(function(he,oe){q=he,re=oe});return this.J(z(P,q),z(V,re)),Ce},b.prototype.catch=function(P){return this.then(void 0,P)},b.prototype.J=function(P,V){function z(){switch(q.h){case 1:P(q.i);break;case 2:V(q.i);break;default:throw Error("Unexpected state: "+q.h)}}var q=this;this.g==null?U.h(z):this.g.push(z),this.o=!0},b.resolve=E,b.reject=function(P){return new b(function(V,z){z(P)})},b.race=function(P){return new b(function(V,z){for(var q=a(P),re=q.next();!re.done;re=q.next())E(re.value).J(V,z)})},b.all=function(P){var V=a(P),z=V.next();return z.done?E([]):new b(function(q,re){function Ce(Z){return function(se){he[Z]=se,oe--,oe==0&&q(he)}}var he=[],oe=0;do he.push(void 0),oe++,E(z.value).J(Ce(he.length-1),re),z=V.next();while(!z.done)})},b}),o("Object.is",function(m){return m||function(b,v){return b===v?b!==0||1/b===1/v:b!==b&&v!==v}}),o("Array.prototype.includes",function(m){return m||function(b,v){var E=this;E instanceof String&&(E=String(E));var D=E.length;for(v=v||0,0>v&&(v=Math.max(v+D,0));v<D;v++){var U=E[v];if(U===b||Object.is(U,b))return!0}return!1}}),o("String.prototype.includes",function(m){return m||function(b,v){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(b,v||0)!==-1}}),o("Array.prototype.keys",function(m){return m||function(){return B(this,function(b){return b})}});var H=this||self;function G(m,b){m=m.split(".");var v=H;m[0]in v||typeof v.execScript=="undefined"||v.execScript("var "+m[0]);for(var E;m.length&&(E=m.shift());)m.length||b===void 0?v[E]&&v[E]!==Object.prototype[E]?v=v[E]:v=v[E]={}:v[E]=b}function Y(m,b){return b=String.fromCharCode.apply(null,b),m==null?b:m+b}var te,ne=typeof TextDecoder!="undefined",ue,He=typeof TextEncoder!="undefined";function Fe(m){if(He)m=(ue||(ue=new TextEncoder)).encode(m);else{var b=void 0;b=b===void 0?!1:b;for(var v=0,E=new Uint8Array(3*m.length),D=0;D<m.length;D++){var U=m.charCodeAt(D);if(128>U)E[v++]=U;else{if(2048>U)E[v++]=U>>6|192;else{if(55296<=U&&57343>=U){if(56319>=U&&D<m.length){var P=m.charCodeAt(++D);if(56320<=P&&57343>=P){U=1024*(U-55296)+P-56320+65536,E[v++]=U>>18|240,E[v++]=U>>12&63|128,E[v++]=U>>6&63|128,E[v++]=U&63|128;continue}else D--}if(b)throw Error("Found an unpaired surrogate");U=65533}E[v++]=U>>12|224,E[v++]=U>>6&63|128}E[v++]=U&63|128}}m=E.subarray(0,v)}return m}var $t={},je=null;function or(m,b){b===void 0&&(b=0),ir(),b=$t[b];for(var v=Array(Math.floor(m.length/3)),E=b[64]||"",D=0,U=0;D<m.length-2;D+=3){var P=m[D],V=m[D+1],z=m[D+2],q=b[P>>2];P=b[(P&3)<<4|V>>4],V=b[(V&15)<<2|z>>6],z=b[z&63],v[U++]=q+P+V+z}switch(q=0,z=E,m.length-D){case 2:q=m[D+1],z=b[(q&15)<<2]||E;case 1:m=m[D],v[U]=b[m>>2]+b[(m&3)<<4|q>>4]+z+E}return v.join("")}function Gr(m){var b=m.length,v=3*b/4;v%3?v=Math.floor(v):"=.".indexOf(m[b-1])!=-1&&(v="=.".indexOf(m[b-2])!=-1?v-2:v-1);var E=new Uint8Array(v),D=0;return ko(m,function(U){E[D++]=U}),E.subarray(0,D)}function ko(m,b){function v(z){for(;E<m.length;){var q=m.charAt(E++),re=je[q];if(re!=null)return re;if(!/^[\s\xa0]*$/.test(q))throw Error("Unknown base64 encoding at char: "+q)}return z}ir();for(var E=0;;){var D=v(-1),U=v(0),P=v(64),V=v(64);if(V===64&&D===-1)break;b(D<<2|U>>4),P!=64&&(b(U<<4&240|P>>2),V!=64&&b(P<<6&192|V))}}function ir(){if(!je){je={};for(var m="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],v=0;5>v;v++){var E=m.concat(b[v].split(""));$t[v]=E;for(var D=0;D<E.length;D++){var U=E[D];je[U]===void 0&&(je[U]=D)}}}}var Is=typeof Uint8Array.prototype.slice=="function",Ha;function ja(m,b,v){return b===v?Ha||(Ha=new Uint8Array(0)):Is?m.slice(b,v):new Uint8Array(m.subarray(b,v))}var an=0,mn=0;function Ka(m,b){b=b===void 0?{}:b,b=b.v===void 0?!1:b.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=b,m&&Xa(this,m)}function Xa(m,b){b=b.constructor===Uint8Array?b:b.constructor===ArrayBuffer?new Uint8Array(b):b.constructor===Array?new Uint8Array(b):b.constructor===String?Gr(b):b instanceof Uint8Array?new Uint8Array(b.buffer,b.byteOffset,b.byteLength):new Uint8Array(0),m.h=b,m.j=0,m.i=m.h.length,m.g=m.j}Ka.prototype.reset=function(){this.g=this.j};function Hr(m){var b=m.h,v=b[m.g],E=v&127;return 128>v?(m.g+=1,E):(v=b[m.g+1],E|=(v&127)<<7,128>v?(m.g+=2,E):(v=b[m.g+2],E|=(v&127)<<14,128>v?(m.g+=3,E):(v=b[m.g+3],E|=(v&127)<<21,128>v?(m.g+=4,E):(v=b[m.g+4],E|=(v&15)<<28,128>v?(m.g+=5,E>>>0):(m.g+=5,128<=b[m.g++]&&128<=b[m.g++]&&128<=b[m.g++]&&128<=b[m.g++]&&m.g++,E)))))}function Gt(m){var b=m.h[m.g],v=m.h[m.g+1],E=m.h[m.g+2],D=m.h[m.g+3];return m.g+=4,v=(b<<0|v<<8|E<<16|D<<24)>>>0,m=2*(v>>31)+1,b=v>>>23&255,v&=8388607,b==255?v?NaN:1/0*m:b==0?m*Math.pow(2,-149)*v:m*Math.pow(2,b-150)*(v+Math.pow(2,23))}var qa=[];function ks(){this.g=new Uint8Array(64),this.h=0}ks.prototype.push=function(m){if(!(this.h+1<this.g.length)){var b=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(b)}this.g[this.h++]=m},ks.prototype.length=function(){return this.h},ks.prototype.end=function(){var m=this.g,b=this.h;return this.h=0,ja(m,0,b)};function gn(m,b){for(;127<b;)m.push(b&127|128),b>>>=7;m.push(b)}function Rs(m){var b={},v=b.N===void 0?!1:b.N;this.o={v:b.v===void 0?!1:b.v},this.N=v,b=this.o,qa.length?(v=qa.pop(),b&&(v.v=b.v),m&&Xa(v,m),m=v):m=new Ka(m,b),this.g=m,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}Rs.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function ar(m){var b=m.g;if((b=b.g==b.i)||(b=m.j)||(b=m.g,b=b.l||0>b.g||b.g>b.i),b)return!1;m.m=m.g.g,b=Hr(m.g);var v=b&7;return v!=0&&v!=5&&v!=1&&v!=2&&v!=3&&v!=4?(m.j=!0,!1):(m.i=b,m.l=b>>>3,m.h=v,!0)}function ur(m){switch(m.h){case 0:if(m.h!=0)ur(m);else{for(m=m.g;m.h[m.g]&128;)m.g++;m.g++}break;case 1:m.h!=1?ur(m):(m=m.g,m.g+=8);break;case 2:if(m.h!=2)ur(m);else{var b=Hr(m.g);m=m.g,m.g+=b}break;case 5:m.h!=5?ur(m):(m=m.g,m.g+=4);break;case 3:b=m.l;do{if(!ar(m)){m.j=!0;break}if(m.h==4){m.l!=b&&(m.j=!0);break}ur(m)}while(1);break;default:m.j=!0}}function Ya(m,b,v){var E=m.g.i,D=Hr(m.g),U=m.g.g+D;if(m.g.i=U,v(b,m),v=U-m.g.g,v!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+D+" bytes, instead read "+(D-v)+" bytes, either the data ended unexpectedly or the message misreported its own length");return m.g.g=U,m.g.i=E,b}function Qa(m){var b=Hr(m.g);m=m.g;var v=m.g;m.g+=b,m=m.h;var E;if(ne)(E=te)||(E=te=new TextDecoder("utf-8",{fatal:!1})),E=E.decode(m.subarray(v,v+b));else{b=v+b;for(var D=[],U=null,P,V,z;v<b;)P=m[v++],128>P?D.push(P):224>P?v>=b?D.push(65533):(V=m[v++],194>P||(V&192)!==128?(v--,D.push(65533)):D.push((P&31)<<6|V&63)):240>P?v>=b-1?D.push(65533):(V=m[v++],(V&192)!==128||P===224&&160>V||P===237&&160<=V||((E=m[v++])&192)!==128?(v--,D.push(65533)):D.push((P&15)<<12|(V&63)<<6|E&63)):244>=P?v>=b-2?D.push(65533):(V=m[v++],(V&192)!==128||(P<<28)+(V-144)>>30!==0||((E=m[v++])&192)!==128||((z=m[v++])&192)!==128?(v--,D.push(65533)):(P=(P&7)<<18|(V&63)<<12|(E&63)<<6|z&63,P-=65536,D.push((P>>10&1023)+55296,(P&1023)+56320))):D.push(65533),8192<=D.length&&(U=Y(U,D),D.length=0);E=Y(U,D)}return E}function Ro(){this.h=[],this.i=0,this.g=new ks}function lr(m,b){b.length!==0&&(m.h.push(b),m.i+=b.length)}function _o(m){var b=m.i+m.g.length();if(b===0)return new Uint8Array(0);b=new Uint8Array(b);for(var v=m.h,E=v.length,D=0,U=0;U<E;U++){var P=v[U];P.length!==0&&(b.set(P,D),D+=P.length)}return v=m.g,E=v.h,E!==0&&(b.set(v.g.subarray(0,E),D),v.h=0),m.h=[b],b}function Ht(m,b,v){if(v!=null){gn(m.g,8*b+5),m=m.g;var E=v;E=(v=0>E?1:0)?-E:E,E===0?0<1/E?an=mn=0:(mn=0,an=2147483648):isNaN(E)?(mn=0,an=2147483647):34028234663852886e22<E?(mn=0,an=(v<<31|2139095040)>>>0):11754943508222875e-54>E?(E=Math.round(E/Math.pow(2,-149)),mn=0,an=(v<<31|E)>>>0):(b=Math.floor(Math.log(E)/Math.LN2),E*=Math.pow(2,-b),E=Math.round(8388608*E),16777216<=E&&++b,mn=0,an=(v<<31|b+127<<23|E&8388607)>>>0),v=an,m.push(v>>>0&255),m.push(v>>>8&255),m.push(v>>>16&255),m.push(v>>>24&255)}}var Za=typeof Uint8Array=="function";function Ja(m,b,v){if(m!=null)return typeof m=="object"?Za&&m instanceof Uint8Array?v(m):eu(m,b,v):b(m)}function eu(m,b,v){if(Array.isArray(m)){for(var E=Array(m.length),D=0;D<m.length;D++)E[D]=Ja(m[D],b,v);return Array.isArray(m)&&m.W&&jr(E),E}E={};for(D in m)E[D]=Ja(m[D],b,v);return E}function cg(m){return typeof m=="number"?isFinite(m)?m:String(m):m}var hg={W:{value:!0,configurable:!0}};function jr(m){return Array.isArray(m)&&!Object.isFrozen(m)&&Object.defineProperties(m,hg),m}var tu;function Et(m,b,v){var E=tu;tu=null,m||(m=E),E=this.constructor.ca,m||(m=E?[E]:[]),this.j=E?0:-1,this.i=null,this.g=m;e:{if(E=this.g.length,m=E-1,E&&(E=this.g[m],!(E===null||typeof E!="object"||Array.isArray(E)||Za&&E instanceof Uint8Array))){this.l=m-this.j,this.h=E;break e}b!==void 0&&-1<b?(this.l=Math.max(b,m+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(v)for(b=0;b<v.length;b++)m=v[b],m<this.l?(m+=this.j,(E=this.g[m])?jr(E):this.g[m]=_s):(nu(this),(E=this.h[m])?jr(E):this.h[m]=_s)}var _s=Object.freeze(jr([]));function nu(m){var b=m.l+m.j;m.g[b]||(m.h=m.g[b]={})}function Ve(m,b,v){return b===-1?null:(v===void 0?0:v)||b>=m.l?m.h?m.h[b]:void 0:m.g[b+m.j]}function ru(m){var b=b===void 0?!1:b,v=Ve(m,1,b);return v==null&&(v=_s),v===_s&&(v=jr([]),Te(m,1,v,b)),v}function en(m,b,v){return m=Ve(m,b),m=m==null?m:+m,m==null?v===void 0?0:v:m}function Te(m,b,v,E){(E===void 0?0:E)||b>=m.l?(nu(m),m.h[b]=v):m.g[b+m.j]=v}function Ao(m,b){m.i||(m.i={});var v=m.i[1];if(!v){var E=ru(m);v=[];for(var D=0;D<E.length;D++)v[D]=new b(E[D]);m.i[1]=v}return v}function su(m,b,v,E){var D=Ao(m,v);b=b||new v,m=ru(m),E!=null?(D.splice(E,0,b),m.splice(E,0,cr(b))):(D.push(b),m.push(cr(b)))}Et.prototype.toJSON=function(){var m=cr(this);return eu(m,cg,or)};function cr(m,b){if(m.i)for(var v in m.i){var E=m.i[v];if(Array.isArray(E))for(var D=0;D<E.length;D++)E[D]&&cr(E[D]);else E&&cr(E)}return m.g}Et.prototype.toString=function(){return cr(this).toString()};function ou(m,b){return m=Ve(m,b),m==null?0:m}function iu(m,b){return m=Ve(m,b),m==null?"":m}function Oo(m,b){if(m=m.m){lr(b,b.g.end());for(var v=0;v<m.length;v++)lr(b,m[v])}}function Kr(m,b){if(b.h==4)return!1;var v=b.m;return ur(b),b.N||(b=ja(b.g.h,v,b.g.g),(v=m.m)?v.push(b):m.m=[b]),!0}function st(m,b){var v=void 0;return new(v||(v=Promise))(function(E,D){function U(z){try{V(b.next(z))}catch(q){D(q)}}function P(z){try{V(b.throw(z))}catch(q){D(q)}}function V(z){z.done?E(z.value):new v(function(q){q(z.value)}).then(U,P)}V((b=b.apply(m,void 0)).next())})}function Xr(m){Et.call(this,m)}g(Xr,Et);function pg(m,b){for(;ar(b);)switch(b.i){case 8:var v=Hr(b.g);Te(m,1,v);break;case 21:v=Gt(b.g),Te(m,2,v);break;case 26:v=Qa(b),Te(m,3,v);break;case 34:v=Qa(b),Te(m,4,v);break;default:if(!Kr(m,b))return m}return m}function Fo(m){Et.call(this,m,-1,dg)}g(Fo,Et),Fo.prototype.addClassification=function(m,b){return su(this,m,Xr,b),this};var dg=[1];function qr(m){Et.call(this,m)}g(qr,Et);function fg(m,b){for(;ar(b);)switch(b.i){case 13:var v=Gt(b.g);Te(m,1,v);break;case 21:v=Gt(b.g),Te(m,2,v);break;case 29:v=Gt(b.g),Te(m,3,v);break;case 37:v=Gt(b.g),Te(m,4,v);break;case 45:v=Gt(b.g),Te(m,5,v);break;default:if(!Kr(m,b))return m}return m}function au(m){Et.call(this,m,-1,mg)}g(au,Et);var mg=[1];function Do(m){Et.call(this,m)}g(Do,Et);function uu(m,b,v){if(v=m.createShader(v===0?m.VERTEX_SHADER:m.FRAGMENT_SHADER),m.shaderSource(v,b),m.compileShader(v),!m.getShaderParameter(v,m.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+m.getShaderInfoLog(v));return v}function gg(m){return Ao(m,Xr).map(function(b){return{index:ou(b,1),Y:en(b,2),label:Ve(b,3)!=null?iu(b,3):void 0,displayName:Ve(b,4)!=null?iu(b,4):void 0}})}function yg(m){return{x:en(m,1),y:en(m,2),z:en(m,3),visibility:Ve(m,4)!=null?en(m,4):void 0}}function Po(m){e:{var b=new au;for(m=new Rs(m);ar(m);)switch(m.i){case 10:var v=Ya(m,new qr,fg);su(b,v,qr,void 0);break;default:if(!Kr(b,m))break e}}return Ao(b,qr).map(yg)}function Lo(m,b){this.h=m,this.g=b,this.l=0}function lu(m,b,v){return xg(m,b),typeof m.g.canvas.transferToImageBitmap=="function"?Promise.resolve(m.g.canvas.transferToImageBitmap()):v?Promise.resolve(m.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(m.g.canvas):(m.i===void 0&&(m.i=document.createElement("canvas")),new Promise(function(E){m.i.height=m.g.canvas.height,m.i.width=m.g.canvas.width,m.i.getContext("2d",{}).drawImage(m.g.canvas,0,0,m.g.canvas.width,m.g.canvas.height),E(m.i)}))}function xg(m,b){var v=m.g;if(m.m===void 0){var E=uu(v,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),D=uu(v,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),U=v.createProgram();if(v.attachShader(U,E),v.attachShader(U,D),v.linkProgram(U),!v.getProgramParameter(U,v.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+v.getProgramInfoLog(U));E=m.m=U,v.useProgram(E),D=v.getUniformLocation(E,"sampler0"),m.j={I:v.getAttribLocation(E,"aVertex"),H:v.getAttribLocation(E,"aTex"),da:D},m.s=v.createBuffer(),v.bindBuffer(v.ARRAY_BUFFER,m.s),v.enableVertexAttribArray(m.j.I),v.vertexAttribPointer(m.j.I,2,v.FLOAT,!1,0,0),v.bufferData(v.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),v.STATIC_DRAW),v.bindBuffer(v.ARRAY_BUFFER,null),m.o=v.createBuffer(),v.bindBuffer(v.ARRAY_BUFFER,m.o),v.enableVertexAttribArray(m.j.H),v.vertexAttribPointer(m.j.H,2,v.FLOAT,!1,0,0),v.bufferData(v.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),v.STATIC_DRAW),v.bindBuffer(v.ARRAY_BUFFER,null),v.uniform1i(D,0)}E=m.j,v.useProgram(m.m),v.canvas.width=b.width,v.canvas.height=b.height,v.viewport(0,0,b.width,b.height),v.activeTexture(v.TEXTURE0),m.h.bindTexture2d(b.glName),v.enableVertexAttribArray(E.I),v.bindBuffer(v.ARRAY_BUFFER,m.s),v.vertexAttribPointer(E.I,2,v.FLOAT,!1,0,0),v.enableVertexAttribArray(E.H),v.bindBuffer(v.ARRAY_BUFFER,m.o),v.vertexAttribPointer(E.H,2,v.FLOAT,!1,0,0),v.bindFramebuffer(v.DRAW_FRAMEBUFFER?v.DRAW_FRAMEBUFFER:v.FRAMEBUFFER,null),v.clearColor(0,0,0,0),v.clear(v.COLOR_BUFFER_BIT),v.colorMask(!0,!0,!0,!0),v.drawArrays(v.TRIANGLE_FAN,0,4),v.disableVertexAttribArray(E.I),v.disableVertexAttribArray(E.H),v.bindBuffer(v.ARRAY_BUFFER,null),m.h.bindTexture2d(0)}function bg(m){this.g=m}var wg=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function vg(m,b){return b+m}function cu(m,b){window[m]=b}function $g(m){var b=document.createElement("script");return b.setAttribute("src",m),b.setAttribute("crossorigin","anonymous"),new Promise(function(v){b.addEventListener("load",function(){v()},!1),b.addEventListener("error",function(){v()},!1),document.body.appendChild(b)})}function Sg(){return st(this,function m(){return O(m,function(b){switch(b.g){case 1:return b.m=2,S(b,WebAssembly.instantiate(wg),4);case 4:b.g=3,b.m=0;break;case 2:return b.m=0,b.j=null,b.return(!1);case 3:return b.return(!0)}})})}function Bo(m){if(this.g=m,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=m&&m.locateFile||vg,typeof window=="object")var b=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location!="undefined")b=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=b,m.options){b=a(Object.keys(m.options));for(var v=b.next();!v.done;v=b.next()){v=v.value;var E=m.options[v].default;E!==void 0&&(this.j[v]=typeof E=="function"?E():E)}}}n=Bo.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Tg(m,b){return m.g.files===void 0?[]:typeof m.g.files=="function"?m.g.files(b):m.g.files}function Cg(m){return st(m,function b(){var v=this,E,D,U,P,V,z,q,re,Ce,he,oe;return O(b,function(Z){switch(Z.g){case 1:return E=v,v.R?(D=Tg(v,v.j),S(Z,Sg(),2)):Z.return();case 2:if(U=Z.h,typeof window=="object")return cu("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),cu("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),z=D.filter(function(se){return se.data!==void 0}),q=D.filter(function(se){return se.data===void 0}),re=Promise.all(z.map(function(se){var ce=As(E,se.url);if(se.path!==void 0){var fe=se.path;ce=ce.then(function(Ze){return E.overrideFile(fe,Ze),Promise.resolve(Ze)})}return ce})),Ce=Promise.all(q.map(function(se){return se.simd===void 0||se.simd&&U||!se.simd&&!U?$g(E.locateFile(se.url,E.S)):Promise.resolve()})).then(function(){return st(E,function se(){var ce,fe,Ze=this;return O(se,function(Ee){if(Ee.g==1)return ce=window.createMediapipeSolutionsWasm,fe=window.createMediapipeSolutionsPackedAssets,S(Ee,ce(fe),2);Ze.h=Ee.h,Ee.g=0})})}),he=function(){return st(E,function se(){var ce=this;return O(se,function(fe){return ce.g.graph&&ce.g.graph.url?fe=S(fe,As(ce,ce.g.graph.url),0):(fe.g=0,fe=void 0),fe})})}(),S(Z,Promise.all([Ce,re,he]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return P=D.filter(function(se){return se.simd===void 0||se.simd&&U||!se.simd&&!U}).map(function(se){return E.locateFile(se.url,E.S)}),importScripts.apply(null,u(P)),S(Z,createMediapipeSolutionsWasm(Module),6);case 6:v.h=Z.h,v.l=new OffscreenCanvas(1,1),v.h.canvas=v.l,V=v.h.GL.createContext(v.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext!="undefined"?2:1}),v.h.GL.makeContextCurrent(V),Z.g=4;break;case 7:if(v.l=document.createElement("canvas"),oe=v.l.getContext("webgl2",{}),!oe&&(oe=v.l.getContext("webgl",{}),!oe))return alert("Failed to create WebGL canvas context when passing video frame."),Z.return();v.D=oe,v.h.canvas=v.l,v.h.createContext(v.l,!0,!0,{});case 4:v.i=new v.h.SolutionWasm,v.R=!1,Z.g=0}})})}function Ng(m){return st(m,function b(){var v=this,E,D,U,P,V,z,q,re;return O(b,function(Ce){if(Ce.g==1){if(v.g.graph&&v.g.graph.url&&v.P===v.g.graph.url)return Ce.return();if(v.o=!0,!v.g.graph||!v.g.graph.url){Ce.g=2;return}return v.P=v.g.graph.url,S(Ce,As(v,v.g.graph.url),3)}for(Ce.g!=2&&(E=Ce.h,v.i.loadGraph(E)),D=a(Object.keys(v.B)),U=D.next();!U.done;U=D.next())P=U.value,v.i.overrideFile(P,v.B[P]);if(v.B={},v.g.listeners)for(V=a(v.g.listeners),z=V.next();!z.done;z=V.next())q=z.value,Rg(v,q);re=v.j,v.j={},v.setOptions(re),Ce.g=0})})}n.reset=function(){return st(this,function m(){var b=this;return O(m,function(v){b.i&&(b.i.reset(),b.m={},b.s={}),v.g=0})})},n.setOptions=function(m,b){var v=this;if(b=b||this.g.options){for(var E=[],D=[],U={},P=a(Object.keys(m)),V=P.next();!V.done;U={K:U.K,L:U.L},V=P.next()){var z=V.value;z in this.j&&this.j[z]===m[z]||(this.j[z]=m[z],V=b[z],V!==void 0&&(V.onChange&&(U.K=V.onChange,U.L=m[z],E.push(function(q){return function(){return st(v,function re(){var Ce,he=this;return O(re,function(oe){if(oe.g==1)return S(oe,q.K(q.L),2);Ce=oe.h,Ce===!0&&(he.o=!0),oe.g=0})})}}(U))),V.graphOptionXref&&(z={valueNumber:V.type===1?m[z]:0,valueBoolean:V.type===0?m[z]:!1,valueString:V.type===2?m[z]:""},V=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),V.graphOptionXref),z),D.push(V))))}(E.length!==0||D.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(D),this.u=(this.u===void 0?[]:this.u).concat(E))}};function Eg(m){return st(m,function b(){var v=this,E,D,U,P,V,z,q;return O(b,function(re){switch(re.g){case 1:if(!v.o)return re.return();if(!v.u){re.g=2;break}E=a(v.u),D=E.next();case 3:if(D.done){re.g=5;break}return U=D.value,S(re,U(),4);case 4:D=E.next(),re.g=3;break;case 5:v.u=void 0;case 2:if(v.A){for(P=new v.h.GraphOptionChangeRequestList,V=a(v.A),z=V.next();!z.done;z=V.next())q=z.value,P.push_back(q);v.i.changeOptions(P),P.delete(),v.A=void 0}v.o=!1,re.g=0}})})}n.initialize=function(){return st(this,function m(){var b=this;return O(m,function(v){return v.g==1?S(v,Cg(b),2):v.g!=3?S(v,Ng(b),3):S(v,Eg(b),0)})})};function As(m,b){return st(m,function v(){var E=this,D,U;return O(v,function(P){return b in E.F?P.return(E.F[b]):(D=E.locateFile(b,""),U=fetch(D).then(function(V){return V.arrayBuffer()}),E.F[b]=U,P.return(U))})})}n.overrideFile=function(m,b){this.i?this.i.overrideFile(m,b):this.B[m]=b},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(m,b){return st(this,function v(){var E=this,D,U,P,V,z,q,re,Ce,he;return O(v,function(oe){switch(oe.g){case 1:return E.g.inputs?(D=1e3*(b==null?performance.now():b),S(oe,E.C,2)):oe.return();case 2:return S(oe,E.initialize(),3);case 3:for(U=new E.h.PacketDataList,P=a(Object.keys(m)),V=P.next();!V.done;V=P.next())if(z=V.value,q=E.g.inputs[z]){e:{var Z=E,se=m[z];switch(q.type){case"video":var ce=Z.m[q.stream];if(ce||(ce=new Lo(Z.h,Z.D),Z.m[q.stream]=ce),Z=ce,Z.l===0&&(Z.l=Z.h.createTexture()),typeof HTMLVideoElement!="undefined"&&se instanceof HTMLVideoElement){var fe=se.videoWidth;ce=se.videoHeight}else typeof HTMLImageElement!="undefined"&&se instanceof HTMLImageElement?(fe=se.naturalWidth,ce=se.naturalHeight):(fe=se.width,ce=se.height);ce={glName:Z.l,width:fe,height:ce},fe=Z.g,fe.canvas.width=ce.width,fe.canvas.height=ce.height,fe.activeTexture(fe.TEXTURE0),Z.h.bindTexture2d(Z.l),fe.texImage2D(fe.TEXTURE_2D,0,fe.RGBA,fe.RGBA,fe.UNSIGNED_BYTE,se),Z.h.bindTexture2d(0),Z=ce;break e;case"detections":for(ce=Z.m[q.stream],ce||(ce=new bg(Z.h),Z.m[q.stream]=ce),Z=ce,Z.data||(Z.data=new Z.g.DetectionListData),Z.data.reset(se.length),ce=0;ce<se.length;++ce){fe=se[ce];var Ze=Z.data,Ee=Ze.setBoundingBox,pt=ce,Ue=fe.T,ae=new Do;Te(ae,1,Ue.Z),Te(ae,2,Ue.$),Te(ae,3,Ue.height),Te(ae,4,Ue.width),Te(ae,5,Ue.rotation),Te(ae,6,Ue.X);var ye=Ue=new Ro;Ht(ye,1,Ve(ae,1)),Ht(ye,2,Ve(ae,2)),Ht(ye,3,Ve(ae,3)),Ht(ye,4,Ve(ae,4)),Ht(ye,5,Ve(ae,5));var ve=Ve(ae,6);if(ve!=null&&ve!=null){gn(ye.g,48);var pe=ye.g,xe=ve;ve=0>xe,xe=Math.abs(xe);var le=xe>>>0;for(xe=Math.floor((xe-le)/4294967296),xe>>>=0,ve&&(xe=~xe>>>0,le=(~le>>>0)+1,4294967295<le&&(le=0,xe++,4294967295<xe&&(xe=0))),an=le,mn=xe,ve=an,le=mn;0<le||127<ve;)pe.push(ve&127|128),ve=(ve>>>7|le<<25)>>>0,le>>>=7;pe.push(ve)}if(Oo(ae,ye),Ue=_o(Ue),Ee.call(Ze,pt,Ue),fe.O)for(Ze=0;Ze<fe.O.length;++Ze)ae=fe.O[Ze],ye=!!ae.visibility,Ee=Z.data,pt=Ee.addNormalizedLandmark,Ue=ce,ae=Object.assign(Object.assign({},ae),{visibility:ye?ae.visibility:0}),ye=new qr,Te(ye,1,ae.x),Te(ye,2,ae.y),Te(ye,3,ae.z),ae.visibility&&Te(ye,4,ae.visibility),pe=ae=new Ro,Ht(pe,1,Ve(ye,1)),Ht(pe,2,Ve(ye,2)),Ht(pe,3,Ve(ye,3)),Ht(pe,4,Ve(ye,4)),Ht(pe,5,Ve(ye,5)),Oo(ye,pe),ae=_o(ae),pt.call(Ee,Ue,ae);if(fe.M)for(Ze=0;Ze<fe.M.length;++Ze){if(Ee=Z.data,pt=Ee.addClassification,Ue=ce,ae=fe.M[Ze],ye=new Xr,Te(ye,2,ae.Y),ae.index&&Te(ye,1,ae.index),ae.label&&Te(ye,3,ae.label),ae.displayName&&Te(ye,4,ae.displayName),pe=ae=new Ro,le=Ve(ye,1),le!=null&&le!=null)if(gn(pe.g,8),ve=pe.g,0<=le)gn(ve,le);else{for(xe=0;9>xe;xe++)ve.push(le&127|128),le>>=7;ve.push(1)}Ht(pe,2,Ve(ye,2)),ve=Ve(ye,3),ve!=null&&(ve=Fe(ve),gn(pe.g,26),gn(pe.g,ve.length),lr(pe,pe.g.end()),lr(pe,ve)),ve=Ve(ye,4),ve!=null&&(ve=Fe(ve),gn(pe.g,34),gn(pe.g,ve.length),lr(pe,pe.g.end()),lr(pe,ve)),Oo(ye,pe),ae=_o(ae),pt.call(Ee,Ue,ae)}}Z=Z.data;break e;default:Z={}}}switch(re=Z,Ce=q.stream,q.type){case"video":U.pushTexture2d(Object.assign(Object.assign({},re),{stream:Ce,timestamp:D}));break;case"detections":he=re,he.stream=Ce,he.timestamp=D,U.pushDetectionList(he);break;default:throw Error("Unknown input config type: '"+q.type+"'")}}return E.i.send(U),S(oe,E.C,4);case 4:U.delete(),oe.g=0}})})};function Ig(m,b,v){return st(m,function E(){var D,U,P,V,z,q,re=this,Ce,he,oe,Z,se,ce,fe,Ze;return O(E,function(Ee){switch(Ee.g){case 1:if(!v)return Ee.return(b);for(D={},U=0,P=a(Object.keys(v)),V=P.next();!V.done;V=P.next())z=V.value,q=v[z],typeof q!="string"&&q.type==="texture"&&b[q.stream]!==void 0&&++U;1<U&&(re.G=!1),Ce=a(Object.keys(v)),V=Ce.next();case 2:if(V.done){Ee.g=4;break}if(he=V.value,oe=v[he],typeof oe=="string")return fe=D,Ze=he,S(Ee,kg(re,he,b[oe]),14);if(Z=b[oe.stream],oe.type==="detection_list"){if(Z){for(var pt=Z.getRectList(),Ue=Z.getLandmarksList(),ae=Z.getClassificationsList(),ye=[],ve=0;ve<pt.size();++ve){var pe=pt.get(ve);e:{var xe=new Do;for(pe=new Rs(pe);ar(pe);)switch(pe.i){case 13:var le=Gt(pe.g);Te(xe,1,le);break;case 21:le=Gt(pe.g),Te(xe,2,le);break;case 29:le=Gt(pe.g),Te(xe,3,le);break;case 37:le=Gt(pe.g),Te(xe,4,le);break;case 45:le=Gt(pe.g),Te(xe,5,le);break;case 48:for(var Me=pe.g,qe=128,Vo=0,Fn=le=0;4>Fn&&128<=qe;Fn++)qe=Me.h[Me.g++],Vo|=(qe&127)<<7*Fn;if(128<=qe&&(qe=Me.h[Me.g++],Vo|=(qe&127)<<28,le|=(qe&127)>>4),128<=qe)for(Fn=0;5>Fn&&128<=qe;Fn++)qe=Me.h[Me.g++],le|=(qe&127)<<7*Fn+3;128>qe?(Me=Vo>>>0,qe=le>>>0,(le=qe&2147483648)&&(Me=~Me+1>>>0,qe=~qe>>>0,Me==0&&(qe=qe+1>>>0)),Me=4294967296*qe+(Me>>>0),le=le?-Me:Me):(Me.l=!0,le=void 0),Te(xe,6,le);break;default:if(!Kr(xe,pe))break e}}xe={Z:en(xe,1),$:en(xe,2),height:en(xe,3),width:en(xe,4),rotation:en(xe,5,0),X:ou(xe,6)},pe=Po(Ue.get(ve)),Me=ae.get(ve);e:for(le=new Fo,Me=new Rs(Me);ar(Me);)switch(Me.i){case 10:le.addClassification(Ya(Me,new Xr,pg));break;default:if(!Kr(le,Me))break e}xe={T:xe,O:pe,M:gg(le)},ye.push(xe)}pt=ye}else pt=[];D[he]=pt,Ee.g=7;break}if(oe.type==="proto_list"){if(Z){for(pt=Array(Z.size()),Ue=0;Ue<Z.size();Ue++)pt[Ue]=Z.get(Ue);Z.delete()}else pt=[];D[he]=pt,Ee.g=7;break}if(Z===void 0){Ee.g=3;break}if(oe.type==="float_list"){D[he]=Z,Ee.g=7;break}if(oe.type==="proto"){D[he]=Z,Ee.g=7;break}if(oe.type!=="texture")throw Error("Unknown output config type: '"+oe.type+"'");return se=re.s[he],se||(se=new Lo(re.h,re.D),re.s[he]=se),S(Ee,lu(se,Z,re.G),13);case 13:ce=Ee.h,D[he]=ce;case 7:oe.transform&&D[he]&&(D[he]=oe.transform(D[he])),Ee.g=3;break;case 14:fe[Ze]=Ee.h;case 3:V=Ce.next(),Ee.g=2;break;case 4:return Ee.return(D)}})})}function kg(m,b,v){return st(m,function E(){var D=this,U;return O(E,function(P){return typeof v=="number"||v instanceof Uint8Array||v instanceof D.h.Uint8BlobList?P.return(v):v instanceof D.h.Texture2dDataOut?(U=D.s[b],U||(U=new Lo(D.h,D.D),D.s[b]=U),P.return(lu(U,v,D.G))):P.return(void 0)})})}function Rg(m,b){for(var v=b.name||"$",E=[].concat(u(b.wants)),D=new m.h.StringList,U=a(b.wants),P=U.next();!P.done;P=U.next())D.push_back(P.value);U=m.h.PacketListener.implement({onResults:function(V){for(var z={},q=0;q<b.wants.length;++q)z[E[q]]=V.get(q);var re=m.listeners[v];re&&(m.C=Ig(m,z,b.outs).then(function(Ce){Ce=re(Ce);for(var he=0;he<b.wants.length;++he){var oe=z[E[he]];typeof oe=="object"&&oe.hasOwnProperty&&oe.hasOwnProperty("delete")&&oe.delete()}Ce&&(m.C=Ce)}))}}),m.i.attachMultiListener(D,U),D.delete()}n.onResults=function(m,b){this.listeners[b||"$"]=m},G("Solution",Bo),G("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function hu(m){switch(m===void 0&&(m=0),m){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function pu(m){var b=this;m=m||{},this.g=new Bo({locateFile:m.locateFile,files:function(v){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:hu(v.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Po},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Po},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(v){return st(b,function E(){var D,U,P=this,V;return O(E,function(z){return z.g==1?(D=hu(v),U="third_party/mediapipe/modules/pose_landmark/"+D,S(z,As(P.g,D),2)):(V=z.h,P.g.overrideFile(U,V),z.return(!0))})})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=pu.prototype,n.reset=function(){this.g.reset()},n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(m){this.g.onResults(m)},n.initialize=function(){return st(this,function m(){var b=this;return O(m,function(v){return S(v,b.g.initialize(),0)})})},n.send=function(m,b){return st(this,function v(){var E=this;return O(v,function(D){return S(D,E.g.send(m,b),0)})})},n.setOptions=function(m){this.g.setOptions(m)},G("Pose",pu),G("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),G("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),G("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),G("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),G("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),G("VERSION","0.4.1633558788")}).call(hn);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VO=L();VO.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var It;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(It||(It={}));var gl;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(gl||(gl={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MO={};function Um(n){return MO[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x(n,e,t,r,s){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd;if(o.type==="tensor")return ct(e.inputNames[o.inputIndexStart],t,r,s);if(o.type==="tensors")return e.inputNames.slice(a,u).map(p=>ct(p,t,r,s));const l=ct(e.inputNames.slice(a)[0],t,r,s),c=l.dataSync();return o.type==="number"?c[0]:fi(l.shape,c)}const i=e.attrParams[n];return i&&i.value}function ct(n,e,t,r){const[s,o]=gt(n);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=t.currentContextIds.find(a=>!!e[so(s,a)]);return i!==void 0?e[so(s,i)][o]:void 0}function UO(n,e,t){return e[so(n,t.currentContextId)]}function tn(n,e){const[t,r,s]=gt(n);return[so(t,e&&e.currentContextId),r,s]}function so(n,e){return e?`${n}-${e}`:n}function gt(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],r=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[t,s,r]}function js(n,e,t){let r=x("pad",n,e,t);if(r==="explicit"){r=x("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function un(n){return n.kept?n:jn(n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WO=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var zO=Object.freeze(Object.defineProperty({__proto__:null,json:WO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GO=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var HO=Object.freeze(Object.defineProperty({__proto__:null,json:GO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jO=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var KO=Object.freeze(Object.defineProperty({__proto__:null,json:jO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XO=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var qO=Object.freeze(Object.defineProperty({__proto__:null,json:XO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YO=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var QO=Object.freeze(Object.defineProperty({__proto__:null,json:YO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZO=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var JO=Object.freeze(Object.defineProperty({__proto__:null,json:ZO},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eF=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var tF=Object.freeze(Object.defineProperty({__proto__:null,json:eF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var rF=Object.freeze(Object.defineProperty({__proto__:null,json:nF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sF=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var oF=Object.freeze(Object.defineProperty({__proto__:null,json:sF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iF=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var aF=Object.freeze(Object.defineProperty({__proto__:null,json:iF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var lF=Object.freeze(Object.defineProperty({__proto__:null,json:uF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var hF=Object.freeze(Object.defineProperty({__proto__:null,json:cF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pF=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var dF=Object.freeze(Object.defineProperty({__proto__:null,json:pF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var mF=Object.freeze(Object.defineProperty({__proto__:null,json:fF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gF=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var yF=Object.freeze(Object.defineProperty({__proto__:null,json:gF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xF=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var bF=Object.freeze(Object.defineProperty({__proto__:null,json:xF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wF=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var vF=Object.freeze(Object.defineProperty({__proto__:null,json:wF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $F=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var SF=Object.freeze(Object.defineProperty({__proto__:null,json:$F},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TF=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var CF=Object.freeze(Object.defineProperty({__proto__:null,json:TF},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yl{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[zO,HO,KO,qO,QO,JO,tF,rF,oF,aF,lF,hF,dF,mF,yF,bF,vF,SF,CF],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?s.push(g[y.name]):y.op==="Const"?o.push(g[y.name]):(y.input==null||y.input.length===0)&&i.push(g[y.name]),g),{});let u=[];const l=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const p=Object.keys(a);p.forEach(g=>{const y=a[g];y.inputNames.forEach((w,$)=>{const[S,,T]=tn(w),N=a[S];if(N.outputs!=null){const k=N.outputs.indexOf(T);if(k!==-1){const R=`${S}:${k}`;y.inputNames[$]=R}}y.inputs.push(N),N.children.push(y)})}),Object.keys(h).length===0?p.forEach(g=>{const y=a[g];y.children.length===0&&l.push(y)}):Object.keys(h).forEach(g=>{const[y]=tn(g),w=a[y];w!=null&&(w.signatureKey=h[g],l.push(w))}),Object.keys(c).length>0?Object.keys(c).forEach(g=>{const[y]=tn(g),w=a[y];w&&(w.signatureKey=c[g],u.push(w))}):u=s;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const f={nodes:a,inputs:u,outputs:l,weights:o,placeholders:s,signature:t,functions:d};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=Um(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=Gi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Gi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=Qi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Qi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=ji(e.attr,o.tfName,o.defaultValue||0),a===void 0&&!!o.tfDeprecatedName&&(a=ji(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=Yi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Yi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=Hi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Hi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Ji(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Ji(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=qi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=qi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Zi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Zi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Ki(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Ki(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Xi(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=Xi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=xl(e.attr,o.tfName,o.defaultValue),a===void 0&&!!o.tfDeprecatedName&&(a=xl(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let o={};t!=null&&(o=t.reduce((h,p)=>(h[p.name]=this.mapNode(p),p.op==="Const"&&s.push(h[p.name]),h),{}));const i=[],a=[];e.signature.inputArg.forEach(h=>{const[p]=tn(h.name),d={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:za(h.type),type:"dtype"}},children:[]};d.signatureKey=h.name,i.push(d),o[p]=d}),Object.keys(o).forEach(h=>{const p=o[h];p.inputNames.forEach((d,f)=>{const[g,,y]=tn(d),w=o[g];if(w.outputs!=null){const $=w.outputs.indexOf(y);if($!==-1){const S=`${g}:${$}`;p.inputNames[f]=S}}p.inputs.push(w),w.children.push(p)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[p,d]=tn(l[h.name]),f=o[p];f!=null&&(f.defaultOutput=d,a.push(f))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function NF(n){const e=L().global;if(typeof e.atob!="undefined")return e.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Wm(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):NF(n);return e?t:t.toLowerCase()}function Gi(n,e,t,r=!1){const s=n[e];return s!=null?Wm(s.s,r):t}function Hi(n,e,t){const r=n[e];return r?r.b:t}function ji(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function za(n){switch(typeof n=="string"&&(n=It[n]),n){case It.DT_FLOAT:case It.DT_HALF:return"float32";case It.DT_INT32:case It.DT_INT64:case It.DT_INT8:case It.DT_UINT8:return"int32";case It.DT_BOOL:return"bool";case It.DT_DOUBLE:return"float32";case It.DT_STRING:return"string";default:return null}}function xl(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function Ki(n,e,t){const r=n[e];return r&&r.type?za(r.type):t}function Xi(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>za(s)):t}function zm(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function qi(n,e,t){const r=n[e];return r&&r.shape?zm(r.shape):t}function Yi(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function Qi(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(o=>Wm(o,r)):t}function Zi(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>zm(s)):t}function Ji(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EF{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return ct(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return ct(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return ji(this.node.rawAttrs,e,t);if(r.s!=null)return Gi(this.node.rawAttrs,e,t);if(r.b!=null)return Hi(this.node.rawAttrs,e,t);if(r.shape!=null)return qi(this.node.rawAttrs,e,t);if(r.type!=null)return Ki(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return Yi(this.node.rawAttrs,e,t);if(r.list.s!=null)return Qi(this.node.rawAttrs,e,t);if(r.list.shape!=null)return Zi(this.node.rawAttrs,e,t);if(r.list.b!=null)return Ji(this.node.rawAttrs,e,t);if(r.list.type!=null)return Xi(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=(n,e,t)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[ke(x("a",n,e,t),x("b",n,e,t))];case"AddN":return[qx(x("tensors",n,e,t))];case"FloorMod":case"Mod":return[vb(x("a",n,e,t),x("b",n,e,t))];case"Mul":return[ee(x("a",n,e,t),x("b",n,e,t))];case"RealDiv":case"Div":return[Ie(x("a",n,e,t),x("b",n,e,t))];case"DivNoNan":return[h1(x("a",n,e,t),x("b",n,e,t))];case"FloorDiv":return[Nd(x("a",n,e,t),x("b",n,e,t))];case"Sub":return[me(x("a",n,e,t),x("b",n,e,t))];case"Minimum":return[Ra(x("a",n,e,t),x("b",n,e,t))];case"Maximum":return[gb(x("a",n,e,t),x("b",n,e,t))];case"Pow":return[Pd(x("a",n,e,t),x("b",n,e,t))];case"SquaredDifference":return[af(x("a",n,e,t),x("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kF=(n,e,t)=>{switch(n.op){case"Abs":case"ComplexAbs":return[kt(x("x",n,e,t))];case"Acos":return[Hx(x("x",n,e,t))];case"Acosh":return[Kx(x("x",n,e,t))];case"Asin":return[s0(x("x",n,e,t))];case"Asinh":return[i0(x("x",n,e,t))];case"Atan":return[u0(x("x",n,e,t))];case"Atan2":return[c0(x("x",n,e,t),x("y",n,e,t))];case"Atanh":return[p0(x("x",n,e,t))];case"Ceil":return[P0(x("x",n,e,t))];case"Complex":return[En(x("real",n,e,t),x("imag",n,e,t))];case"Cos":return[K0(x("x",n,e,t))];case"Cosh":return[q0(x("x",n,e,t))];case"Elu":return[Fd(x("x",n,e,t))];case"Erf":return[g1(x("x",n,e,t))];case"Exp":return[pn(x("x",n,e,t))];case"Expm1":return[k1(x("x",n,e,t))];case"Floor":return[F1(x("x",n,e,t))];case"Log":return[us(x("x",n,e,t))];case"Log1p":return[Md(x("x",n,e,t))];case"Imag":return[po(x("x",n,e,t))];case"Neg":return[Or(x("x",n,e,t))];case"Reciprocal":return[zb(x("x",n,e,t))];case"Real":return[is(x("x",n,e,t))];case"Relu":return[go(x("x",n,e,t))];case"Round":return[rf(x("x",n,e,t))];case"Selu":return[Qb(x("x",n,e,t))];case"Sigmoid":return[vs(x("x",n,e,t))];case"Sin":return[rw(x("x",n,e,t))];case"Sign":return[tw(x("x",n,e,t))];case"Sinh":return[ow(x("x",n,e,t))];case"Softplus":return[Y1(x("x",n,e,t))];case"Sqrt":return[Pi(x("x",n,e,t))];case"Square":return[fo(x("x",n,e,t))];case"Tanh":return[N0(x("x",n,e,t))];case"Tan":return[$w(x("x",n,e,t))];case"ClipByValue":return[Rd(x("x",n,e,t),x("clipValueMin",n,e,t),x("clipValueMax",n,e,t))];case"Relu6":return[nf(x("x",n,e,t))];case"Rsqrt":return[qb(ct(n.inputNames[0],e,t))];case"Prod":return[Kd(x("x",n,e,t),x("axes",n,e,t))];case"LeakyRelu":return[Vd(x("x",n,e,t),x("alpha",n,e,t))];case"Prelu":return[jd(x("x",n,e,t),x("alpha",n,e,t))];case"IsNan":return[V1(ct(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rt(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){I(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];I(s<0||o<0||s===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function bl(n){return!(typeof n=="number"||n.some(e=>e<0))}function Zr(n,e,t){let r=ea(n,t);const s=!bl(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=ea(o.shape,r)}),!bl(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function ea(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RF{constructor(e,t,r,s,o,i,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=de(0),bn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Rt(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,bn(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return $n([],[0].concat(this.elementShape));const r=this.readMany(e);return Rt(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),dn(r,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return $n([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return Rt(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),bt(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,tr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:t.size/r,i=[];ie(()=>{t=W(t,[1,r,o]);for(let u=0;u<e.length;++u){const l=u===0?0:s[u-1],c=[0,l,0],h=[1,e[u],o];i[u]=W($e(t,c,h),this.elementShape)}return i});const a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zn{constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Rt(t,o.shape,"TensorList shape mismatch: "),bn(o)}),this.idTensor=de(0),this.maxNumElements=s,bn(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Zn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Rt(e,this.elementShape,"TensorList shape mismatch: ");const s=Zr(this.elementShape,this.tensors,e);return ie(()=>{const o=this.tensors.map(i=>W(i,s));return dn(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Zr(this.elementShape,this.tensors,e),s=this.tensors.pop();return Rt(s.shape,e,"TensorList shape mismatch: "),W(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Rt(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");bn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Zn([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Rt(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Zr(this.elementShape,this.tensors,t);return W(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Rt(this.elementShape,t.shape,"TensorList shape mismatch: "),bn(t),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Rt(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Zr(this.elementShape,this.tensors,r);return e.length===0?$n([],[0].concat(s)):ie(()=>{const o=e.map(i=>W(this.tensors[i],s));return dn(o,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Rt(this.elementShape,t,"TensorList shape mismatch: ");const r=Zr(this.elementShape,this.tensors,t);return this.size()===0?$n([],[0].concat(r)):ie(()=>{const s=this.tensors.map(o=>W(o,r));return bt(s,0)})}}function _F(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);Rt(s,e,"TensorList shape mismatch: ");const o=tr(n);return new Zn(o,e,r)}function AF(n,e,t){return new Zn([],n,e,t)}function OF(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Zn([],t,n.dtype,r),i=tr(n,0);return e.forEach((a,u)=>{o.setItem(a,i[u])}),o}function FF(n,e,t){let r=0;const s=e.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),i=ea(o,t),a=r===0?0:n.size/r,u=ie(()=>{const c=[];n=W(n,[1,r,a]);for(let h=0;h<e.length;++h){const p=h===0?0:s[h-1],d=[0,p,0],f=[1,e[h],a];c[h]=W($e(n,d,f),i)}return n.dispose(),c}),l=new Zn([],t,n.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=x("thenBranch",n,e,t),s=x("elseBranch",n,e,t),o=x("cond",n,e,t),i=x("args",n,e,t);return(await o.data())[0]?t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=x("body",n,e,t),s=x("cond",n,e,t),o=x("args",n,e,t),i=await t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),a=o.map(c=>c.id);let u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=o;for(;u[0];){const c=l;l=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const h=l.map(d=>d.id);c.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()});const p=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await p[0].data(),p.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&h.indexOf(d.id)===-1&&d.dispose()})}return l}case"LoopCond":{const r=x("pred",n,e,t);return[un(r)]}case"Switch":{const r=x("pred",n,e,t);let s=x("data",n,e,t);return s.kept||(s=un(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>ct(s,e,t)!==void 0);if(r){const s=ct(r,e,t);return[un(s)]}return}case"Enter":{const r=x("frameName",n,e,t),s=x("tensor",n,e,t);return t.enterFrame(r),[un(s)]}case"Exit":{const r=x("tensor",n,e,t);return t.exitFrame(),[un(r)]}case"NextIteration":{const r=x("tensor",n,e,t);return t.nextIteration(),[un(r)]}case"TensorArrayV3":{const r=x("size",n,e,t),s=x("dtype",n,e,t),o=x("elementShape",n,e,t),i=x("dynamicSize",n,e,t),a=x("clearAfterRead",n,e,t),u=x("identicalElementShapes",n,e,t),l=x("name",n,e,t),c=new RF(l,s,r,o,u,i,a);return t.addTensorArray(c),[c.idTensor,de(1)]}case"TensorArrayWriteV3":{const r=x("tensorArrayId",n,e,t),s=x("index",n,e,t),o=x("tensor",n,e,t),i=t.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=x("tensorArrayId",n,e,t),s=x("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=x("tensorArrayId",n,e,t),s=x("indices",n,e,t),o=x("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=x("tensorArrayId",n,e,t),s=x("indices",n,e,t),o=x("tensor",n,e,t),i=t.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=x("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),o=x("dtype",n,e,t);return[s.concat(o)]}case"TensorArraySplitV3":{const r=x("tensorArrayId",n,e,t),s=x("tensor",n,e,t),o=x("lengths",n,e,t),i=t.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=x("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[de(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=x("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=x("tensorListId",n,e,t),s=x("index",n,e,t),o=x("tensor",n,e,t),i=t.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=x("tensorListId",n,e,t),s=x("index",n,e,t),o=x("elementShape",n,e,t),i=x("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=x("indices",n,e,t),s=x("tensor",n,e,t),o=x("elementShape",n,e,t),i=x("numElements",n,e,t),a=OF(s,r,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=x("elementShape",n,e,t),s=x("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=x(o,n,e,t),a=AF(r,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListGather":{const r=x("tensorListId",n,e,t),s=x("indices",n,e,t),o=x("elementShape",n,e,t),i=x("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=x("tensorListId",n,e,t),s=x("elementShape",n,e,t),o=x("elementDType",n,e,t),i=x("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=x("tensor",n,e,t),s=x("elementShape",n,e,t),o=x("elementDType",n,e,t),i=_F(r,s,o);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=x("tensorListId",n,e,t),s=t.getTensorList(r.id),o=x("dtype",n,e,t),i=x("elementShape",n,e,t);return[s.concat(o,i)]}case"TensorListPushBack":{const r=x("tensorListId",n,e,t),s=x("tensor",n,e,t),o=t.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=x("tensorListId",n,e,t),s=x("elementShape",n,e,t),o=x("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=x("tensor",n,e,t),s=x("elementShape",n,e,t),o=x("lengths",n,e,t),i=FF(r,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=x("tensorListId",n,e,t),s=t.getTensorList(r.id);return[de(s.size(),"int32")]}case"TensorListResize":{const r=x("tensorListId",n,e,t),s=x("size",n,e,t),i=t.getTensorList(r.id).resize(s);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wl(n,e,t){const[r,s]=x("fusedOps",n,e,t),o=r==="biasadd",i=!o,a=s==="prelu",u=r==="fusedbatchnorm",l=x("numArgs",n,e,t);if(o){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=x("strides",n,e,t),h=js(n,e,t),p=x("dataFormat",n,e,t).toUpperCase(),d=x("dilations",n,e,t);let[f,g]=x("args",n,e,t);i&&(g=f,f=void 0);const y=x("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:p,dilations:d,biasArg:f,preluArg:g,activationFunc:s,leakyreluAlpha:y}}const PF=(n,e,t)=>{switch(n.op){case"Conv1D":{const r=x("stride",n,e,t),s=x("pad",n,e,t),o=x("dataFormat",n,e,t).toUpperCase(),i=x("dilation",n,e,t);return[M0(x("x",n,e,t),x("filter",n,e,t),r,s,o,i)]}case"Conv2D":{const r=x("strides",n,e,t),s=js(n,e,t),o=x("dataFormat",n,e,t).toUpperCase(),i=x("dilations",n,e,t);return[$a(x("x",n,e,t),x("filter",n,e,t),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=wl(n,e,t);return[Ww({x:x("x",n,e,t),filter:x("filter",n,e,t),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=wl(n,e,t);return[Xw({x:x("x",n,e,t),filter:x("filter",n,e,t),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=x("outputShape",n,e,t),s=x("strides",n,e,t),o=js(n,e,t);return[z0(x("x",n,e,t),x("filter",n,e,t),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=x("strides",n,e,t),s=js(n,e,t),o=x("dilations",n,e,t),i=x("dataFormat",n,e,t).toUpperCase();return[Ad(x("input",n,e,t),x("filter",n,e,t),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("dataFormat",n,e,t).toUpperCase(),i=x("dilations",n,e,t);return[H0(x("x",n,e,t),x("filter",n,e,t),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[b0(x("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[cb(x("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t),i=x("includeBatchInIndex",n,e,t),{result:a,indexes:u}=fb(x("x",n,e,t),[o[1],o[2]],[r[1],r[2]],s,i);return[a,u]}case"AvgPool3D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[v0(x("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("kernelSize",n,e,t);return[pb(x("x",n,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=x("strides",n,e,t),s=x("pad",n,e,t),o=x("dilations",n,e,t),i=r[1],a=r[2],u=o[1],l=o[2];return[i1(x("x",n,e,t),x("filter",n,e,t),[i,a],s,[u,l],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LF=(n,e,t)=>{switch(n.op){case"Fill":{const r=x("shape",n,e,t),s=x("dtype",n,e,t),o=x("value",n,e,t);return[Ea(r,o,s)]}case"LinSpace":{const r=x("start",n,e,t),s=x("stop",n,e,t),o=x("num",n,e,t);return[G1(r,s,o)]}case"Multinomial":{const r=x("logits",n,e,t),s=x("numSamples",n,e,t),o=x("seed",n,e,t);return[Sb(r,s,o)]}case"OneHot":{const r=x("indices",n,e,t),s=x("depth",n,e,t),o=x("onValue",n,e,t),i=x("offValue",n,e,t);return[Cx(r,s,o,i)]}case"Ones":return[ka(x("shape",n,e,t),x("dtype",n,e,t))];case"OnesLike":return[Nb(x("x",n,e,t))];case"RandomUniform":return[Ub(x("shape",n,e,t),x("minval",n,e,t),x("maxval",n,e,t),x("dtype",n,e,t))];case"Range":{const r=x("start",n,e,t),s=x("stop",n,e,t),o=x("step",n,e,t);return[ls(r,s,o,x("dtype",n,e,t))]}case"TruncatedNormal":{const r=x("shape",n,e,t),s=x("mean",n,e,t),o=x("stdDev",n,e,t),i=x("seed",n,e,t);return[Nw(r,s,o,x("dtype",n,e,t),i)]}case"Zeros":return[kn(x("shape",n,e,t),x("dtype",n,e,t))];case"ZerosLike":return[Sa(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jo(n,e,t){const r=x("boxes",n,e,t),s=x("scores",n,e,t),o=x("maxOutputSize",n,e,t),i=x("iouThreshold",n,e,t),a=x("scoreThreshold",n,e,t),u=x("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}const BF=async(n,e,t)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=Jo(n,e,t),l=await xt.nonMaxSuppressionWithScoreAsync(r,s,o,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a}=Jo(n,e,t),u=x("padToMaxOutputSize",n,e,t),l=await xt.nonMaxSuppressionPaddedAsync(r,s,o,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a}=Jo(n,e,t);return[await xt.nonMaxSuppressionAsync(r,s,o,i,a)]}case"Where":{const r=_e(x("condition",n,e,t),"bool"),s=[await _w(r)];return r.dispose(),s}case"ListDiff":return Jb(x("x",n,e,t),x("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VF=(n,e,t)=>{switch(n.op){case"LowerBound":{const r=x("sortedSequence",n,e,t),s=x("values",n,e,t);return[ub(r,s)]}case"TopKV2":{const r=x("x",n,e,t),s=x("k",n,e,t),o=x("sorted",n,e,t),i=Tw(r,s,o);return[i.values,i.indices]}case"UpperBound":{const r=x("sortedSequence",n,e,t),s=x("values",n,e,t);return[kw(r,s)]}case"Unique":{const r=x("x",n,e,t),s=Vu(r);return[s.values,s.indices]}case"UniqueV2":{const r=x("x",n,e,t),s=x("axis",n,e,t),o=Vu(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MF=(n,e,t)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const r=x("default",n,e,t);return[ct(n.name,e,t)||r];case"Placeholder":return[ct(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=x("x",n,e,t);return[un(l)]}case"IdentityN":return x("x",n,e,t).map(l=>un(l));case"Snapshot":const s=x("x",n,e,t);return[un(s)];case"Shape":return[nt(x("x",n,e,t).shape,"int32")];case"ShapeN":return x("x",n,e,t).map(l=>nt(l.shape));case"Size":return[de(x("x",n,e,t).size,"int32")];case"Rank":return[de(x("x",n,e,t).rank,"int32")];case"NoOp":return[de(1)];case"Print":const o=x("x",n,e,t),i=x("data",n,e,t),a=x("message",n,e,t),u=x("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UF{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=de(0),this.tensorMap=new Map,bn(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return de(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),ie(()=>{const s=tr(t),o=r.length,i=s.length;I(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const u=r[a],l=s[a];bn(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return ie(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,t);s.push(a)}return dn(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r!=null?r:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WF=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=x("keyDType",n,e,t),o=x("valueDType",n,e,t),i=new UF(s,o);return r.addHashTable(n.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=x("tableHandle",n,e,t,r),o=x("keys",n,e,t),i=x("values",n,e,t);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=x("tableHandle",n,e,t,r),o=x("keys",n,e,t),i=x("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=x("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zF=(n,e,t)=>{switch(n.op){case"ResizeBilinear":{const r=x("images",n,e,t),s=x("size",n,e,t),o=x("alignCorners",n,e,t),i=x("halfPixelCenters",n,e,t);return[xt.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=x("images",n,e,t),s=x("size",n,e,t),o=x("alignCorners",n,e,t),i=x("halfPixelCenters",n,e,t);return[xt.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=x("image",n,e,t),s=x("boxes",n,e,t),o=x("boxInd",n,e,t),i=x("cropSize",n,e,t),a=x("method",n,e,t),u=x("extrapolationValue",n,e,t);return[xt.cropAndResize(r,s,o,i,a,u)]}case"ImageProjectiveTransformV3":{const r=x("images",n,e,t),s=x("transforms",n,e,t),o=x("outputShape",n,e,t),i=x("fillValue",n,e,t),a=x("interpolation",n,e,t),u=x("fillMode",n,e,t);return[xt.transform(r,s,a.toLowerCase(),u.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GF=(n,e,t)=>{switch(n.op){case"Equal":return[Od(x("a",n,e,t),x("b",n,e,t))];case"NotEqual":return[Hd(x("a",n,e,t),x("b",n,e,t))];case"Greater":return[mo(x("a",n,e,t),x("b",n,e,t))];case"GreaterEqual":return[Bd(x("a",n,e,t),x("b",n,e,t))];case"Less":return[W1(x("a",n,e,t),x("b",n,e,t))];case"LessEqual":return[Ia(x("a",n,e,t),x("b",n,e,t))];case"LogicalAnd":return[Ud(x("a",n,e,t),x("b",n,e,t))];case"LogicalNot":return[sb(x("a",n,e,t))];case"LogicalOr":return[ib(x("a",n,e,t),x("b",n,e,t))];case"Select":case"SelectV2":return[Er(x("condition",n,e,t),x("a",n,e,t),x("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HF=(n,e,t)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ye(x("a",n,e,t),x("b",n,e,t),x("transposeA",n,e,t),x("transposeB",n,e,t))];case"Einsum":return[d1(x("equation",n,e,t),...x("tensors",n,e,t))];case"Transpose":return[Ai(x("x",n,e,t),x("perm",n,e,t))];case"_FusedMatMul":const[r,s]=x("fusedOps",n,e,t),o=r==="biasadd",i=s==="prelu",a=x("numArgs",n,e,t),u=x("leakyreluAlpha",n,e,t);if(o){if(i&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,c]=x("args",n,e,t);return[Yw({a:x("a",n,e,t),b:x("b",n,e,t),transposeA:x("transposeA",n,e,t),transposeB:x("transposeB",n,e,t),bias:l,activation:s,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=(n,e,t)=>{switch(n.op){case"EuclideanNorm":return[C1(x("x",n,e,t),x("axis",n,e,t),x("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[Lu(x("x",n,e,t),x("mean",n,e,t),x("variance",n,e,t),x("offset",n,e,t),x("scale",n,e,t),x("epsilon",n,e,t))];case"FusedBatchNormV3":return[Lu(x("x",n,e,t),x("mean",n,e,t),x("variance",n,e,t),x("offset",n,e,t),x("scale",n,e,t),x("epsilon",n,e,t))];case"LRN":return[j1(x("x",n,e,t),x("radius",n,e,t),x("bias",n,e,t),x("alpha",n,e,t),x("beta",n,e,t))];case"Softmax":return[aw(x("x",n,e,t))];case"LogSoftmax":return[J1(x("x",n,e,t))];case"SparseToDense":return[lf(x("sparseIndices",n,e,t),x("outputShape",n,e,t),x("sparseValues",n,e,t),x("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KF=(n,e,t)=>{switch(n.op){case"Max":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[wr(x("x",n,e,t),i,a)]}case"Mean":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[zd(x("x",n,e,t),i,a)]}case"Min":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[Di(x("x",n,e,t),i,a)]}case"Sum":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[De(x("x",n,e,t),i,a)]}case"All":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[Qx(x("x",n,e,t),i,a)]}case"Any":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[Jx(x("x",n,e,t),i,a)]}case"ArgMax":{const i=x("axis",n,e,t);return[Ed(x("x",n,e,t),i)]}case"ArgMin":{const i=x("axis",n,e,t);return[n0(x("x",n,e,t),i)]}case"Prod":{const i=x("axis",n,e,t),a=x("keepDims",n,e,t);return[Kd(x("x",n,e,t),i,a)]}case"Cumprod":{const i=x("axis",n,e,t),a=x("exclusive",n,e,t),u=x("reverse",n,e,t);return[Q0(x("x",n,e,t),i,a,u)]}case"Cumsum":{const i=x("axis",n,e,t),a=x("exclusive",n,e,t),u=x("reverse",n,e,t);return[J0(x("x",n,e,t),i,a,u)]}case"Bincount":const r=x("x",n,e,t),s=x("weights",n,e,t),o=x("size",n,e,t);return[kd(r,s,o)];case"DenseBincount":{const i=x("x",n,e,t),a=x("weights",n,e,t),u=x("size",n,e,t),l=x("binaryOutput",n,e,t);return[t1(i,a,u,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XF=(n,e,t)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=x("n",n,e,t),s=x("axis",n,e,t);let o=x("tensors",n,e,t);return o=o.slice(0,r),[bt(o,s)]}case"Gather":{const r=x("x",n,e,t),s=x("indices",n,e,t);return[Bu(r,_e(s,"int32"),0)]}case"GatherV2":{const r=x("axis",n,e,t),s=x("batchDims",n,e,t),o=x("x",n,e,t),i=x("indices",n,e,t);return[Bu(o,_e(i,"int32"),r,s)]}case"Reverse":{const r=x("dims",n,e,t),s=[];for(let i=0;i<r.length;i++)r[i]&&s.push(i);const o=x("x",n,e,t);return[eo(o,s)]}case"ReverseV2":{const r=x("axis",n,e,t),s=x("x",n,e,t);return[eo(s,r)]}case"Slice":{const r=x("begin",n,e,t),s=x("size",n,e,t);return[$e(x("x",n,e,t),r,s)]}case"StridedSlice":{const r=x("begin",n,e,t),s=x("end",n,e,t),o=x("strides",n,e,t),i=x("beginMask",n,e,t),a=x("endMask",n,e,t),u=x("ellipsisMask",n,e,t),l=x("newAxisMask",n,e,t),c=x("shrinkAxisMask",n,e,t),h=x("x",n,e,t);return[ww(h,r,s,o,i,a,u,l,c)]}case"Pack":return ie(()=>{const r=x("axis",n,e,t),s=x("tensors",n,e,t),o=s[0].shape,i=Ne(s[0]).shape,a=s.map(u=>{const l=ze(u.shape,o);if(!l&&!ze(Ne(u).shape,i))throw new Error("the input tensors shape does not match");return l?u:W(u,o)});return[dn(a,r)]});case"Unpack":{const r=x("axis",n,e,t),s=x("tensor",n,e,t);return tr(s,r)}case"Tile":{const r=x("reps",n,e,t);return[rs(x("x",n,e,t),r)]}case"Split":case"SplitV":{const r=x("axis",n,e,t),s=x("numOrSizeSplits",n,e,t),o=x("x",n,e,t);return cs(o,s,r)}case"ScatterNd":{const r=x("indices",n,e,t),s=x("values",n,e,t),o=x("shape",n,e,t);return[Ow(r,s,o)]}case"GatherNd":{const r=x("x",n,e,t),s=x("indices",n,e,t);return[Lw(r,s)]}case"SparseToDense":{const r=x("sparseIndices",n,e,t),s=x("outputShape",n,e,t),o=x("sparseValues",n,e,t),i=x("defaultValue",n,e,t);return[lf(r,o,s,o.dtype===i.dtype?i:_e(i,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qF=(n,e,t)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=Ds.sparseFillEmptyRows(x("indices",n,e,t),x("values",n,e,t),x("denseShape",n,e,t),x("defaultValue",n,e,t));return[r,s,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=Ds.sparseReshape(x("inputIndices",n,e,t),x("inputShape",n,e,t),x("newShape",n,e,t));return[r,s]}case"SparseSegmentMean":return[Ds.sparseSegmentMean(x("data",n,e,t),x("indices",n,e,t),x("segmentIds",n,e,t))];case"SparseSegmentSum":return[Ds.sparseSegmentSum(x("data",n,e,t),x("indices",n,e,t),x("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YF=(n,e,t)=>{switch(n.op){case"FFT":return[sf(x("x",n,e,t))];case"IFFT":return[Li(x("x",n,e,t))];case"RFFT":return[of(x("x",n,e,t))];case"IRFFT":return[hw(x("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QF=(n,e,t)=>{switch(n.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=Go.stringNGrams(x("data",n,e,t),x("dataSplits",n,e,t),x("separator",n,e,t),x("nGramWidths",n,e,t),x("leftPad",n,e,t),x("rightPad",n,e,t),x("padWidth",n,e,t),x("preserveShortSequences",n,e,t));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=Go.stringSplit(x("input",n,e,t),x("delimiter",n,e,t),x("skipEmpty",n,e,t));return[r,s,o]}case"StringToHashBucketFast":return[Go.stringToHashBucketFast(x("input",n,e,t),x("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZF=(n,e,t)=>{switch(n.op){case"Cast":return[_e(x("x",n,e,t),x("dtype",n,e,t))];case"ExpandDims":{const r=x("axis",n,e,t);return[_t(x("x",n,e,t),r)]}case"Squeeze":{const r=x("axis",n,e,t);return[Ne(x("x",n,e,t),r)]}case"Reshape":return[W(x("x",n,e,t),x("shape",n,e,t))];case"MirrorPad":return[Gd(x("x",n,e,t),x("padding",n,e,t),x("mode",n,e,t))];case"PadV2":case"Pad":return[Js(x("x",n,e,t),x("padding",n,e,t),x("constantValue",n,e,t))];case"SpaceToBatchND":{const r=x("blockShape",n,e,t),s=x("paddings",n,e,t);return[kb(x("x",n,e,t),r,s)]}case"BatchToSpaceND":{const r=x("blockShape",n,e,t),s=x("crops",n,e,t);return[I0(x("x",n,e,t),r,s)]}case"DepthToSpace":{const r=x("blockSize",n,e,t),s=x("dataFormat",n,e,t).toUpperCase();return[r1(x("x",n,e,t),r,s)]}case"BroadcastTo":return[Gs(x("x",n,e,t),x("shape",n,e,t))];case"BroadcastArgs":return[O0(x("s0",n,e,t),x("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vl(n,e,t,r){const s=((o,i,a)=>{switch(o.category){case"arithmetic":return ie(()=>IF(o,i,a));case"basic_math":return ie(()=>kF(o,i,a));case"control":return DF(o,i,a);case"convolution":return ie(()=>PF(o,i,a));case"creation":return ie(()=>LF(o,i,a));case"dynamic":return BF(o,i,a);case"evaluation":return ie(()=>VF(o,i,a));case"image":return ie(()=>zF(o,i,a));case"graph":return ie(()=>MF(o,i,a));case"logical":return ie(()=>GF(o,i,a));case"matrices":return ie(()=>HF(o,i,a));case"normalization":return ie(()=>jF(o,i,a));case"reduction":return ie(()=>KF(o,i,a));case"slice_join":return ie(()=>XF(o,i,a));case"sparse":return ie(()=>qF(o,i,a));case"spectral":return ie(()=>YF(o,i,a));case"string":return ie(()=>QF(o,i,a));case"transformation":return ie(()=>ZF(o,i,a));case"hash_table":return WF(o,i,a,r);case"custom":const u=Um(o.op);if(u&&u.customExecutor)return u.customExecutor(new EF(o,i,a));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Sr(s)?s.then(o=>[].concat(o)):[].concat(s)}class $l{constructor(e={},t={},r={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(n,e,t,r){const s=new Set,o=[];let i=null,a=null;const u=new Set,l=Object.keys(n).map(p=>gt(p)[0]);let c=[];r!=null&&(c=r.map(p=>gt(p.name)[0]));const h=[...e];for(;h.length>0;){const p=h.pop();if((Gm(p)||rD(p)||sD(p))&&i==null&&(i=p,a=i.children.map(d=>d.name).filter(d=>s.has(d))),s.add(p.name),t[p.name]==null&&l.indexOf(p.name)===-1&&c.indexOf(p.name)===-1){if(p.inputs.length===0){o.push(p.name);continue}p.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),h.push(d))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function JF(n,e,t){const{usedNodes:r,inputs:s}=t,o=[],i=Object.keys(s).map(c=>gt(c)[0]).map(c=>n.nodes[c]),a=n.initNodes;i.forEach(c=>{r.has(c.name)&&o.push(c)}),n.weights.forEach(c=>{r.has(c.name)&&o.push(c)}),a!=null&&a.forEach(c=>{r.has(c.name)&&o.push(c)});const u=new Set,l=[];for(;o.length>0;){const c=o.pop();u.add(c.name),e[c.name]||l.push(c),c.children.forEach(h=>{!u.has(h.name)&&r.has(h.name)&&h.inputs.every(p=>u.has(p.name))&&o.push(h)})}return l}const eD=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],tD=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],nD=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Gm(n){return eD.indexOf(n.op)>=0}function rD(n){return tD.indexOf(n.op)>=0}function sD(n){return nD.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oo{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new oo(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const r=e.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const r=Sl(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const a=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${s}]`)}return JF(this.graph,this.weightMap,r)}execute(e,t){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(h=>this.graph.nodes[gt(h)[0]]),o=t.map(h=>gt(h)[0]);let i=o.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);const a=this.getCompilationKey(s,i);let u=this.compiledMap.get(a);u==null&&(u=this.compile(e,i),this.compiledMap.set(a,u));const l={},c={};return ie(()=>{const h=new $l(this.weightMap,l,c,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(g=>{const[y,w]=gt(g),$=[];$[w]=e[g],p[y]=$});const d=this.getFrozenTensorIds(p),f={};for(let g=0;g<u.length;g++){const y=u[g];if(!p[y.name]){const w=vl(y,p,h,this._resourceManager);if(Sr(w))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=w,this.checkTensorForDisposal(y.name,y,p,h,d,o,f)}}return this.parent==null&&h.dispose(d),t.map(g=>ct(g,p,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,o,i,a){t.category==="control"||i.indexOf(e)!==-1||(r[e].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){const l=UO(u.name,r,s);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){const h=a[c.id];if(h===1){if(!this.keepTensorForDebug)c.dispose();else{const[p,d]=tn(t.name,s);this.intermediateTensors[p]?this.intermediateTensors[p][d]=c:(this.intermediateTensors[p]=[],this.intermediateTensors[p][d]=c)}delete a[c.id]}else h!=null&&a[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,r=!1,s={},o={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=L().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();const i=new $l(this.weightMap,s,o,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,i,t,r);const a=t.map(c=>ct(c,this.tensorsMap,i)),u=a.map(c=>c.id),l=Object.keys(e).map(c=>e[c].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(e,t,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const o=Object.keys(e),i=o.map(S=>this.graph.nodes[gt(S)[0]]),a=r.map(S=>gt(S)[0]);let u=a.map(S=>this.graph.nodes[S]);u.length===0&&(u=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:p}=Sl(e,u,this.weightMap,this._initNodes),d=[...i,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[T,N]=gt(S),k=[];k[N]=e[S],f[T]=k});const g={},y=this.getFrozenTensorIds(f),w={};for(;d.length>0;){const S=this.processStack(i,d,t,f,w,y,a,g,l);await Promise.all(S)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=u.filter(S=>!Gm(S)&&!ct(S.name,f,t)).map(S=>S.name);if($.length>0){let S="";throw h!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${S}`)}return f}processStack(e,t,r,s,o,i,a,u,l){const c=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let p="";if(h.node.op==="Enter"&&x("isConstant",h.node,s,r)&&([p]=tn(h.node.name,r)),s[h.node.name]==null){const d=vl(h.node,s,r,this._resourceManager);p||([p]=tn(h.node.name,r));const f=r.currentContext;Sr(d)?c.push(d.then(g=>(s[p]=g,r.currentContext=f,this.checkTensorForDisposal(p,h.node,s,r,i,a,u),this.processChildNodes(h.node,t,r,s,o,l),g))):(s[p]=d,this.checkTensorForDisposal(p,h.node,s,r,i,a,u),this.processChildNodes(h.node,t,r,s,o,l))}else this.processChildNodes(h.node,t,r,s,o,l)}return c}processChildNodes(e,t,r,s,o,i){e.children.forEach(a=>{const[u]=tn(a.name,r);o[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!ct(l,s,r))&&(o[u]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(l=>!!ct(l,s,r))&&(o[u]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=gt(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((u,l)=>i[l]===-1||i[l]===u);I(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&I(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const t={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const s=this._signature.inputs[r];t[s.name]=e[r]}else t[r]=e[r];return t}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=gt(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[r]=gt(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class oD{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iD="?tfjs-format=file",aD="model.json";class uD{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new oD}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Du(e,this.loadOptions);else{const t=qy(e,this.loadOptions);if(t.length===0)t.push(Du(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Sr(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?r=this.artifacts.userDefinedMetadata.signature:r=this.artifacts.signature,this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=Vy(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new oo(yl.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=yl.Instance.transformGraph(e.modelInitializer);this.initializer=new oo(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const r=Xy(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Xe)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,r,s)=>(t[r]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function _r(n,e={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=lD(n));const t=new uD(n,e);return await t.load(),t}function lD(n){return n.endsWith("/")||(n=n+"/"),`${n}${aD}${iD}`}/**
    * @license
    * Copyright 2022 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Hm=function(n,e){return(Hm=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])})(n,e)};function jm(n,e){function t(){this.constructor=n}Hm(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Re=function(){return(Re=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n}).apply(this,arguments)};function be(n,e,t,r){return new(t||(t=Promise))(function(s,o){function i(l){try{u(r.next(l))}catch(c){o(c)}}function a(l){try{u(r.throw(l))}catch(c){o(c)}}function u(l){var c;l.done?s(l.value):(c=l.value,c instanceof t?c:new t(function(h){h(c)})).then(i,a)}u((r=r.apply(n,e||[])).next())})}function we(n,e){var t,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(l){return function(c){if(t)throw new TypeError("Generator is already executing.");for(;i;)try{if(t=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,r=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){i.label=c[1];break}if(c[0]===6&&i.label<s[1]){i.label=s[1],s=c;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(c);break}s[2]&&i.ops.pop(),i.trys.pop();continue}c=e.call(n,i)}catch(h){c=[6,h],r=0}finally{t=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Gn(){for(var n=0,e=0,t=arguments.length;e<t;e++)n+=arguments[e].length;var r=Array(n),s=0;for(e=0;e<t;e++)for(var o=arguments[e],i=0,a=o.length;i<a;i++,s++)r[s]=o[i];return r}var sn=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],ms=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],cD={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},hD={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},pD=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],dD=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function io(n){return n instanceof SVGAnimatedLength?n.baseVal.value:n}function Km(n){return be(this,void 0,void 0,function(){var e,t;return we(this,function(r){switch(r.label){case 0:return e=document.createElement("canvas"),n instanceof Xe?[4,ya(n,e)]:[3,2];case 1:return r.sent(),[3,3];case 2:e.width=io(n.width),e.height=io(n.height),t=e.getContext("2d"),n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0),r.label=3;case 3:return[2,e]}})})}function Xm(n){return be(this,void 0,void 0,function(){var e,t,r,s,o,i;return we(this,function(a){switch(a.label){case 0:return n instanceof Xe?(e=n.shape.slice(0,2),t=e[0],r=e[1],s=ImageData.bind,[4,ya(n)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,a.sent(),r,t]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=io(n.width),o.height=io(n.height),i.drawImage(n,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function fD(n){return be(this,void 0,void 0,function(){var e,t;return we(this,function(r){switch(r.label){case 0:return n instanceof SVGImageElement||n instanceof OffscreenCanvas?[4,Km(n)]:[3,2];case 1:return t=r.sent(),[3,3];case 2:t=n,r.label=3;case 3:return e=t,[2,cd(e,4)]}})})}function qm(n){if(n<0||n>=256)throw new Error("Mask value must be in range [0, 255] but got "+n);if(!Number.isInteger(n))throw new Error("Mask value must be an integer but got "+n)}var Jr={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},mD=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,this.mask]})})},n.prototype.toImageData=function(){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,Xm(this.mask)]})})},n.prototype.toTensor=function(){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,fD(this.mask)]})})},n.prototype.getUnderlyingType=function(){return"canvasimagesource"},n}();function gD(n){return qm(n),"person"}var yD=function(){function n(e){var t,r=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new BO.Pose({locateFile:function(s,o){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:o+"/"+s}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,s.poseLandmarks==null)r.poses=[];else{var o=r.translateOutput(s.poseLandmarks,s.poseWorldLandmarks);s.segmentationMask&&(o.segmentation={maskValueToLabel:gD,mask:new mD(s.segmentationMask)}),r.poses=[o]}})}return n.prototype.translateOutput=function(e,t){var r=this,s={keypoints:e.map(function(o,i){return{x:o.x*r.width,y:o.y*r.height,z:o.z,score:o.visibility,name:ms[i]}})};return t!=null&&(s.keypoints3D=t.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:ms[i]}})),s},n.prototype.estimatePoses=function(e,t,r){return be(this,void 0,void 0,function(){var s,o;return we(this,function(i){switch(i.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Xe?(o=ImageData.bind,[4,ya(e)]):[3,2];case 1:return s=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},r)];case 4:return i.sent(),[2,this.poses]}})})},n.prototype.dispose=function(){this.poseSolution.close()},n.prototype.reset=function(){this.poseSolution.reset()},n.prototype.initialize=function(){return this.poseSolution.initialize()},n}();function xD(n){return be(this,void 0,void 0,function(){var e,t;return we(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return Re({},Jr);var o=Re({},s);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Jr.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Jr.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Jr.smoothSegmentation),o.modelType==null&&(o.modelType=Jr.modelType),o}(n),[4,(t=new yD(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function gs(n){return n instanceof Xe?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function Ym(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function Ga(n){return n instanceof Xe?n:cd(n)}function Qm(n,e,t){return ta(t,"inputResolution"),[1/t.width*n[0][0]*e.width,1/t.height*n[0][1]*e.width,n[0][3]*e.width,1/t.width*n[1][0]*e.height,1/t.height*n[1][1]*e.height,n[1][3]*e.height,0,0]}function ta(n,e){I(n.width!==0,function(){return e+" width cannot be 0."}),I(n.height!==0,function(){return e+" height cannot be 0."})}function ei(n,e,t){var r=t.rotationVectorStartKeypointIndex,s=t.rotationVectorEndKeypointIndex,o=n.locationData,i=o.relativeKeypoints[r].x*e.width,a=o.relativeKeypoints[r].y*e.height,u=o.relativeKeypoints[s].x*e.width,l=o.relativeKeypoints[s].y*e.height,c=2*Math.sqrt((u-i)*(u-i)+(l-a)*(l-a)),h=function(p,d,f){var g,y=p.locationData,w=f.rotationVectorStartKeypointIndex,$=f.rotationVectorEndKeypointIndex;g=f.rotationVectorTargetAngle?f.rotationVectorTargetAngle:Math.PI*f.rotationVectorTargetAngleDegree/180;var S=y.relativeKeypoints[w].x*d.width,T=y.relativeKeypoints[w].y*d.height,N=y.relativeKeypoints[$].x*d.width,k=y.relativeKeypoints[$].y*d.height;return Ym(g-Math.atan2(-(k-T),N-S))}(n,e,t);return{xCenter:i/e.width,yCenter:a/e.height,width:c/e.width,height:c/e.height,rotation:h}}function Zm(n){if(n.length!==16)throw new Error("Array length must be 16 but got "+n.length);return[[n[0],n[1],n[2],n[3]],[n[4],n[5],n[6],n[7]],[n[8],n[9],n[10],n[11]],[n[12],n[13],n[14],n[15]]]}function ti(n,e,t,r,s,o,i){return n[e][s]*(n[t][o]*n[r][i]-n[t][i]*n[r][o])}function ot(n,e,t){var r=(e+1)%4,s=(e+2)%4,o=(e+3)%4,i=(t+1)%4,a=(t+2)%4,u=(t+3)%4;return ti(n,r,s,o,i,a,u)+ti(n,s,o,r,i,a,u)+ti(n,o,r,s,i,a,u)}function Tl(n,e,t){t===void 0&&(t={ignoreRotation:!1});for(var r=[],s=0,o=n;s<o.length;s++){var i=o[s],a=i.x-.5,u=i.y-.5,l=t.ignoreRotation?0:e.rotation,c=Math.cos(l)*a-Math.sin(l)*u,h=Math.sin(l)*a+Math.cos(l)*u;c=c*e.width+e.xCenter,h=h*e.height+e.yCenter;var p=i.z*e.width,d=Re({},i);d.x=c,d.y=h,d.z=p,r.push(d)}return r}function Jm(n,e){var t=function(r,s,o,i){var a=s-r,u=i-o;if(a===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var l=u/a;return{scale:l,offset:o-r*l}}(0,255,e[0],e[1]);return ie(function(){return ke(ee(n,t.scale),t.offset)})}function na(n,e,t){var r,s,o,i,a,u,l,c,h,p,d,f,g,y,w=e.outputTensorSize,$=e.keepAspectRatio,S=e.borderMode,T=e.outputTensorFloatRange,N=gs(n),k=function(O,B){return B?{xCenter:B.xCenter*O.width,yCenter:B.yCenter*O.height,width:B.width*O.width,height:B.height*O.height,rotation:B.rotation}:{xCenter:.5*O.width,yCenter:.5*O.height,width:O.width,height:O.height,rotation:0}}(N,t),R=function(O,B,M){if(M===void 0&&(M=!1),!M)return{top:0,left:0,right:0,bottom:0};var H=B.height,G=B.width;ta(B,"targetSize"),ta(O,"roi");var Y,te,ne=H/G,ue=O.height/O.width,He=0,Fe=0;return ne>ue?(Y=O.width,te=O.width*ne,Fe=(1-ue/ne)/2):(Y=O.height/ne,te=O.height,He=(1-ne/ue)/2),O.width=Y,O.height=te,{top:Fe,left:He,right:He,bottom:Fe}}(k,w,$),F=(r=k,s=N.width,o=N.height,i=!1,a=r.width,u=r.height,l=i?-1:1,c=Math.cos(r.rotation),h=Math.sin(r.rotation),p=r.xCenter,d=r.yCenter,f=1/s,g=1/o,(y=new Array(16))[0]=a*c*l*f,y[1]=-u*h*f,y[2]=0,y[3]=(-.5*a*c*l+.5*u*h+p)*f,y[4]=a*h*l*g,y[5]=u*c*g,y[6]=0,y[7]=(-.5*u*c-.5*a*h*l+d)*g,y[8]=0,y[9]=0,y[10]=a*f,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,Zm(y));return{imageTensor:ie(function(){var O=Ga(n),B=qt(Qm(F,N,w),[1,8]),M=S==="zero"?"constant":"nearest",H=xt.transform(_t(_e(O,"float32")),B,"bilinear",M,0,[w.height,w.width]);return T!=null?Jm(H,T):H}),padding:R,transformationMatrix:F}}function Cl(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function bD(n){return ie(function(){var e=function(s){return ie(function(){return[$e(s,[0,0,0],[1,-1,1]),$e(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:Ne(r),logits:Ne(t)}})}function eg(n){return n!=null&&n.currentTime!=null}function Nl(n){for(var e={locationData:{relativeKeypoints:[]}},t=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<n.length;++i){var a=n[i];t=Math.min(t,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:t,yMin:s,xMax:r,yMax:o,width:r-t,height:o-s},e}function wD(n,e,t,r){return be(this,void 0,void 0,function(){var s,o,i,a,u;return we(this,function(l){switch(l.label){case 0:return n.sort(function(c,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,c.score)}),s=qt(n.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),o=nt(n.map(function(c){return c.score[0]})),[4,xt.nonMaxSuppressionAsync(s,o,e,t)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=n.filter(function(c,h){return a.indexOf(h)>-1}),it([s,o,i]),[2,u]}})})}function tg(n,e){return n.map(function(t){var r=Re(Re({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function vD(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,p,d,f,g,y,w,$,S,T,N,k,R,F,O,B;return we(this,function(M){switch(M.label){case 0:if(r=Ne(e,[0]),s=r.shape,o=s[0],i=s[1],a=s[2],n.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+n.length+", heatmap length: "+a);return u=[],[4,r.buffer()];case 1:for(l=M.sent(),c=0;c<n.length;c++)if(h=n[c],p=Re({},h),u.push(p),d=Math.trunc(p.x*i),f=Math.trunc(p.y*o),!(d<0||d>=i||f<0||d>=o)){for(g=Math.trunc((t.kernelSize-1)/2),y=Math.max(0,d-g),w=Math.min(i,d+g+1),$=Math.max(0,f-g),S=Math.min(o,f+g+1),T=0,N=0,k=0,R=0,F=$;F<S;++F)for(O=y;O<w;++O)B=l.get(F,O,c),T+=B,R=Math.max(R,B),N+=O*B,k+=F*B;R>=t.minConfidenceToRefine&&T>0&&(p.x=N/i/T,p.y=k/o/T)}return r.dispose(),[2,u]}})})}function El(n,e){var t=e.left,r=e.top,s=e.left+e.right,o=e.top+e.bottom;return n.map(function(i){return Re(Re({},i),{x:(i.x-t)/(1-s),y:(i.y-r)/(1-o),z:i.z/(1-s)})})}function $D(n,e,t){return Ys()==="webgl"?function(r,s,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:r.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `+i+`);

      setOutput(outputValue);
    }
`},u=Ex();return ie(function(){var l=u.compileAndRun(a,[r,s]);return Bn().makeTensorFromDataId(l.dataId,l.shape,l.dtype)})}(n,e,t):ie(function(){var r=me(e,.5),s=fo(r),o=me(1,Ra(1,ee(s,ke(5.68842,ee(s,ke(-.748699,ee(s,ke(-57.8051,ee(s,ke(291.309,ee(s,-624.717)))))))))));return ke(e,ee(me(n,e),ee(o,t.combineWithPreviousRatio)))})}function SD(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,i,a;return we(this,function(u){switch(u.label){case 0:return r=n[0],s=n[1],o=function(l,c,h){return ie(function(){var p,d,f,g;h.reverseOutputOrder?(d=Ne($e(l,[0,h.boxCoordOffset+0],[-1,1])),p=Ne($e(l,[0,h.boxCoordOffset+1],[-1,1])),g=Ne($e(l,[0,h.boxCoordOffset+2],[-1,1])),f=Ne($e(l,[0,h.boxCoordOffset+3],[-1,1]))):(p=Ne($e(l,[0,h.boxCoordOffset+0],[-1,1])),d=Ne($e(l,[0,h.boxCoordOffset+1],[-1,1])),f=Ne($e(l,[0,h.boxCoordOffset+2],[-1,1])),g=Ne($e(l,[0,h.boxCoordOffset+3],[-1,1]))),d=ke(ee(Ie(d,h.xScale),c.w),c.x),p=ke(ee(Ie(p,h.yScale),c.h),c.y),h.applyExponentialOnBoxSize?(f=ee(pn(Ie(f,h.hScale)),c.h),g=ee(pn(Ie(g,h.wScale)),c.w)):(f=ee(Ie(f,h.hScale),c.h),g=ee(Ie(g,h.wScale),c.h));var y=me(p,Ie(f,2)),w=me(d,Ie(g,2)),$=ke(p,Ie(f,2)),S=ke(d,Ie(g,2)),T=bt([W(y,[h.numBoxes,1]),W(w,[h.numBoxes,1]),W($,[h.numBoxes,1]),W(S,[h.numBoxes,1])],1);if(h.numKeypoints)for(var N=0;N<h.numKeypoints;++N){var k=h.keypointCoordOffset+N*h.numValuesPerKeypoint,R=void 0,F=void 0;h.reverseOutputOrder?(R=Ne($e(l,[0,k],[-1,1])),F=Ne($e(l,[0,k+1],[-1,1]))):(F=Ne($e(l,[0,k],[-1,1])),R=Ne($e(l,[0,k+1],[-1,1])));var O=ke(ee(Ie(R,h.xScale),c.w),c.x),B=ke(ee(Ie(F,h.yScale),c.h),c.y);T=bt([T,W(O,[h.numBoxes,1]),W(B,[h.numBoxes,1])],1)}return T})}(s,e,t),i=ie(function(){var l=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(l=Rd(r,-t.scoreClippingThresh,t.scoreClippingThresh)),l=vs(l)):l}),[4,TD(o,i,t)];case 1:return a=u.sent(),it([o,i]),[2,a]}})})}function TD(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,p,d,f;return we(this,function(g){switch(g.label){case 0:return r=[],[4,n.data()];case 1:return s=g.sent(),[4,e.data()];case 2:for(o=g.sent(),i=0;i<t.numBoxes;++i)if(!(t.minScoreThresh!=null&&o[i]<t.minScoreThresh||(a=i*t.numCoords,u=CD(s[a+0],s[a+1],s[a+2],s[a+3],o[i],t.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(t.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],h=t.numKeypoints*t.numValuesPerKeypoint,p=0;p<h;p+=t.numValuesPerKeypoint)d=a+t.keypointCoordOffset+p,f={x:s[d+0],y:t.flipVertically?1-s[d+1]:s[d+1]},c.relativeKeypoints.push(f);r.push(u)}return[2,r]}})})}function CD(n,e,t,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-t:n,xMax:r,yMax:o?1-n:t,width:r-e,height:t-n}}}}function ND(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Il(n,e,t,r){return be(this,void 0,void 0,function(){var s,o,i,a,u,l,c,h;return we(this,function(p){switch(p.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,o=s/e.numLandmarks,[4,n.data()];case 1:for(i=p.sent(),a=[],u=0;u<e.numLandmarks;++u)l=u*o,(h={x:0,y:0}).x=t?e.inputImageWidth-i[l]:i[l],o>1&&(h.y=r?e.inputImageHeight-i[l+1]:i[l+1]),o>2&&(h.z=i[l+2]),o>3&&(h.score=ND(e.visibilityActivation,i[l+3])),a.push(h);for(c=0;c<a.length;++c)(h=a[c]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function kl(n,e,t){var r=n.width,s=n.height,o=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(o=function(c,h){return h.rotation!=null?c+=h.rotation:h.rotationDegree!=null&&(c+=Math.PI*h.rotationDegree/180),Ym(c)}(o,t)),o===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var i=(e.width*r*t.shiftX*Math.cos(o)-e.height*s*t.shiftY*Math.sin(o))/e.width,a=(e.width*r*t.shiftX*Math.sin(o)+e.height*s*t.shiftY*Math.cos(o))/e.height;n.xCenter=n.xCenter+i,n.yCenter=n.yCenter+a}if(t.squareLong){var u=Math.max(r*e.width,s*e.height);r=u/e.width,s=u/e.height}else if(t.squareShort){var l=Math.min(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function ED(n,e){return n.map(function(t){var r=Re(Re({},t),{x:t.x/e.width,y:t.y/e.height});return t.z!=null&&(t.z=t.z/e.width),r})}var wn=function(){function n(e){this.alpha=e,this.initialized=!1}return n.prototype.apply=function(e,t){var r;return this.initialized?r=t==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(r=e,this.initialized=!0),this.rawValue=e,this.storedValue=r,r},n.prototype.applyWithAlpha=function(e,t,r){return this.alpha=t,this.apply(e,r)},n.prototype.hasLastRawValue=function(){return this.initialized},n.prototype.lastRawValue=function(){return this.rawValue},n.prototype.reset=function(){this.initialized=!1},n}(),ni=function(){function n(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new wn(this.getAlpha(this.minCutOff)),this.dx=new wn(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s=Math.trunc(t);if(this.lastTimestamp>=s)return e;this.lastTimestamp!==0&&s!==0&&(this.frequency=1/(1e-6*(s-this.lastTimestamp))),this.lastTimestamp=s;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*r*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),u)},n.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},n}(),ra=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Gn(e);o=1/r}return e.map(function(i,a){var u=Re(Re({},i),{x:s.xFilters[a].apply(i.x,t,o),y:s.yFilters[a].apply(i.y,t,o)});return i.z!=null&&(u.z=s.zFilters[a].apply(i.z,t,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new ni(t.config)}),this.yFilters=e.map(function(r){return new ni(t.config)}),this.zFilters=e.map(function(r){return new ni(t.config)}))},n}(),ri=function(){function n(e){this.config=e,this.window=[],this.lowPassFilter=new wn(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return n.prototype.apply=function(e,t,r){if(e==null)return e;var s,o=Math.trunc(t);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)s=1;else{for(var i=e*r-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,u=i,l=a,c=(1+this.window.length)*(1e6/30),h=0,p=this.window;h<p.length;h++){var d=p[h];if(l+d.duration>c)break;u+=d.distance,l+=d.duration}var f=u/(1e-6*l);s=1-1/(1+this.config.velocityScale*Math.abs(f)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=r,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,s)},n}(),ID=function(){function n(e){this.config=e}return n.prototype.apply=function(e,t,r){var s=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(r<this.config.minAllowedObjectScale)return Gn(e);o=1/r}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var u=Re(Re({},i),{x:s.xFilters[a].apply(i.x,t,o),y:s.yFilters[a].apply(i.y,t,o)});return i.z!=null&&(u.z=s.zFilters[a].apply(i.z,t,o)),u})},n.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},n.prototype.initializeFiltersIfEmpty=function(e){var t=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(r){return new ri(t.config)}),this.yFilters=e.map(function(r){return new ri(t.config)}),this.zFilters=e.map(function(r){return new ri(t.config)}))},n}(),si=function(){function n(e){if(e.velocityFilter!=null)this.keypointsFilter=new ID(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new ra(e.oneEuroFilter)}}return n.prototype.apply=function(e,t,r,s,o){if(s===void 0&&(s=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(l,c){return(l.width*c.width+l.height*c.height)/2}(o,r):1,a=s?tg(e,r):e,u=this.keypointsFilter.apply(a,t,i);return s?ED(u,r):u},n}(),Rl=function(){function n(e){this.alpha=e.alpha}return n.prototype.apply=function(e){var t=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new wn(t.alpha)}));for(var r=[],s=0;s<e.length;++s){var o=e[s],i=Re({},o);i.score=this.visibilityFilters[s].apply(o.score),r.push(i)}return r},n}(),kD={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},dr={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},RD={maxPoses:1,flipHorizontal:!1},_D={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},AD=.3,_l={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},OD={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},FD={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},DD={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},PD={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},LD={kernelSize:7,minConfidenceToRefine:.5},Al={alpha:.1},BD={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},VD={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},MD={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},UD={activation:"none"},WD={combineWithPreviousRatio:.7},zD=function(){function n(e){this.mask=e}return n.prototype.toCanvasImageSource=function(){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,Km(this.mask)]})})},n.prototype.toImageData=function(){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,Xm(this.mask)]})})},n.prototype.toTensor=function(){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,this.mask]})})},n.prototype.getUnderlyingType=function(){return"tensor"},n}();function GD(n){return qm(n),"person"}var HD=function(){function n(e,t,r,s,o,i){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=r,this.enableSegmentation=s,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var p=[],d=0;d<h.numLayers;){for(var f=[],g=[],y=[],w=[],$=d;$<h.strides.length&&h.strides[$]===h.strides[d];){var S=Cl(h.minScale,h.maxScale,$,h.strides.length);if($===0&&h.reduceBoxesInLowestLayer)y.push(1),y.push(2),y.push(.5),w.push(.1),w.push(S),w.push(S);else{for(var T=0;T<h.aspectRatios.length;++T)y.push(h.aspectRatios[T]),w.push(S);if(h.interpolatedScaleAspectRatio>0){var N=$===h.strides.length-1?1:Cl(h.minScale,h.maxScale,$+1,h.strides.length);w.push(Math.sqrt(S*N)),y.push(h.interpolatedScaleAspectRatio)}}$++}for(var k=0;k<y.length;++k){var R=Math.sqrt(y[k]);f.push(w[k]/R),g.push(w[k]*R)}var F=0,O=0;if(h.featureMapHeight.length>0)F=h.featureMapHeight[d],O=h.featureMapWidth[d];else{var B=h.strides[d];F=Math.ceil(h.inputSizeHeight/B),O=Math.ceil(h.inputSizeWidth/B)}for(var M=0;M<F;++M)for(var H=0;H<O;++H)for(var G=0;G<f.length;++G){var Y={xCenter:(H+h.anchorOffsetX)/O,yCenter:(M+h.anchorOffsetY)/F,width:0,height:0};h.fixedAnchorSize?(Y.width=1,Y.height=1):(Y.width=g[G],Y.height=f[G]),p.push(Y)}d=$}return p}(kD);var a=nt(this.anchors.map(function(h){return h.width})),u=nt(this.anchors.map(function(h){return h.height})),l=nt(this.anchors.map(function(h){return h.xCenter})),c=nt(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:l,y:c,w:a,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?qt([],[0,0]):null}return n.prototype.estimatePoses=function(e,t,r){return be(this,void 0,void 0,function(){var s,o,i,a,u,l,c,h,p,d,f,g,y,w,$,S,T,N,k,R,F,O,B;return we(this,function(M){switch(M.label){case 0:return s=function(H){var G;if((G=H==null?RD:Re({},H)).maxPoses==null&&(G.maxPoses=1),G.maxPoses<=0)throw new Error("Invalid maxPoses "+G.maxPoses+". Should be > 0.");if(G.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return G}(t),e==null?(this.reset(),[2,[]]):(this.maxPoses=s.maxPoses,this.timestamp=r!=null?1e3*r:eg(e)?1e6*e.currentTime:null,o=gs(e),i=ie(function(){return _e(Ga(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((u=M.sent()).length===0)return this.reset(),i.dispose(),[2,[]];l=u[0],a=this.poseDetectionToRoi(l,o),M.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return c=M.sent(),i.dispose(),c==null?(this.reset(),[2,[]]):(h=c.landmarks,p=c.auxiliaryLandmarks,d=c.poseScore,f=c.worldLandmarks,g=c.segmentationMask,y=this.poseLandmarkFiltering(h,p,f,o),w=y.actualLandmarksFiltered,$=y.auxiliaryLandmarksFiltered,S=y.actualWorldLandmarksFiltered,T=this.poseLandmarksToRoi($,o),this.regionOfInterest=T,N=this.smoothSegmentation&&g!=null?this.poseSegmentationFiltering(g):g,(k=w!=null?tg(w,o):null)!=null&&k.forEach(function(H,G){H.name=ms[G]}),(R=S)!=null&&R.forEach(function(H,G){H.name=ms[G]}),F={score:d,keypoints:k,keypoints3D:R},N!==null&&(O=ie(function(){var H=_t(N,2),G=Js(H,[[0,0],[0,0],[0,1]]);return Gd(G,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||it(N),B={maskValueToLabel:GD,mask:new zD(O)},F.segmentation=B),[2,[F]])}})})},n.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return t.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=$D(t,e,WD),it(e)),it(t),this.prevFilteredSegmentationMask},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),it([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},n.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(it(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=qt([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},n.prototype.detectPose=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,i,a,u,l,c,h;return we(this,function(p){switch(p.label){case 0:return t=na(e,OD),r=t.imageTensor,s=t.padding,o=this.detectorModel.predict(r),i=bD(o),a=i.boxes,[4,SD([u=i.logits,a],this.anchorTensor,_D)];case 1:return(l=p.sent()).length===0?(it([r,o,u,a]),[2,l]):[4,wD(l,this.maxPoses,AD)];case 2:return c=p.sent(),h=function(d,f){d===void 0&&(d=[]);for(var g=f.left,y=f.top,w=f.left+f.right,$=f.top+f.bottom,S=0;S<d.length;S++){var T=d[S],N=T.locationData.relativeBoundingBox,k=(N.xMin-g)/(1-w),R=(N.yMin-y)/(1-$),F=N.width/(1-w),O=N.height/(1-$);N.xMin=k,N.yMin=R,N.width=F,N.height=O,N.xMax=k+F,N.yMax=R+O;var B=T.locationData.relativeKeypoints;B&&B.forEach(function(M){var H=(M.x-g)/(1-w),G=(M.y-y)/(1-$);M.x=H,M.y=G})}return d}(c,s),it([r,o,u,a]),[2,h]}})})},n.prototype.poseDetectionToRoi=function(e,t){return kl(ei(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,_l)},n.prototype.poseLandmarksByRoi=function(e,t){return be(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,p,d,f,g,y;return we(this,function(w){switch(w.label){case 0:if(r=gs(t),s=na(t,FD,e),o=s.imageTensor,i=s.padding,a=s.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType);return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),l=this.landmarkModel.execute(o,u),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return(c=w.sent())==null?(it(l),it(o),[2,null]):(h=c.landmarks,p=c.auxiliaryLandmarks,d=c.poseScore,f=c.worldLandmarks,g=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(r,e,i,a,h,p,f,g)]);case 2:return y=w.sent(),it(l),it(o),[2,Re({poseScore:d},y)]}})})},n.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,r,s,o,i,a,u){return be(this,void 0,void 0,function(){var l,c,h,p,d,f;return we(this,function(g){return l=El(o,r),c=El(i,r),h=Tl(l,t),p=Tl(c,t),d=function(y,w){for(var $=[],S=0,T=y;S<T.length;S++){var N=T[S],k=N.x,R=N.y,F=w.rotation,O=Math.cos(F)*k-Math.sin(F)*R,B=Math.sin(F)*k+Math.cos(F)*R,M=Re({},N);M.x=O,M.y=B,$.push(M)}return $}(a,t),f=null,this.enableSegmentation&&(f=ie(function(){var y=u.shape,w=y[0],$=y[1],S=function(k){var R=Zm(new Array(16).fill(0));R[0][0]=ot(k,0,0),R[1][0]=-ot(k,0,1),R[2][0]=ot(k,0,2),R[3][0]=-ot(k,0,3),R[0][2]=ot(k,2,0),R[1][2]=-ot(k,2,1),R[2][2]=ot(k,2,2),R[3][2]=-ot(k,2,3),R[0][1]=-ot(k,1,0),R[1][1]=ot(k,1,1),R[2][1]=-ot(k,1,2),R[3][1]=ot(k,1,3),R[0][3]=-ot(k,3,0),R[1][3]=ot(k,3,1),R[2][3]=-ot(k,3,2),R[3][3]=ot(k,3,3);for(var F=k[0][0]*R[0][0]+k[1][0]*R[0][1]+k[2][0]*R[0][2]+k[3][0]*R[0][3],O=0;O<R.length;O++)for(var B=0;B<R.length;B++)R[O][B]/=F;return R}(s),T=qt(Qm(S,{width:$,height:w},e),[1,8]),N=[1,w,$,1];return Ne(xt.transform(W(u,N),T,"bilinear","constant",0,[e.height,e.width]),[0,3])}),it(u)),[2,{landmarks:h,auxiliaryLandmarks:p,worldLandmarks:d,segmentationMask:f}]})})},n.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,i,a,u,l,c,h,p,d,f;return we(this,function(g){switch(g.label){case 0:return t=e[0],r=e[1],s=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,r.data()];case 1:return(a=g.sent()[0])<.5?[2,null]:[4,Il(t,DD)];case 2:return[4,vD(g.sent(),s,LD)];case 3:return u=g.sent(),l=u.slice(0,33),c=u.slice(33,35),[4,Il(o,PD)];case 4:return h=g.sent(),p=h.slice(0,33),d=function(y,w,$){$===void 0&&($=!0);for(var S=[],T=0;T<y.length;T++){var N=Re({},w[T]);$&&(N.score=y[T].score),S.push(N)}return S}(l,p,!0),f=this.enableSegmentation?function(y,w,$){return ie(function(){var S=Ne(y,[0]),T=S.shape[2];if(T===1){var N=S;switch(w.activation){case"none":break;case"sigmoid":N=vs(N);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported ("+w.activation+")")}var k=$?xt.resizeBilinear(N,[$.height,$.width]):N;return Ne(k,[2])}throw new Error("Unsupported number of tensor channels "+T)})}(i,UD):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:d,segmentationMask:f}]}})})},n.prototype.poseLandmarksToRoi=function(e,t){return kl(ei(Nl(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,_l)},n.prototype.poseLandmarkFiltering=function(e,t,r,s){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var u=ei(Nl(t),s,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new Rl(Al)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new Rl(Al)),i=this.visibilitySmoothingFilterAuxiliary.apply(t),a=this.visibilitySmoothingFilterActual.apply(r),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new si(BD)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,s,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new si(VD)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,s,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new si(MD)),a=this.worldLandmarksSmoothingFilterActual.apply(r,this.timestamp)}else o=e,i=t,a=r;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},n}();function jD(n){return be(this,void 0,void 0,function(){var e,t,r,s,o,i;return we(this,function(a){switch(a.label){case 0:return e=function(u){var l=Re({},u==null?dr:u);if(l.enableSmoothing==null&&(l.enableSmoothing=dr.enableSmoothing),l.enableSegmentation==null&&(l.enableSegmentation=dr.enableSegmentation),l.smoothSegmentation==null&&(l.smoothSegmentation=dr.smoothSegmentation),l.modelType==null&&(l.modelType=dr.modelType),l.detectorModelUrl==null&&(l.detectorModelUrl=dr.detectorModelUrl),l.landmarkModelUrl==null)switch(l.modelType){case"lite":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return l}(n),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([_r(e.detectorModelUrl,{fromTFHub:t}),_r(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new HD(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Sn,dt,ng=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but encountered "+t.maxTracks);if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but encountered "+t.maxAge);if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+t.keypointTrackerParams.keypointConfidenceThreshold);if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but encountered "+t.keypointTrackerParams.minNumberOfKeypoints);for(var r=0,s=t.keypointTrackerParams.keypointFalloff;r<s.length;r++){var o=s[r];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive but encountered "+o)}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var r=this.computeSimilarity(e);return this.assignTracks(e,r,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(r){return e-r.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,r){for(var s=Array.from(Array(t[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var u=a[i];if(s.length!==0){for(var l=-1,c=-1,h=0,p=s;h<p.length;h++){var d=p[h],f=t[u][d];f>=this.minSimilarity&&f>c&&(l=d,c=f)}if(l>=0){var g=this.tracks[l];g=Object.assign(g,this.createTrack(e[u],r,g.id)),e[u].id=g.id;var y=s.indexOf(l);s.splice(y,1)}else o.push(u)}else o.push(u)}for(var w=0,$=o;w<$.length;w++){u=$[w];var S=this.createTrack(e[u],r);this.tracks.push(S),e[u].id=S.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,r){return r.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,r){var s={id:r||this.nextTrackID(),lastTimestamp:t,keypoints:Gn(e.keypoints).map(function(o){return Re({},o)})};return e.box!==void 0&&(s.box=Re({},e.box)),s},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(r){return!e.includes(r.id)})},n.prototype.reset=function(){this.tracks=[]},n}(),KD=function(n){function e(t){return n.call(this,t)||this}return jm(e,n),e.prototype.computeSimilarity=function(t){var r=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(s){return r.tracks.map(function(o){return r.iou(s,o)})})},e.prototype.iou=function(t,r){var s=Math.max(t.box.xMin,r.box.xMin),o=Math.max(t.box.yMin,r.box.yMin),i=Math.min(t.box.xMax,r.box.xMax),a=Math.min(t.box.yMax,r.box.yMax);if(s>=i||o>=a)return 0;var u=(i-s)*(a-o);return u/(t.box.width*t.box.height+r.box.width*r.box.height-u)},e}(ng),XD=function(n){function e(t){var r=n.call(this,t)||this;return r.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,r.keypointFalloff=t.keypointTrackerParams.keypointFalloff,r.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,r}return jm(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var r=[],s=0,o=t;s<o.length;s++){for(var i=o[s],a=[],u=0,l=this.tracks;u<l.length;u++){var c=l[u];a.push(this.oks(i,c))}r.push(a)}return r},e.prototype.oks=function(t,r){for(var s=this.area(r.keypoints)+1e-6,o=0,i=0,a=0;a<t.keypoints.length;++a){var u=t.keypoints[a],l=r.keypoints[a];if(!(u.score<this.keypointThreshold||l.score<this.keypointThreshold)){i+=1;var c=Math.pow(u.x-l.x,2)+Math.pow(u.y-l.y,2),h=2*this.keypointFalloff[a];o+=Math.exp(-1*c/(2*s*Math.pow(h,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(t){var r=this,s=t.filter(function(u){return u.score>r.keypointThreshold}),o=Math.min.apply(Math,Gn([1],s.map(function(u){return u.x}))),i=Math.max.apply(Math,Gn([0],s.map(function(u){return u.x}))),a=Math.min.apply(Math,Gn([1],s.map(function(u){return u.y})));return(i-o)*(Math.max.apply(Math,Gn([0],s.map(function(u){return u.y})))-a)},e}(ng);function rg(n){switch(n){case dt.BlazePose:return ms.reduce(function(e,t,r){return e[t]=r,e},{});case dt.PoseNet:case dt.MoveNet:return sn.reduce(function(e,t,r){return e[t]=r,e},{});default:throw new Error("Model "+n+" is not supported.")}}(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(Sn||(Sn={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(dt||(dt={}));Object.freeze({__proto__:null,getKeypointIndexBySide:function(n){switch(n){case dt.BlazePose:return cD;case dt.PoseNet:case dt.MoveNet:return hD;default:throw new Error("Model "+n+" is not supported.")}},getAdjacentPairs:function(n){switch(n){case dt.BlazePose:return dD;case dt.PoseNet:case dt.MoveNet:return pD;default:throw new Error("Model "+n+" is not supported.")}},getKeypointIndexByName:rg});var Ol=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],sg={modelType:"SinglePose.Lightning",enableSmoothing:!0},Fl={},Dl={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},oi={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Pl={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function qD(n,e,t,r){for(var s={},o=0,i=sn;o<i.length;o++){var a=i[o];s[a]=[e[t[a]].y*r.height,e[t[a]].x*r.width]}if(function($,S){return($[S.left_hip].score>.2||$[S.right_hip].score>.2)&&($[S.left_shoulder].score>.2||$[S.right_shoulder].score>.2)}(e,t)){var u=(s.left_hip[0]+s.right_hip[0])/2,l=(s.left_hip[1]+s.right_hip[1])/2,c=function($,S,T,N,k){for(var R=["left_shoulder","right_shoulder","left_hip","right_hip"],F=0,O=0,B=0;B<R.length;B++)(te=Math.abs(N-T[R[B]][0]))>F&&(F=te),(ne=Math.abs(k-T[R[B]][1]))>O&&(O=ne);for(var M=0,H=0,G=0,Y=Object.keys(T);G<Y.length;G++){var te,ne,ue=Y[G];$[S[ue]].score<.2||((te=Math.abs(N-T[ue][0]))>M&&(M=te),(ne=Math.abs(k-T[ue][1]))>H&&(H=ne))}return[F,O,M,H]}(e,t,s,u,l),h=c[0],p=c[1],d=c[2],f=c[3],g=Math.max(1.9*p,1.9*h,1.2*d,1.2*f),y=[u-(g=Math.min(g,Math.max(l,r.width-l,u,r.height-u))),l-g];if(g>Math.max(r.width,r.height)/2)return sa(n==null,r);var w=2*g;return{yMin:y[0]/r.height,xMin:y[1]/r.width,yMax:(y[0]+w)/r.height,xMax:(y[1]+w)/r.width,height:(y[0]+w)/r.height-y[0]/r.height,width:(y[1]+w)/r.width-y[1]/r.width}}return sa(n==null,r)}function sa(n,e){var t,r,s,o;return n?e.width>e.height?(t=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width):(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(t=e.width/e.height,r=1,s=(e.height/2-e.width/2)/e.height,o=0):(t=1,r=e.height/e.width,s=0,o=(e.width/2-e.height/2)/e.width),{yMin:s,xMin:o,yMax:s+t,xMax:o+r,height:t,width:r}}function YD(n){var e,t=n==null?sg:Re({},n);if(t.modelType==null)t.modelType="SinglePose.Lightning";else if(Ol.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+Ol);if(t.enableSmoothing==null&&(t.enableSmoothing=!0),t.minPoseScore!=null&&(t.minPoseScore<0||t.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(t.multiPoseMaxDimension!=null&&(t.multiPoseMaxDimension%32!=0||t.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(t.modelType==="MultiPose.Lightning"&&t.enableTracking==null&&(t.enableTracking=!0),t.modelType==="MultiPose.Lightning"&&t.enableTracking===!0)if(t.trackerType==null&&(t.trackerType=Sn.BoundingBox),t.trackerType===Sn.Keypoint)t.trackerConfig!=null?t.trackerConfig=function(r){var s=Ll(oi,r);return s.keypointTrackerParams=Re({},oi.keypointTrackerParams),r.keypointTrackerParams!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold=r.keypointTrackerParams.keypointConfidenceThreshold),r.keypointTrackerParams.keypointFalloff!=null&&(s.keypointTrackerParams.keypointFalloff=r.keypointTrackerParams.keypointFalloff),r.keypointTrackerParams.minNumberOfKeypoints!=null&&(s.keypointTrackerParams.minNumberOfKeypoints=r.keypointTrackerParams.minNumberOfKeypoints)),s}(t.trackerConfig):t.trackerConfig=oi;else{if(t.trackerType!==Sn.BoundingBox)throw new Error("Tracker type not supported by MoveNet");t.trackerConfig!=null?t.trackerConfig=(e=t.trackerConfig,Ll(Pl,e)):t.trackerConfig=Pl}return t}function Ll(n,e){var t={maxTracks:n.maxTracks,maxAge:n.maxAge,minSimilarity:n.minSimilarity};return e.maxTracks!=null&&(t.maxTracks=e.maxTracks),e.maxAge!=null&&(t.maxAge=e.maxAge),e.minSimilarity!=null&&(t.minSimilarity=e.minSimilarity),t}var QD=function(){function n(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=rg(dt.MoveNet),t.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):t.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=t.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new ra(Dl),this.cropRegionFilterYMin=new wn(.9),this.cropRegionFilterXMin=new wn(.9),this.cropRegionFilterYMax=new wn(.9),this.cropRegionFilterXMax=new wn(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===Sn.Keypoint?this.tracker=new XD(t.trackerConfig):t.trackerType===Sn.BoundingBox&&(this.tracker=new KD(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return n.prototype.runSinglePersonPoseModel=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,i;return we(this,function(a){switch(a.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==4||t.shape[0]!==1||t.shape[1]!==1||t.shape[2]!==17||t.shape[3]!==3)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Ys()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=a.sent(),a.label=3;case 3:for(t.dispose(),s={keypoints:[],score:0},o=0,i=0;i<17;++i)s.keypoints[i]={y:r[3*i],x:r[3*i+1],score:r[3*i+2]},s.keypoints[i].score>.2&&(++o,s.score+=s.keypoints[i].score);return o>0&&(s.score/=o),[2,s]}})})},n.prototype.runMultiPersonPoseModel=function(e){return be(this,void 0,void 0,function(){var t,r,s,o,i,a,u,l;return we(this,function(c){switch(c.label){case 0:if((t=this.moveNetModel.execute(e)).shape.length!==3||t.shape[0]!==1||t.shape[2]!==56)throw t.dispose(),new Error("Unexpected output shape from model: ["+t.shape+"]");return Ys()==="webgpu"?[3,1]:(r=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:r=c.sent(),c.label=3;case 3:for(t.dispose(),s=[],o=r.length/56,i=0;i<o;++i)for(s[i]={keypoints:[]},a=56*i+51,s[i].box={yMin:r[a],xMin:r[a+1],yMax:r[a+2],xMax:r[a+3],width:r[a+3]-r[a+1],height:r[a+2]-r[a]},u=56*i+55,s[i].score=r[u],s[i].keypoints=[],l=0;l<17;++l)s[i].keypoints[l]={y:r[56*i+3*l],x:r[56*i+3*l+1],score:r[56*i+3*l+2]};return[2,s]}})})},n.prototype.estimatePoses=function(e,t,r){return t===void 0&&(t=Fl),be(this,void 0,void 0,function(){var s,o,i,a,u,l;return we(this,function(c){switch(c.label){case 0:return t=function(h){return h==null?Fl:Re({},h)}(t),e==null?(this.reset(),[2,[]]):(r==null?eg(e)&&(r=1e6*e.currentTime):r*=1e3,s=Ga(e),o=gs(s),i=_t(s,0),e instanceof Xe||s.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,r)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,r)];case 3:a=c.sent(),c.label=4;case 4:for(u=0;u<a.length;++u)for(l=0;l<a[u].keypoints.length;++l)a[u].keypoints[l].name=sn[l],a[u].keypoints[l].y*=o.height,a[u].keypoints[l].x*=o.width;return[2,a]}})})},n.prototype.estimateSinglePose=function(e,t,r){return be(this,void 0,void 0,function(){var s,o,i,a,u=this;return we(this,function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=sa(this.cropRegion==null,t)),s=ie(function(){var c=qt([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),h=kn([1],"int32"),p=[u.modelInputResolution.height,u.modelInputResolution.width];return _e(xt.cropAndResize(e,c,h,p,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(s)];case 1:if(o=l.sent(),s.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return r!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,r,1)),a=qD(this.cropRegion,o.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},n.prototype.estimateMultiplePoses=function(e,t,r){return be(this,void 0,void 0,function(){var s,o,i,a,u,l,c,h,p,d,f,g=this;return we(this,function(y){switch(y.label){case 0:return t.width>t.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*t.height/t.width),s=xt.resizeBilinear(e,[i,o]),u=o,l=32*Math.ceil(i/32),a=Js(s,[[0,0],[0,l-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*t.width/t.height),i=this.multiPoseMaxDimension,s=xt.resizeBilinear(e,[i,o]),u=32*Math.ceil(o/32),l=i,a=Js(s,[[0,0],[0,0],[0,u-o],[0,0]])),s.dispose(),e.dispose(),c=_e(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=y.sent(),c.dispose(),h=h.filter(function(w){return w.score>=g.minPoseScore}),d=0;d<h.length;++d)for(p=0;p<h[d].keypoints.length;++p)h[d].keypoints[p].y*=l/i,h[d].keypoints[p].x*=u/o;if(this.enableTracking&&(this.tracker.apply(h,r),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new ra(Dl)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,r,1);f=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(w,$){f.has($)||g.keypointFilterMap.delete($)})}return[2,h]}})})},n.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),r=this.cropRegionFilterXMin.apply(e.xMin),s=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:r,yMax:s,xMax:o,height:s-t,width:o-r}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},n.prototype.dispose=function(){this.moveNetModel.dispose()},n.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},n.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},n}();function ZD(n){return n===void 0&&(n=sg),be(this,void 0,void 0,function(){var e,t,r,s;return we(this,function(o){switch(o.label){case 0:return e=YD(n),r=!0,e.modelUrl?(r=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,_r(e.modelUrl,{fromTFHub:r})]):[3,2];case 1:return t=o.sent(),[3,4];case 2:return s=void 0,e.modelType==="SinglePose.Lightning"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,_r(s,{fromTFHub:r})];case 3:t=o.sent(),o.label=4;case 4:return Ys()==="webgl"&&L().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new QD(t,e)]}})})}var Bl={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},Vl=["MobileNetV1","ResNet50"],Ml={MobileNetV1:[8,16],ResNet50:[16]},JD=[8,16,32],Ul={MobileNetV1:[.5,.75,1],ResNet50:[1]},Wl=[1,2,4],eP={maxPoses:1,flipHorizontal:!1},tP={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},nP=[-123.15,-115.9,-103.06];function ii(n){return Math.floor(n/2)}var rP=function(){function n(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return n.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(e){for(;e>0&&this.less(ii(e),e);)this.exchange(e,ii(e)),e=ii(e)},n.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},n.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},n.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},n.prototype.exchange=function(e,t){var r=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=r},n}();function sP(n,e,t,r,s,o){for(var i=o.shape,a=i[0],u=i[1],l=!0,c=Math.max(t-s,0),h=Math.min(t+s+1,a),p=c;p<h;++p){for(var d=Math.max(r-s,0),f=Math.min(r+s+1,u),g=d;g<f;++g)if(o.get(p,g,n)>e){l=!1;break}if(!l)break}return l}function oP(n){return be(this,void 0,void 0,function(){return we(this,function(e){return[2,Promise.all(n.map(function(t){return t.buffer()}))]})})}function og(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+17)}}function ig(n,e,t){var r=og(n.heatmapY,n.heatmapX,n.id,t),s=r.y,o=r.x;return{x:n.heatmapX*e+o,y:n.heatmapY*e+s}}function ag(n,e,t,r){var s=t.x,o=t.y;return n.some(function(i){var a,u,l,c,h,p,d=i.keypoints;return a=o,u=s,l=d[r].y,c=d[r].x,(h=l-a)*h+(p=c-u)*p<=e})}var zl=sn.reduce(function(n,e,t){return n[e]=t,n},{}),ug=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[zl[e],zl[t]]}),ai=ug.map(function(n){return n[1]}),Gl=ug.map(function(n){return n[0]});function Hl(n,e,t){return n<e?e:n>t?t:n}function ui(n,e,t,r){return{y:Hl(Math.round(n.y/e),0,t-1),x:Hl(Math.round(n.x/e),0,r-1)}}function jl(n,e){return{x:n.x+e.x,y:n.y+e.y}}function Kl(n,e,t,r,s,o,i,a){a===void 0&&(a=2);for(var u=r.shape,l=u[0],c=u[1],h={y:e.y,x:e.x},p=jl(h,function($,S,T){var N=T.shape[2]/2;return{y:T.get(S.y,S.x,$),x:T.get(S.y,S.x,N+$)}}(n,ui(h,o,l,c),i)),d=0;d<a;d++){var f=ui(p,o,l,c),g=og(f.y,f.x,t,s);p=jl({x:f.x*o,y:f.y*o},{x:g.x,y:g.y})}var y=ui(p,o,l,c),w=r.get(y.y,y.x,t);return{y:p.y,x:p.x,name:sn[t],score:w}}function iP(n,e,t,r,s,o){var i=e.shape[2],a=ai.length,u=new Array(i),l=n.part,c=n.score,h=ig(l,r,t);u[l.id]={score:c,name:sn[l.id],y:h.y,x:h.x};for(var p=a-1;p>=0;--p){var d=ai[p],f=Gl[p];u[d]&&!u[f]&&(u[f]=Kl(p,u[d],f,e,t,r,o))}for(p=0;p<a;++p)d=Gl[p],f=ai[p],u[d]&&!u[f]&&(u[f]=Kl(p,u[d],f,e,t,r,s));return u}function aP(n,e,t){return t.reduce(function(r,s,o){var i=s.y,a=s.x,u=s.score;return ag(n,e,{y:i,x:a},o)||(r+=u),r},0)/t.length}function uP(n,e,t,r,s,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),be(this,void 0,void 0,function(){var u,l,c,h,p,d,f,g,y,w,$,S;return we(this,function(T){switch(T.label){case 0:return[4,oP([n,e,t,r])];case 1:for(u=T.sent(),l=u[0],c=u[1],h=u[2],p=u[3],d=[],f=function(N,k,R){for(var F=R.shape,O=F[0],B=F[1],M=F[2],H=new rP(O*B*M,function(ue){return ue.score}),G=0;G<O;++G)for(var Y=0;Y<B;++Y)for(var te=0;te<M;++te){var ne=R.get(G,Y,te);ne<N||sP(te,ne,G,Y,k,R)&&H.enqueue({score:ne,part:{heatmapY:G,heatmapX:Y,id:te}})}return H}(i,1,l),g=a*a;d.length<o&&!f.empty();)y=f.dequeue(),w=ig(y.part,s,c),ag(d,g,w,y.part.id)||($=iP(y,l,c,s,h,p),S=aP(d,g,$),d.push({keypoints:$,score:S}));return[2,d]}})})}function lP(n){var e=n.shape,t=e[0],r=e[1],s=e[2];return ie(function(){var o,i,a=W(n,[t*r,s]),u=Ed(a,0),l=_t(Ie(u,de(r,"int32")),1),c=_t((o=u,i=r,ie(function(){var h=Ie(o,de(i,"int32"));return me(o,ee(h,de(i,"int32")))})),1);return bt([l,c],1)})}function cP(n,e,t){return ie(function(){var r=function(s,o){for(var i=[],a=0;a<sn.length;a++){var u=s.get(a,0).valueOf(),l=s.get(a,1).valueOf(),c=hP(u,l,a,o),h=c.x,p=c.y;i.push(p),i.push(h)}return qt(i,[sn.length,2])}(n,t);return ke(_e(ee(n.toTensor(),de(e,"int32")),"float32"),r)})}function hP(n,e,t,r){return{y:r.get(n,e,t),x:r.get(n,e,t+sn.length)}}function pP(n,e,t){return be(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,p;return we(this,function(d){switch(d.label){case 0:return r=0,s=lP(n),[4,Promise.all([n.buffer(),e.buffer(),s.buffer()])];case 1:return o=d.sent(),i=o[0],a=o[1],u=o[2],[4,(l=cP(u,t,a)).buffer()];case 2:return c=d.sent(),h=Array.from(function(f,g){for(var y=g.shape[0],w=new Float32Array(y),$=0;$<y;$++){var S=g.get($,0),T=g.get($,1);w[$]=f.get(S,T,$)}return w}(i,u)),p=h.map(function(f,g){return r+=f,{y:c.get(g,0),x:c.get(g,1),score:f,name:sn[g]}}),s.dispose(),l.dispose(),[2,{keypoints:p,score:r/p.length}]}})})}function Xl(n,e){return(n-1)%e==0}var ql="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",Yl="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function Ql(n,e){return function(t,r){return(t-1)%r==0}(n,e)?n:Math.floor(n/e)*e+1}var Zl=function(){function n(e,t){this.posenetModel=e;var r=this.posenetModel.inputs[0].shape;I(r[1]===-1&&r[2]===-1,function(){return"Input shape ["+r[1]+", "+r[2]+"] must both be equal to or -1"});var s,o,i=(s=t.inputResolution,o=t.outputStride,{height:Ql(s.height,o),width:Ql(s.width,o)});(function(a){I(JD.indexOf(a)>=0,function(){return"outputStride of "+a+" is invalid. It must be either 8 or 16."})})(t.outputStride),function(a,u){I(Xl(a.height,u),function(){return"height of "+a.height+" is invalid for output stride "+u+"."}),I(Xl(a.width,u),function(){return"width of "+a.width+" is invalid for output stride "+u+"."})}(i,t.outputStride),this.inputResolution=i,this.outputStride=t.outputStride,this.architecture=t.architecture}return n.prototype.estimatePoses=function(e,t){return t===void 0&&(t=eP),be(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,p,d,f,g,y,w;return we(this,function($){switch($.label){case 0:return r=function(S){var T=S;if(T.maxPoses==null&&(T.maxPoses=1),T.maxPoses<=0)throw new Error("Invalid maxPoses "+T.maxPoses+". Should be > 0.");if(T.maxPoses>1){if((T=Re(Re({},tP),T)).scoreThreshold<0||T.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+T.scoreThreshold+". Should be in range [0.0, 1.0]");if(T.nmsRadius<=0)throw new Error("Invalid nmsRadius "+T.nmsRadius+".")}return T}(t),e==null?[2,[]]:(this.maxPoses=r.maxPoses,s=na(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),o=s.imageTensor,i=s.padding,a=this.architecture==="ResNet50"?ke(o,nP):Jm(o,[-1,1]),u=this.posenetModel.predict(a),this.architecture==="ResNet50"?(l=Ne(u[2],[0]),c=Ne(u[3],[0]),h=Ne(u[0],[0]),p=Ne(u[1],[0])):(l=Ne(u[0],[0]),c=Ne(u[1],[0]),h=Ne(u[2],[0]),p=Ne(u[3],[0])),d=vs(c),this.maxPoses!==1?[3,2]:[4,pP(d,l,this.outputStride)]);case 1:return g=$.sent(),f=[g],[3,4];case 2:return[4,uP(d,l,h,p,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 3:f=$.sent(),$.label=4;case 4:return y=gs(e),w=function(S,T,N,k){var R=T.height,F=T.width,O=R/(N.height*(1-k.top-k.bottom)),B=F/(N.width*(1-k.left-k.right)),M=-k.top*N.height,H=-k.left*N.width;if(B===1&&O===1&&M===0&&H===0)return S;for(var G=0,Y=S;G<Y.length;G++)for(var te=0,ne=Y[G].keypoints;te<ne.length;te++){var ue=ne[te];ue.x=(ue.x+H)*B,ue.y=(ue.y+M)*O}return S}(f,y,this.inputResolution,i),r.flipHorizontal&&(w=function(S,T){for(var N=0,k=S;N<k.length;N++)for(var R=0,F=k[N].keypoints;R<F.length;R++){var O=F[R];O.x=T.width-1-O.x}return S}(w,y)),o.dispose(),a.dispose(),it(u),l.dispose(),c.dispose(),h.dispose(),p.dispose(),d.dispose(),[2,w]}})})},n.prototype.dispose=function(){this.posenetModel.dispose()},n.prototype.reset=function(){},n}();function dP(n){return n===void 0&&(n=Bl),be(this,void 0,void 0,function(){var e,t,r,s,o;return we(this,function(i){switch(i.label){case 0:return(e=function(c){var h=c||Bl;if(h.architecture==null&&(h.architecture="MobileNetV1"),Vl.indexOf(h.architecture)<0)throw new Error("Invalid architecture "+h.architecture+". Should be one of "+Vl);if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),Ml[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride "+h.outputStride+". Should be one of "+Ml[h.architecture]+" for architecture "+h.architecture+".");if(h.multiplier==null&&(h.multiplier=1),Ul[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier "+h.multiplier+". Should be one of "+Ul[h.architecture]+" for architecture "+h.architecture+".");if(h.quantBytes==null&&(h.quantBytes=4),Wl.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes "+h.quantBytes+". Should be one of "+Wl+" for architecture "+h.architecture+".");if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(n)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,u=e.quantBytes,l="model-stride"+a+".json",t=u===4?Yl+"float/"+l:Yl+"quant"+u+"/"+l,[4,_r(e.modelUrl||t)]);case 1:return r=i.sent(),[2,new Zl(r,e)];case 2:return s=function(c,h,p){var d={1:"100",.75:"075",.5:"050"},f="model-stride"+c+".json";return p===4?ql+"float/"+d[h]+"/"+f:ql+"quant"+p+"/"+d[h]+"/"+f}(e.outputStride,e.multiplier,e.quantBytes),[4,_r(e.modelUrl||s)];case 3:return o=i.sent(),[2,new Zl(o,e)]}var a,u,l})})}function fP(n,e){return be(this,void 0,void 0,function(){var t,r;return we(this,function(s){switch(n){case dt.PoseNet:return[2,dP(e)];case dt.BlazePose:if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,jD(e)];if(t.runtime==="mediapipe")return[2,xD(e)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r);case dt.MoveNet:return[2,ZD(e)];default:throw new Error(n+" is not a supported model name.")}})})}const mP={modeltype:void 0,enableSmoothing:!0,minPoseScore:0,multiPoseMaxDimension:256,enableTracking:!0,trackerType:Sn.BoundingBox,trackerConfig:{}},gP={architecture:"MobileNetV1",outputStride:16,multiplier:1,quantBytes:4},yP={runtime:"tfjs",enableSmoothing:!0,modelType:"full"};class xP{constructor(){this.model=null,this.detector=null}async createDetector(e){let t;e=="BlazePose"?t=yP:e=="PoseNet"?t=gP:t=mP,console.log("here"),this.detector=await fP(e,t)}async detectPose(e){if(this.detector)return await this.detector.estimatePoses(e);throw"Pose detection error: No detector setup."}}const Tn=document.getElementById("input-video");let at=null,li=null,ci;const bP=50,oa={MoveNet:.3,PoseNet:.5,BlazePose:.7},lg=new xP;let vr,ao;function wP(n){at=n[0]?n[0].keypoints:[];for(let e in at)at[e].x=Tn.width-at[e].x}function vP(n){if(at)for(let e in at){let t=at[e];t.score>oa[vr]&&(n.stroke(50,100,100),n.fill(0,100,100),n.ellipse(t.x,t.y,10,10),n.sqrt(n.pow(n.mouseX-t.x,2)+n.pow(n.mouseY-t.y,2))<15&&(n.fill(50,100,100),n.text(t.name,t.x+10,t.y+10)))}}function $P(n){n.push(),n.translate(n.width,0),n.scale(-1,1),n.drawingContext.drawImage(Tn,0,0),n.pop()}function SP(n){lg.detectPose(Tn).then(wP)}function TP(){navigator.mediaDevices.getUserMedia({video:!0,audio:!1}).then(n=>{let e=n.getVideoTracks()[0].getSettings().width,t=n.getVideoTracks()[0].getSettings().height;li=n,Tn.srcObject=li,Tn.width=e,Tn.height=t,ci=new MediaRecorder(li,{mimeType:"video/webm"}),lg.createDetector(vr).then(()=>{new p5(CP),ci.addEventListener("dataavailable",SP)}),ci.start(1e3/bP)})}document.getElementById("start").onclick=()=>{vr=document.getElementById("model").value,ao=document.getElementById("demo").value,TP(),document.getElementById("start").style="display: none;",document.getElementById("start-info").style="display: none;",document.getElementById("run-info").style="display: block;",ao=="keypoints"?document.getElementById("keypoint-info").style="display: block;":document.getElementById("kaleidoscope-info").style="display: block;",document.getElementById("model").setAttribute("disabled","disabled"),document.getElementById("demo").setAttribute("disabled","disabled")};const CP=n=>{let e=1,t=1,r=.5,s=0;n.setup=()=>{n.createCanvas(Tn.width,Tn.height),n.colorMode(n.HSB,100)},n.draw=()=>{if(n.background(255),n.noStroke(),$P(n),ao=="keypoints"&&vP(n),ao!="kaleidoscope"||!at||!at[9]||!at[10])return;if(at[9].score<oa[vr]||at[10].score<oa[vr])return;let o=9,i=10;vr=="BlazePose"&&(o=15,i=16);let a=at[o].x,u=at[o].y,l=at[i].x,c=at[i].y;t=n.sqrt(n.pow(a-l,2)+n.pow(u-c,2))/n.width;let h=(a+l)/2,p=(u+c)/2-50;r=3*t,s+=r/30;for(let d=0;d<12;d++){n.push(),n.translate(h,p),n.rotate(n.floor(d/2)*n.PI/3+s);let f=1;d%2!=0&&(f=-1),n.fill(92,50*e,70),n.ellipse(145*n.pow(t,1.3)*f,140*n.pow(t,1.3),30*f*t,50*t),n.fill(16,86*e,98),n.rect(100*n.pow(t,1.3)*f,70*n.pow(t,1.3),20*f*t,50*t),n.fill(12,62*e,90),n.ellipse(10*n.pow(t,1.4)*1.5*f,60*n.pow(t,1.4)*1.5,70*n.pow(t,1.4),150*n.pow(t,1.4)),n.fill(34,70*e,51),n.ellipse(0,2*n.pow(t,1.5)*1.5,50*n.pow(t,1.5),30*n.pow(t,1.5)),n.fill(96,79*e,66),n.ellipse(75*n.pow(t,1.3)*f,75*n.pow(t,1.3)*1.5,40*t,70*t),n.fill(91,92*e,38),n.ellipse(90*n.pow(t,1.2)*f,100*n.pow(t,1.2)*1.5,50*t,50*t),n.fill(51,73*e,96),n.rect(120*n.pow(t,1)*f,60*n.pow(t,1),30*f*t,65*t),n.pop()}for(let d=0;d<12;d++){n.push(),n.translate(h,p),n.rotate(n.floor(d/2)*n.PI/3+s);let f=1;d%2!=0&&(f=-1),n.fill(92,50*e,70),n.ellipse(20*n.pow(t,1.4)*1.5*f,40*n.pow(t,1.5)*1.5,48*t,70*t),n.fill(2,69*e,100),n.ellipse(25*n.pow(t,1.5)*1.5*f,50*n.pow(t,1.5)*1.5,40*t,60*t),n.fill(43,94*e,94),n.ellipse(75*n.pow(t,1.4)*1.2*f,150*n.pow(t,1.4)*1.2,90*t,55*t),n.fill(60,93*e,78),n.ellipse(5*n.pow(t,2)*.9*f,130*n.pow(t,2)*.9,90*t,55*t),n.fill(92,50*e,70),n.ellipse(5*n.pow(t,1.8)*.9*f,120*n.pow(t,1.8)*.9,30*t,30*t),n.fill(16,86,98),n.ellipse(0,0,10*t,16*t),n.stroke(7,80*e,100),n.strokeWeight(6),n.line(60*n.pow(t,.8)*.8*f,100*n.pow(t,.8)*.8,-20*n.pow(t,.8)*f,270*n.pow(t,1.5)),n.pop()}}};
